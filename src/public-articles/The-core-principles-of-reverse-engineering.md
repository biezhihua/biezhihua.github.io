# 逆向工程核心原理

那么，读者应该如何使用本书学习逆向分析技术呢？对此，我给出如下几点建议，供各位参考。
第一，技术书不是装饰书架的道具，它们是提高各位技术水平的工具。所以阅读时要勾画出重要部分，在书页空白处写下自己的想法与心得等。阅读时，在书页上记录相关技术、注意事项、技术优缺点、与作者的不同见解等，让它成为只属于你的书。读完这样一本逆向分析技术书后，不知不觉间就构建出自己独特的逆向分析世界，最终成为代码逆向分析专家。

第二，拥有积极乐观的心态。逆向分析是一项深奥的技术，会涉及OS底层知识。要学的内容很多，并且大部分内容需要亲自测试并确认才能最终理解。必须用积极乐观的心态对待这一过程，学习逆向技术无关聪明与否，只跟投入时间的多少有关。学习时，不要太急躁，请保持轻松的心态。

第三，不断挑战。逆向分析不尽如人意时，不要停下来，要尝试其他方法，不断挑战。要相信一定会有解决的方法，可能几年前早已有人成功过了。搜索相关资料并不断尝试，不仅能提高自身技术水平，解决问题后，心里还能感受到一种成就感。这样的成功经验一点点积累起来，自信心就会大大增强，自身的逆向分析水平也会得到明显提高。这种从经验中获得的自信会不知不觉地对逆向分析过程产生积极影响，让逆向分析往更好的方向发展。

希望本书能够帮助各位把“心愿表”上的愿望一一实现，也希望各位把本书讲解的知识、技术广泛应用到逆向分析过程中，发挥更大的作用。谢谢。

## 第一部分	代码逆向技术基础

### 第1章 关于逆向工程

1.1 逆向工程

1.2 代码逆向工程


1.2.1 逆向分析法


1.2.2  源代码、十六进制代码、汇编代码


1.2.3  “打补丁”与“破解”

1.3 代码逆向准备
1.3.1 目标
1.3.2 激情
1.3.3 谷歌

1.4  学习逆向分析技术的禁忌
1.4.1 贪心
1.4.2 急躁
1.5 逆向分析技术的乐趣

### 第2章	逆向分析Hello World!程序

2.1 Hello World!程序

2.2 调试HelloWorld. exe程序
2.2.1 调试目标
2.2.2 开始调试
2.2.3 入口点
2.2.4 跟踪40270C函数
2.2.5 跟踪40104F跳转语句
2.2.6 查找main()函数

2.3 进一步熟悉调试器
2.3.1 调试器指令
2.3.2  “大本营”
2.3.3 设置“大本营”的四种方法

2.4 快速查找指定代码的四种方法
2.4.1 代码执行法
2.4.2 字符串检索法
2.4.3 API检索法 (1): 在调用代码中设置断点
2.4.4 API检索法 (2): 在API代码中设置断点

2.5 使用“打补丁”方式修改“HelloWorld!”字符串
2.5.1  “打补丁”
2.5.2 修改字符串的两种方法

2.6 小结


### 第3章 小端序标记法
3.1 字节序
3.1.1 大端序与小端序
3.1.2 在OllyDbg中查看小端序

### 第4章 IA-32寄存器基本讲解
4.1 什么是CPU寄存器
4.2 IA-32寄存器

- 通用寄存器(General Purpose Registers,32位)
  - 各寄存器的名称如下所示。
    - EAX：（针对操作数和结果数据的）累加器
    - EBX:（DS段中的数据指针）基址寄存器
    - ECX：（字符串和循环操作的）计数器
    - EDX:（I/O指针）数据寄存器
    - 此外，ECX与EAX也可以用于特殊用途。循环命令(LOOP)中，ECX用来循环计数(loop count)，每执行一次循环，ECX都会减1.EAX一般用在函数返回值中，所有Win32API函数都会先把返回值保存到EAX再返回。
    - EBP:（SS段中栈内数据指针）扩展基址指针寄存器
    - ESI：（字符串操作源指针）源变址寄存器
    - EDI：（字符串操作目标指针）目的变址寄存器
    - ESP:（SS段中栈指针）栈指针寄存器
    - 以上4个寄存器主要用作保存内存地址的指针。
    - ESP指示栈区域的栈顶地址，某些指令(PUSH、POP、CALL、RET)可以直接用来操作ESP（栈区域管理是程序中相当重要的部分，请不要把ESP用作其他用途）。
    - EBP表示栈区域的基地址，函数被调用时保存ESP的值，函数返回时再把值返回ESP，保证栈不会崩溃（这称为栈帧(StackFrame)技术，它是代码逆向分析技术中的一个重要概念，后面会详细讲解）。
    - ESI和EDI与特定指令(LODS、STOS、REP、MOVS等)一起使用，主要用于内存复制。
- 段寄存器(Segment Registers,16位，6个)
  - CS: Code Segment, 代码段寄存器
  - SS: Stack Segment, 栈段寄存器
  - DS: Data Segment,数据段寄存器
  - ES: Extra(Data) Segment, 附加（数据）段寄存器
  - FS: Data Segment, 数据段寄存器
  - GS: Data Segment, 数据段寄存器
- 程序状态与控制寄存器(Program Status and Control Registers,32位，1个)
  - EFLAGS: Flag Register, 标志寄存器  
  - 学习代码逆向分析技术的初级阶段，只要掌握3个与程序调试相关的标志即可，分别为ZF(ZeroFlag，零标志)、OF (Overflow Flag, 溢出标志)、CF(Carry Flag, 进位标志)。
  - ZF 若运算结果为0, 则其值为1(True), 否则其值为0(False).
  - OF 有符号整数(signed integer) 溢出时, OF值被置为1。此外, MSB(Most Significant Bit,最高有效位)改变时，其值也被设为1.
  - CF 无符号整数(unsigned integer)溢出时，其值也被置为1.
- 指令指针寄存器(Instruction Pointer,32位，1个)
  - EIP: Instruction Pointer, 指令指针寄存器
  - 指令指针寄存器保存着CPU要执行的指令地址，其大小为32位（4个字节），由原16位IP寄存器扩展而来。程序运行时，CPU会读取EIP中一条指令的地址，传送指令到指令缓冲区后，EIP寄存器的值自动增加，增加的大小即是读取指令的字节大小。这样，CPU每次执行完一条指令，就会通过EIP寄存器读取并执行下一条指令。
  - 与通用寄存器不同，我们不能直接修改EIP的值，只能通过其他指令间接修改，这些特定指令包括JMP、Jcc、CALL、RET.此外，我们还可以通过中断或异常来修改EIP的值。

Intel® 64 和 IA-32 架构软件开发人员手册合并卷：1、2A、2B、2C、2D、3A、3B、3C、3D 和 4
- Volume 1: Basic Architecture
  - CHAPTER 3 BASIC EXECUTION ENVIRONMENT
    - 3.4 BASIC PROGRAM EXECUTION REGISTERS
      - 3.4.1 General-Purpose Registers
      - 3.4.2 Segment Registers
      - 3.4.3 EFLAGS Register
        - 3.4.3.1 Status Flags

4.3 小结

### 第5章 栈

5.1 栈

5.1.1 栈的特征

5.1.2 栈操作示例

向栈压入数据时，栈顶指针减小，向低地址移动；从栈中弹出数据时，栈顶指针增加，向高地址移动。

### 第6章 分析abex' crackme#1

6.1 abex' crackme #1
6.1.1 开始调试
6.1.2 分析代码

```shell
PUSH	入栈指令
CALL	调用指定位置的函数
INC	值加1
DEC	值减1
JMP	跳转到指定地址
CMP
比较给定的两个操作数 *与SUB命令类似，但操作数的值不会改变，仅改变EFLAGS寄存器（若2个操作数的值一致,SUB结果为0,ZF被置为1）
JE	条件跳转指令 (Jump if equal) *若ZF为1, 则跳转
```

6.2 破解

6.3 将参数压入栈

6.4 小结

### 第7章	栈帧

7.1 栈帧

栈帧(StackFrame)相关知识，栈帧在程序中用于声明局部变量、调用函数。

简言之，栈帧就是利用EBP（栈帧指针，请注意不是ESP）寄存器访问栈内局部变量、参数、函数返回地址等的手段。

为什么使用EBP而不是ESP？
程序运行中，ESP寄存器的值随时变化，访问栈中函数的局部变量、参数时，若以ESP值为基准编写程序会十分困难，并且也很难使CPU引用到准确的地址。
所以，调用某函数时，先要把用作基准点（函数起始地址）的ESP值保存到EBP,并维持在函数内部。
这样，无论ESP的值如何变化，以EBP的值为基准(base)能够安全访问到相关函数的局部变量、参数、返回地址，这就是EBP寄存器作为栈帧指针的作用。


栈帧结构
```bash
PUSH EBP	      ；函数开始（使用EBP前先把已有值保存到栈中）
MOV EBP, ESP	  ；保存当前ESP到EBP中
                ；函数体
                ；无论ESP值如何变化，EBP都保持不变，可以安全访问函数的局部变量、参数
MOV ESP, EBP	  ；将函数的起始地址返回到ESP中
POP EBP	        ；函数返回前弹出保存在栈中的EBP值
RETN	          ；函数终止
```

借助栈帧技术管理函数调用时，无论函数调用的深度有多深、多复杂，调用栈都能得到很好的管理与维护。

提示
- 最新的编译器中都带有一个“优化”(Optimization)选项，使用该选项编译简单的函数将不会生成栈帧。
- 在栈中保存函数返回地址是系统安全隐患之一，攻击者使用缓冲区溢出技术能够把保存在栈内存的返回地址更改为其他地址。

7.2 调试示例：stackframe. exe

7.2.1 StackFrame.cpp

```c
#include "stdio.h"

long add(long a, long b) 
{
	long x = a, y = b;
	return (x+y);
}

int main(int argc, char* argv[])
{
	long a = 1, b = 2;
	long c = add(a, b);
	printf("Sum of %ld and %ld is %ld\n", a, b, c);
	return 0;
}
```

7.2.2 开始执行main()函数&生成栈帧

```shell
004D18D0 <stackfram | 55                 | push ebp                                   | StackFrame.c:12
004D18D1            | 8BEC               | mov ebp,esp                                |
004D18D3            | 81EC E4000000      | sub esp,E4                                 | 生成栈空间
004D18D9            | 53                 | push ebx                                   |
004D18DA            | 56                 | push esi                                   | 
004D18DB            | 57                 | push edi                                   |
004D18DC <stackfram | 8D7D DC            | lea edi,dword ptr ss:[ebp-24]              | 初始化局部变量空间
004D18DF            | B9 09000000        | mov ecx,9                                  | 
004D18E4            | B8 CCCCCCCC        | mov eax,CCCCCCCC                           | 
004D18E9            | F3:AB              | rep stosd                                  |
```

7.2.3 设置局部变量

```shell
004D18F6            | C745 F8 01000000   | mov dword ptr ss:[ebp-8],1                 | 把数据1保存到[EBP-8]中，[EBP-8]代表局部变量a
004D18FD            | C745 EC 02000000   | mov dword ptr ss:[ebp-14],2                | 把数据1保存到[EBP-14]中，[EBP-14]代表局部变量b
```

提示
DWORD PTR SS:[EBP-4]语句中, SS是Stack Segment的缩写，表示栈段。由于Windows中使用的是段内存模型(Segment Memory Model), 使用时需要指出相关内存属于哪一个区段。其实，32位的Windows OS中, SS、DS、ES的值皆为0, 所以采用这种方式附上区段并没有什么意义。因EBP与ESP是指向栈的寄存器，所以添加上了SS寄存器。请注意,“DWORD PTR”与“SS:”等字符串可以通过设置OllyDbg的相应选项来隐藏。

7.2.4 add()函数参数传递与调用

```shell
004D1904            | 8B45 EC            | mov eax,dword ptr ss:[ebp-14]              | 
004D1907            | 50                 | push eax                                   | arg2
004D1908            | 8B4D F8            | mov ecx,dword ptr ss:[ebp-8]               | 
004D190B            | 51                 | push ecx                                   | arg1
004D190C            | E8 12F7FFFF        | call stackframe.4D1023                     | call的同时会push下一个指令的地址004D1911，也叫做返回地址
```

返回地址
执行CALL命令进入被调用的函数之前，CPU会先把函数的返回地址压入栈，用作函数执行完毕后的返回地址。

```shell
0041FA90      004D1911          return to stackframe.__$EncStackInitEnd+26 from stackframe.__enc$textbss$end+23
0041FA94      00000001          
0041FA98      00000002          
```

7.2.5 开始执行add()函数&生成栈帧

```shell
004D18 | 55                 | push ebp                                                   | StackFrame.c:6
004D18 | 8BEC               | mov ebp,esp                                                |
004D18 | 81EC D8000000      | sub esp,D8                                                 |
```

可以看到，main（）函数使用的EBP值被备份到栈中，然后EBP的值被设置为一个新值。

7.2.6 设置add()函数的局部变量(x,y)

```shell
004D18 | 8B45 08            | mov eax,dword ptr ss:[ebp+8]                               | 取出参数a
004D18 | 8945 F8            | mov dword ptr ss:[ebp-8],eax                               | 设置局部变量值
004D18 | 8B45 0C            | mov eax,dword ptr ss:[ebp+C]                               | 取出参数b
004D18 | 8945 EC            | mov dword ptr ss:[ebp-14],eax                              | 设置局部变量值
```

```shell
0040FCC8          CCCCCCCC     
0040FCCC          00000002     
0040FCD0          CCCCCCCC     
0040FCD4          CCCCCCCC     
0040FCD8          00000001     
0040FCDC          CCCCCCCC     
0040FCE0          0040FDE0     EBP  
0040FCE4          004D1911     return to stackframe.__$EncStackInitEnd+26 from stackframe.__enc$textbss$end+23
0040FCE8          00000001     
0040FCEC          00000002     
```

7.2.7 ADD运算

```shell
004D18A2            | 8B45 F8            | mov eax,dword ptr ss:[ebp-8]               | 使用局部变量计算
004D18A5            | 0345 EC            | add eax,dword ptr ss:[ebp-14]              |
```

7.2.8 删除函数add()的栈帧&函数执行完毕（返回）

```shell
004D18B8  | 8BE5               | mov esp,ebp                                                |
004D18BA  | 5D                 | pop ebp                                                    |
004D18BB  | C3                 | ret                                                        |
```

上面这条命令用于恢复函数add（）开始执行时备份到栈中的EBP值，它与401000地址处的PUSH EBP命令对应。EBP值恢复为12FF40, 它是main（）函数的EBP值。到此, add（）函数的栈帧就被删除了。

```shell
0040FCE4          004D1911     return to stackframe.__$EncStackInitEnd+26 from stackframe.__enc$textbss$end+23
0040FCE8          00000001     
0040FCEC          00000002     
```

7.2.9 从栈中删除函数add()的参数（整理栈）

```shell
004D1904  | 8B45 EC            | mov eax,dword ptr ss:[ebp-14]                              | StackFrame.c:14
004D1907  | 50                 | push eax                                                   |
004D1908  | 8B4D F8            | mov ecx,dword ptr ss:[ebp-8]                               | ecx:_2339CD9D_StackFrame@c
004D190B  | 51                 | push ecx                                                   | ecx:_2339CD9D_StackFrame@c
004D190C  | E8 12F7FFFF        | call stackframe.4D1023                                     |
004D1911  | 83C4 08            | add esp,8                                                  |
```

```shell
0040FCE8          00000001     
0040FCEC          00000002     
0040FCF0 <&EntryP 004D1028     ESP
0040FCF4 <&EntryP 004D1028     stackframe.__enc$textbss$end+28
```

提示
- 被调函数执行完毕后，函数的调用者(Caller)负责清理存储在栈中的参数，这种方式称为cdecl方式；
- 反之，被调用者(Callee)负责清理保存在栈中的参数，这种方式称为stdcall方式。这些函数调用规则统称为调用约定(Calling Convention), 这在程序开发与分析中是一个非常重要的概念，第10章将进一步讲解相关内容。

7.2.10 调用printf()函数

```shell
004D1914            | 8945 E0            | mov dword ptr ss:[ebp-20],eax              |
004D1917            | 8B45 E0            | mov eax,dword ptr ss:[ebp-20]              | StackFrame.c:15
004D191A            | 50                 | push eax                                   |
004D191B            | 8B4D EC            | mov ecx,dword ptr ss:[ebp-14]              |
004D191E            | 51                 | push ecx                                   |
004D191F            | 8B55 F8            | mov edx,dword ptr ss:[ebp-8]               |
004D1922            | 52                 | push edx                                   |
004D1923            | 68 307B4D00        | push stackframe.4D7B30                     | 4D7B30:"Sum of %ld and %ld is %ld\n"
004D1928            | E8 AAF7FFFF        | call stackframe.4D10D7                     |
004D192D            | 83C4 10            | add esp,10                                 |
```

7.2.11 设置返回值

```shell
004D1930            | 33C0               | xor eax,eax                                | StackFrame.c:16
```

XOR命令用来进行Exclusive OR bit（异或）运算，其特点为“2个相同的值进行XOR运算，结果为0”.XOR命令比MOV EAX，0命令执行速度快，常用于寄存器的初始化操作。

7.2.12 删除栈帧& main()函数终止

```shell
004D1942            | 8BE5               | mov esp,ebp                                |
004D1944            | 5D                 | pop ebp                                    |
004D1945            | C3                 | ret                                        |
```

7.3 设置OllyDbg选项
7.3.1 Disasm选项
7.3.2 Analysis1选项

7.4 小结

### 第8章 abex' crackme#2 

8.1 运行abex' crackme#2 

8.2 Visual Basic文件的特征
8.2.1 VB专用引擎 
8.2.2 本地代码和伪代码
8.2.3 事件处理程序
8.2.4 未文档化的结构体

8.3 开始调试 

```shell
00401238  | 68 141E4000        | push abex' crackme #2.401E14                               |
0040123D  | E8 F0FFFFFF        | call <JMP.&ThunRTMain>                                     |
```
8.3.1 间接调用 

8.3.2 RT MainStruct结构体

8.3.3 ThunRTMain()函数

8.4 分析crackme

8.4.1 检索字符串

TEST: 逻辑比较(Logical Compare)
与bit-wise logical`AND'一样（仅改变EFLAGS寄存器而不改变操作数的值）若2个操作数中一个为0，则AND运算结果被置为0 -> ZF = 1 。
JE: 条件转移指令(Jump if equal)
若ZF=1,  则跳转。

8.4.2 查找字符串地址

```shell
00403321  | 8D55 BC            | lea edx,dword ptr ss:[ebp-44]                              |
00403324  | 8D45 CC            | lea eax,dword ptr ss:[ebp-34]                              |
00403327  | 52                 | push edx                                                   |
00403328  | 50                 | push eax                                                   |
00403329  | FF15 58104000      | call dword ptr ds:[<&__vbaVarTstEq>]                       |
0040332F  | 66:85C0            | test ax,ax                                                 |
00403332  | 0F84 D0000000      | je abex' crackme #2.403408                                 |
```

8.4.3 生成Serial的算法

```shell
00402ED0  | 55                 | push ebp                                                   |
00402ED1  | 8BEC               | mov ebp,esp                                                |
```

NOP: No Operation, 不执行任何动作的指令（只消耗CPU时钟）。

8.4.4 预测代码

```shell
00402F8E  | 8D95 78FFFFFF      | lea edx,dword ptr ss:[ebp-88]                              | [ebp-88]:L"BIEZHIHUA"
00402F94  | 52                 | push edx                                                   |
00402F95  | 56                 | push esi                                                   |
00402F96  | 8B0E               | mov ecx,dword ptr ds:[esi]                                 |
00402F98  | FF91 A0000000      | call dword ptr ds:[ecx+A0]                                 |
```

8.4.5 读取Name字符串的代码

8.4.6 加密循环

```shell
00403102  | BB 04000000        | mov ebx,4                                                  |

0040318B  | FF15 30104000      | call dword ptr ds:[<&__vbaVarForInit>]                     |
00403191  | 8B1D 4C104000      | mov ebx,dword ptr ds:[<&rtcMidCharVar>]                    |
00403197  | 85C0               | test eax,eax                                               |
00403199  | 0F84 06010000      | je abex' crackme #2.4032A5                                 |

0040329A  | FF15 C0104000      | call dword ptr ds:[<&__vbaVarForNext>]                     |
004032A0  | E9 F2FEFFFF        | jmp abex' crackme #2.403197                                |
004032A5  | 8B45 08            | mov eax,dword ptr ss:[ebp+8]                               |
```

8.4.7 加密方法

8.5 小结

## 第9章 Process Explorer———最优秀的进程管理工具 
9.1 Process Explorer
9.2 具体有哪些优点呢
9.3 sysinternals

### 第10章	函数调用约定

10.1 函数调用约定

函数调用约定(Calling Convention) |

主要的函数调用约定如下。
- cdecl
- stdcall
- fastcall
  
术语说明
- 调用者————调用函数的一方。
- 被调用者————被调用的函数。
- 比如在main()函数中调用printf()函数时，调用者为main(),被调用者为printf().

10.1.1 cdecl

cdecl是主要在C语言中使用的方式，调用者负责处理栈。

```C
int add(int a, int b)
{
	return a + b;
}

int main(int argc, char* argv[])
{
	return add(1, 2);
}
```

```shell
00EF17F2  | 6A 02              | push 2                                                     | cdecl.c:12
00EF17F4  | 6A 01              | push 1                                                     |
00EF17F6  | E8 28F8FFFF        | call cdecl.EF1023                                          |
00EF17FB  | 83C4 08            | add esp,8                                                  |
```

```shell
00EF1F10  | 55                 | push ebp                                                   | exe_common.inl:77
00EF1F11  | 8BEC               | mov ebp,esp                                                |
00EF1F13  | 83EC 0C            | sub esp,C                                                  |
00EF1F16  | E8 83F3FFFF        | call cdecl.EF129E                                          | exe_common.inl:78
00EF1F1B  | 8945 FC            | mov dword ptr ss:[ebp-4],eax                               | [ebp-4]:&"ALLUSERSPROFILE=C:\\ProgramData"
00EF1F1E  | E8 85F3FFFF        | call cdecl.EF12A8                                          |
00EF1F23  | 8B00               | mov eax,dword ptr ds:[eax]                                 |
00EF1F25  | 8945 F8            | mov dword ptr ss:[ebp-8],eax                               | [ebp-8]:&"E:\\Projects\\VisualStudioProjects\\cdecl\\Debug\\cdecl.exe"
00EF1F28  | E8 3CF1FFFF        | call cdecl.EF1069                                          |
00EF1F2D  | 8B08               | mov ecx,dword ptr ds:[eax]                                 | ecx:_E28DA64E_cdecl@c
00EF1F2F  | 894D F4            | mov dword ptr ss:[ebp-C],ecx                               | ecx:_E28DA64E_cdecl@c
00EF1F32  | 8B55 FC            | mov edx,dword ptr ss:[ebp-4]                               | [ebp-4]:&"ALLUSERSPROFILE=C:\\ProgramData"
00EF1F35  | 52                 | push edx                                                   |
00EF1F36  | 8B45 F8            | mov eax,dword ptr ss:[ebp-8]                               | [ebp-8]:&"E:\\Projects\\VisualStudioProjects\\cdecl\\Debug\\cdecl.exe"
00EF1F39  | 50                 | push eax                                                   |
00EF1F3A  | 8B4D F4            | mov ecx,dword ptr ss:[ebp-C]                               | ecx:_E28DA64E_cdecl@c
00EF1F3D  | 51                 | push ecx                                                   | ecx:_E28DA64E_cdecl@c
00EF1F3E  | E8 92F3FFFF        | call cdecl.EF12D5                                          |
00EF1F43  | 83C4 0C            | add esp,C                                                  |
00EF1F46  | 8BE5               | mov esp,ebp                                                | exe_common.inl:79
00EF1F48  | 5D                 | pop ebp                                                    |
00EF1F49  | C3                 | ret                                                        |
```

10.1.2 stdcall


```shell
00F41780  | 55                 | push ebp                                                   | cdecl.c:6
00F41781  | 8BEC               | mov ebp,esp                                                |
00F41783  | 81EC C0000000      | sub esp,C0                                                 |
00F41789  | 53                 | push ebx                                                   |
00F4178A  | 56                 | push esi                                                   | esi:__enc$textbss$end+23
00F4178B  | 57                 | push edi                                                   |
00F4178C  | 8BFD               | mov edi,ebp                                                |
00F4178E  | 33C9               | xor ecx,ecx                                                | ecx:_E28DA64E_cdecl@c
00F41790  | B8 CCCCCCCC        | mov eax,CCCCCCCC                                           | eax:_E28DA64E_cdecl@c
00F41795  | F3:AB              | rep stosd                                                  |
00F41797  | B9 00C0F400        | mov ecx,<cdecl._E28DA64E_cdecl@c>                          | cdecl.c:15732480, ecx:_E28DA64E_cdecl@c
00F4179C  | E8 7FFBFFFF        | call cdecl.F41320                                          |
00F417A1  | 90                 | nop                                                        |
00F417A2  | 8B45 08            | mov eax,dword ptr ss:[ebp+8]                               | cdecl.c:7, eax:_E28DA64E_cdecl@c
00F417A5  | 0345 0C            | add eax,dword ptr ss:[ebp+C]                               | eax:_E28DA64E_cdecl@c, [ebp+C]:&"E:\\Projects\\VisualStudioProjects\\cdecl\\Debug\\cdecl.exe"
00F417A8  | 5F                 | pop edi                                                    | cdecl.c:8
00F417A9  | 5E                 | pop esi                                                    | esi:__enc$textbss$end+23
00F417AA  | 5B                 | pop ebx                                                    |
00F417AB  | 81C4 C0000000      | add esp,C0                                                 |
00F417B1  | 3BEC               | cmp ebp,esp                                                |
00F417B3  | E8 8CFAFFFF        | call cdecl.F41244                                          |
00F417B8  | 8BE5               | mov esp,ebp                                                |
00F417BA  | 5D                 | pop ebp                                                    |
00F417BB  | C2 0800            | ret 8                                                      |
```

10.1.3 fastcall

### 第11章	视频讲座
11.1 运行
11.2 分析 
11.2.1 目标 (1): 去除消息框
11.2.2 打补丁 (1): 去除消息框
11.2.3 目标 (2): 查找注册码
11.3 小结

### 第12章	究竟应当如何学习代码逆向分析
12.1 逆向工程 
12.1.1 任何学习都应当有目标
12.1.2 拥有积极心态
12.1.3 要感受其中的乐趣
12.1.4 让检索成为日常生活的一部分
12.1.5 最重要的是实践
12.1.6 请保持平和的心态

代码逆向分析技术的初学者最容易犯的毛病是急躁。总想快速出成果，结果学习却不见起色，技术水平原地踏步。
自己究竟还有多少不懂、能不能顺利进行下去，这都让人一头雾水、心烦不已。
汇编、Windows内部结构、PE文件格式、API钩取等都不是易学的内容，仅汇编一项就学无止境。
此时心浮气躁就很容易放弃目标。

## 第二部分 PE文件格式

### 第13章 PE文件格式⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯90
13.1 介绍⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯90
13.2 PE文件格式⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯90
13.2.1 基本结构⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯91
13.2.2 VA&RVA⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯92
13.3 PE头⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯92
13.3.1 DOS头⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯93
13.3.2 DOS存根⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯94
13.3.3 NT头⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯94
13.3.4 NT头：文件头⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯95
13.3.5 NT头：可选头⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯97
13.3.6 节区头………………………………………………101
13.4 RVA to RAW⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯104
13.5 IAT⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯105
13.5.1 DLL…………………………………………………105
13.5.2 IMAGE IMPORT DESCRIPTOR………………………………107
13.5.3 使用notepad. exe练习⋯⋯⋯⋯⋯⋯108
13.6 EAT⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯112
13.6.1 IMAGE EXPORT DIRECTORY………………………………113
13.6.2 使用kernel32. dll练习………………114
13.7 高级PE⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯116
13.7.1 PEView.exe⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 116
13.7.2 Patched PE⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯117
13.8 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯118

### 第14章	运行时压缩⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯121
14.1 数据压缩⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯121
14.1.1 无损压缩…………………………………………121
14.1.2 有损压缩……………………………………………121
14.2 运行时压缩器⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯122
14.2.1 压缩器⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯122
14.2.2 保护器⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯123
14.3 运行时压缩测试⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯123

### 第15章	调试UPX压缩的notepad 程序⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯127
15.1 notepad. exe的EP代码⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯127
15.2 notepad upx. exe的EP代码⋯⋯⋯⋯⋯⋯⋯⋯127
15.3 跟踪UPX文件⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯129
15.3.1 OllyDbg的跟踪命令⋯⋯⋯⋯⋯⋯⋯129
15.3.2 循环#1⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯129
15.3.3 循环#2⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯130
15.3.4 循环#3………………………………………………131
15.3.5 循环#4⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯131
15.4快速查找UPX OEP的方法⋯⋯⋯⋯⋯⋯⋯⋯132
15.4.1 在POPAD指令后的JMP
指令处设置断点⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯132
15.4.2 在栈中设置硬件断点⋯⋯⋯⋯⋯⋯⋯133
15.5 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯133

### 第16章	基址重定位表⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯135
16.1 PE重定位⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯135
16.1.1 DLL/SYS⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯135
16.1.2 EXE⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯136
16.2 PE重定位时执行的操作⋯⋯⋯⋯⋯⋯⋯⋯⋯136
16.3 PE重定位操作原理⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯138
16.3.1 基址重定位表⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯138
16.3.2  IMAGE BASE RELOCATION
结构体⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯139
16.3.3 基址重定位表的分析方法……139
16.3.4 练习⋯⋯⋯⋯⋯⋯⋯⋯141

### 第17章	从可执行文件中删除. reloc
节区⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯142
17.1 . reloc节区⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯142
17.2 reloc.exe⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 142
17.2.1 删除. reloc节区头⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯142
17.2.2 删除. reloc节区⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯143
17.2.3 修改IMAGE FILE HEADER…………………………………………143
17.2.4修改IMAGE OPTIONAL HEADER⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯144
17.3 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯145

### 第18章 UPack PE文件头详细分析⋯⋯⋯146
18.1 UPack说明⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯146
18.2 使用UPack压缩notepad. exe…………………146
18.3 使用Stud PE工具⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯148
18.4 比较PE文件头⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯148
18.4.1 原notepad. exe的PE文件头⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯149
18.4.2 notepad upack. exe运行时压缩的PE文件头⋯⋯⋯⋯⋯⋯⋯⋯⋯ 149
18.5 分析UPack的PE文件头⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯150
18.5.1 重叠文件头⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯150
18.5.2 IMAGE FILE HEADER.SizeOfOptionalHeader⋯⋯⋯⋯⋯⋯ 150
18.5.3 IMAGE OPTIONAL HEADER. NumberOfRvaAndSizes……………………………………152
18.5.4 IMAGE SECTION HEADER⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯153
18.5.5 重叠节区⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯155
18.5.6 RVA to RAW⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯156
18.5.7 导入表 (IMAGE IMPORT DESCRIPTOR array)…………………158
18.5.8 导入地址表⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯160
18.6 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯161

### 第19章 UPack调试-查找OEP⋯⋯⋯⋯⋯⋯162
19.1 OllyDbg运行错误⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯162
19.2 解码循环⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯163
19.3 设置IAT⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 165
19.4 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯166

### 第20章  “内嵌补丁”练习⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯167
20.1 内嵌补丁⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯167
20.2 练习：Patchme………………………………………………168
20.3 调试：查看代码流……………………………………………168
20.4 代码结构⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯172
20.5  “内嵌补丁”练习⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯173
20.5.1 补丁代码要设置在何处呢⋯⋯⋯173
20.5.2 制作补丁代码……………………………………175
20.5.3 执行补丁代码…………………………………176
20.5.4 结果确认……………………………………………177

## 第三部分 DLL注入
### 第21章 Windows消息钩取⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯180
21.1 钩子⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯180
21.2 消息钩子⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯180
21.3 SetWindowsHookEx()⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯181
21.4 键盘消息钩取练习⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯182
21.4.1 练习示例HookMain. exe⋯⋯⋯⋯182
21.4.2 分析源代码………………………………………185
21.5 调试练习⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯187
21.5.1 调试HookMain. exe⋯⋯⋯⋯⋯⋯⋯⋯188
21.5.2 调试Notepad. exe进程内的
KeyHook. dll⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 190
21.6 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯192

### 第22章	恶意键盘记录器⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯194
22.1 恶意键盘记录器的目标⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯194
22.1.1 在线游戏⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯194
22.1.2 网上银行⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯194
22.1.3 商业机密泄露⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯194
22.2 键盘记录器的种类与发展趋势⋯⋯⋯⋯⋯⋯195
22.3 防范恶意键盘记录器⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯195
22.4 个人信息⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯195
### 第23章 DLL注入⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯197
23.1 DLL注入⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯197
23.2 DLL注入示例⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯198
23.2.1 改善功能与修复Bug⋯⋯⋯⋯⋯⋯⋯ 198
23.2.2 消息钩取⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯198
23.2.3 API钩取⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯198
23.2.4 其他应用程序⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯199
23.2.5 恶意代码……………………………………………199
23.3 DLL注入的实现方法⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯199
23.4 CreateRemoteThread()⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯199
23.4.1 练习示例myhack. dll……………………199
23.4.2 分析示例源代码⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯203
23.4.3 调试方法⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯208
23.5 AppInit DLLs⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯210
23.5.1 分析示例源码…………………………………211
23.5.2 练习示例myhack2. dll………………212
23.6 SetWindowsHookEx()⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯214
23.7 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯214

### 第24章 DLL卸载………………………………………………216
24.1 DLL卸载的工作原理⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯216
24.2 实现DLL卸载⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯216
24.2.1 获取进程中加载的DLL信息…219
24.2.2 获取目标进程的句柄…………………220
24.2.3 获取FreeLibrary()API地址……220
24.2.4 在目标进程中运行线程……………220
24.3 DLL卸载练习⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯220
24.3.1 复制文件及运行notepad. exe…220
24.3.2 注入myhack. dll……………………………221
24.3.3 卸载myhack.dll⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 222
### 第25章	通过修改PE加载DLL…………………224
25.1 练习文件⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯224
25.1.1 TextView.exe⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 224
25.1.2 TextView patched.exe⋯⋯⋯⋯⋯⋯⋯ 225
25.2 源代码-myhack3. cpp…………………………………227
25.2.1 DllMain()⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯227
25.2.2 DownloadURL()⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯228
25.2.3 DropFile()⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯229
25.2.4 dummy()⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯230
25.3 修改TextView. exe文件的准备工作⋯⋯231
25.3.1 修改思路⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯231
25.3.2 查看IDT是否有足够空间……231
25.3.3 移动IDT⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯233
25.4 修改TextView.exe⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 235
25.4.1 修改导入表的RVA值⋯⋯⋯⋯⋯⋯235
25.4.2 删除绑定导入表……………………………235
25.4.3 创建新IDT⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯235
25.4.4 设置Name、INT、IAT⋯⋯⋯⋯⋯236
25.4.5 修改IAT节区的属性值……………238
25.5 检测验证⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯240
25.6 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯241

### 第26章 PE Tools·	…………………………………………242
26.1 PE Tools⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯242
26.1.1 进程内存转储⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯243
26.1.2 PE编辑器…………………………………………245
26.2 小结……………………………………………………………………245
### 第27章	代码注入……………………………………………247
27.1 代码注入⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯247
27.2 DLL注入与代码注入⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯247
27.3 练习示例⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯249
27.3.1 运行notepad.exe⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 249
27.3.2 运行CodeInjection.exe⋯⋯⋯⋯⋯ 249
27.3.3 弹出消息框⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯250
27.4 CodeInjection. cpp⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯250
27.4.1 main()函数…………………………………………251
27.4.2 ThreadProc()函数⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯251
27.4.3 InjectCode()函数⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯254
27.5 代码注入调试练习⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯256
27.5.1 调试notepad. exe……………………………256
27.5.2 设置OllyDbg选项………………………256
27.5.3 运行CodeInjection.exe⋯⋯⋯⋯⋯⋯ 257
27.5.4 线程开始代码……………………………………258
27.6 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯259

### 第第28章	使用汇编语言编写注入代码……260
28.1 目标⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯260
28.2 汇编编程⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯260
28.3 OllyDbg的汇编命令………………………………………260
28.3.1 编写ThreadProc()函数…………………262
28.3.2 保存文件……………………………………………265
28.4 编写代码注入程序⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯266
28.4.1 获取ThreadProc()函数的二进制代码………………………………………266
28.4.2 CodeInjection2. cpp…………………………267
28.5 调试练习⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯270
28.5.1 调试notepad.exe⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 270
28.5.2 设置OllyDbg选项⋯⋯⋯⋯⋯⋯⋯⋯⋯270
28.5.3 运行CodeInjection2.exe⋯⋯⋯⋯⋯ 271
28.5.4 线程起始代码⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯272
28.6 详细分析⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯272
28.6.1 生成栈帧………………………………………………272
28.6.2 THREAD PARAM结构体指针…………………………………………………………273
28.6.3  "User32. dll"字符串⋯⋯⋯⋯⋯⋯⋯⋯274
28.6.4 压入“user32. dll”字符串参数……………………………………………………274
28.6.5 调用LoadLibraryA("user32. dll")………………………………………275
28.6.6  "MessageBoxA"字符串⋯⋯⋯⋯276
28.6.7 调用 GetProcAddress(hMod,"MessageBoxA")…………………………276
28.6.8 压入MessageBoxA()函数的参数1-MB OK……………………………277
28.6.9 压入MessageBoxA()函数的参数2- "ReverseCore"…………277
28.6.10 压入MessageBoxA()函数的参数3-"www.reversecore.com"……………………………………………278
28.6.11 压入MessageBoxA()函数的参数4-NULL………………………………279
28.6.12	调用MessageBoxA()………………279
28.6.13	设置ThreadProc()函数的
返回值………………………………………………280
28.6.14 删除栈帧及函数返回⋯⋯⋯⋯⋯⋯280
28.7 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯280

## 第四部分 API钩取
### 第29章 API钩取：逆向分析之“花”…282
29.1 钩取⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯282
29.2 API是什么⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯282
29.3 API钩取⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯283
29.3.1 正常调用API⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯283
29.3.2 钩取API调用⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯284
29.4 技术图表⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯284
29.4.1 方法对象（是什么）…………………285
29.4.2 位置（何处）⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯285
29.4.3 技术（如何）⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯286
29.4.4 API⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯286
### 第30章	记事本WriteFile()API钩取……288
30.1 技术图表-调试技术⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯288
30.2 关于调试器的说明⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯289
30.2.1 术语⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯289
30.2.2 调试器功能⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯289
30.2.3 调试器的工作原理⋯⋯⋯⋯⋯⋯⋯⋯⋯289
30.2.4 调试事件…………………………………………289
30.3 调试技术流程⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯290
30.4 练习⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯291
30.5 工作原理⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯293
30.5.1 栈⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯293
30.5.2 执行流⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯295
30.5.3  “脱钩”&“钩子”⋯⋯⋯⋯⋯⋯⋯⋯⋯295
30.6 源代码分析⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯295
30.6.1 main()…………………………………………………296
30.6.2 DebugLoop()⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯296
30.6.3 EXIT PROCESS DEBUG EVENT⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯298
30.6.4 CREATE PROCESS DEBUG EVENT-OnCreateProcessDebugEvent()··	………………………298
30.6.5 EXCEPTION DEBUG EVENT-OnExceptionDebugEvent()··	…………………300

### 第31章	关于调试器⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯305
31.1 OllyDbg⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯305
31.2 IDA Pro⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 305
31.3 WinDbg⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯306
### 第32章	计算器显示中文数字⋯⋯⋯⋯⋯⋯⋯⋯308
32.1 技术图表⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯308
32.2 选定目标API⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯309
32.3 IAT钩取工作原理⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯312
32.4 练习示例⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯314
32.5 源代码分析⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯316
32.5.1 DllMain()⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯316
32.5.2 MySetWindowTextW()………………317
32.5.3 hook iat()⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯319
32.6 调试被注入的DLL文件⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯322
32.6.1 DllMain()⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯325
32.6.2 hook iat()⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯325
32.6.3 MySetWindowTextW()⋯⋯⋯⋯⋯⋯327
32.7 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯328

### 第33章	隐藏进程⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯329
33.1 技术图表⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯329
33.2 API代码修改技术的原理⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯329
33.2.1 钩取之前⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯330
33.2.2 钩取之后⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯330
33.3 进程隐藏⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯332
33.3.1 进程隐藏工作原理⋯⋯⋯⋯⋯⋯⋯⋯332
33.3.2 相关API⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯332
33.3.3 隐藏技术的问题……………………………333
33.4 练习#1(HideProc. exe, stealth. dll)…333
33.4.1 运行notepad. exe、procexp. exe、taskmgr.exe⋯⋯ 334
33.4.2 运行HideProc.exe⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 334
33.4.3 确认stealth. dll注入成功……………334
33.4.4 查看notepad. exe进程是否隐藏成功⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯335
33.4.5 取消notepad. exe进程隐藏……336
33.5 源代码分析⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯336
33.5.1 HideProc. cpp⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯336
33.5.2 stealth. cpp……………………………………………338
33.6 全局API钩取⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯344
33.6.1 Kernel32. CreateProcess()API⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯344
33.6.2 Ntdll. ZwResumeThread()API………………………………………………………………345
33.7 练习#2(HideProc2. exe,Stealth2. dll)……345
33.7.1 复制stealth2. dll文件到%SYSTEM%文件夹中…………………345
33.7.2 运行HideProc2. exe-hide⋯⋯⋯⋯346
33.7.3 运行ProcExp. exe&notepad.exe⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 346
33.7.4 运行HideProc2. exe-show…………347
33.8 源代码分析⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯348
33.8.1 HideProc2. cpp……………………………………348
33.8.2 stealth2. cpp…………………………………………348
33.9 利用“热补丁”技术钩取API⋯⋯⋯⋯⋯⋯⋯350
33.9.1 API代码修改技术的问题⋯⋯⋯350
33.9.2  “热补丁”（修改7个字节代码）⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯350
33.10 练习#3: stealth3. dll……………………………………353
33.11 源代码分析⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯353
33.12 使用“热补丁”API钩取技术时需要考虑的问题⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯356
33.13 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯357

### 第34章	高级全局API钩取：IE连接控制⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯359
34.1 目标API⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯359
34.2 IE进程结构⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯361
34.3 关于全局API钩取的概念⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯362
34.3.1 常规API钩取⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯363
34.3.2 全局API钩取⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯363
34.4 ntdll!ZwResumeThread()API⋯⋯⋯⋯⋯⋯⋯⋯364
34.5 练习示例：控制IE网络连接⋯⋯⋯⋯⋯⋯⋯⋯368
34.5.1 运行IE⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯368
34.5.2 注入DLL………………………………………369
34.5.3 创建新选项卡⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯369
34.5.4 尝试连接网站………………………………370
34.5.5 卸载DLL………………………………………371
34.5.6 课外练习⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯372
34.6 示例源代码⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯372
34.6.1 DllMain()⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯372
34.6.2 NewInternetConnectW()⋯⋯⋯⋯⋯373
34.6.3 NewZwResumeThread()……………374
34.7 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯375

### 第35章	优秀分析工具的五种标准⋯⋯⋯⋯376
35.1 工具⋯376
35.2 代码逆向分析工程师⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯376
35.3 优秀分析工具的五种标准⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯376
35.3.1 精简工具数量⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯377
35.3.2 工具功能简单、使用方便……377

35.3.3 完全掌握各种功能⋯⋯⋯⋯⋯⋯⋯⋯377
35.3.4 不断升级更新………………………………377
35.3.5 理解工具的核心工作原理……377
35.4 熟练程度的重要性⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯377

## 第五部分 64位& Windows内核6
### 第36章 64位计算⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯380
36.1 64位计算环境⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯380
36.1.1 64位CPU⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯380
36.1.2 64位OS⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯381
36.1.3 Win32 API⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯381
36.1.4 WOW64⋯⋯⋯⋯⋯⋯⋯381
36.1.5 练习：WOW64Test⋯⋯⋯⋯⋯⋯⋯384
36.2 编译64位文件⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯385
36.2.1 Microsoft Windows SDK(Software Development Kit)……386
36.2.2 设置Visual C++2010 Express环境………………………………………………………386
### 第37章 x64处理器⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯389
37.1 x64中新增或变更的项目⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯389
37.1.1 64位⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯389
37.1.2 内存⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯389
37.1.3 通用寄存器⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯389
37.1.4 CALL/JMP指令⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯390
37.1.5 函数调用约定⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯391
37.1.6 栈&栈帧⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯392
37.2 练习：Stack32. exe& Stack64.exe⋯⋯⋯ 392
37.2.1 Stack32.exe⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 392
37.2.2 Stack64.exe⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 394
37.3 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯397

### 第38章 PE32+	………………398
38.1PE32+ (PE+、PE64)⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯398
38.1.1 IMAGE NT HEADERS⋯⋯⋯⋯398
38.1.2 IMAGE FILE HEADER⋯⋯⋯398
38.1.3 IMAGE OPTIONAL HEADER⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯399
38.1.4 IMAGE THUNK DATA⋯⋯⋯401
38.1.5 IMAGE TLS DIRECTORY…403
### 第39章 WinDbg·	……………405
39.1 WinDbg·	………………………………………405
39.1.1 WinDbg的特征⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯405
39.1.2 运行WinDbg⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯406

39.1.3 内核调试⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯407
39.1.4 WinDbg基本指令⋯⋯⋯⋯⋯⋯⋯⋯⋯409
### 第40章 64位调试⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯411
40.1 x64环境下的调试器⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯411
40.2 64位调试⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯411
40.3 PE32: WOW64Test x86. exe⋯⋯⋯⋯⋯⋯⋯413
40.3.1 EP代码⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯414
40.3.2 Startup代码⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯414
40.3.3 main()函数⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯415
40.4 PE32+: WOW64Test x64.exe⋯⋯⋯⋯⋯⋯ 416
40.4.1 系统断点⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯416
40.4.2 EP代码⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯417
40.4.3 Startup代码⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯418
40.4.4 main()函数………………………………………420
40.5 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯423
### 第41章 ASLR⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯424
41.1 Windows内核版本⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯424
41.2 ASLR⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯424
41.3 Visual C++⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯424
41.4 ASLR.exe⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 425
41.4.1 节区信息⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯426
41.4.2 IMAGE FILE HEADER\Characteristics⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯427
41.4.3 IMAGE OPTIONAL HEADER\DLL Characteristics⋯⋯⋯⋯⋯⋯⋯⋯⋯428
41.5 练习：删除ASLR功能⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯428
### 第42章	内核6中的会话………………………………430
42.1 会话⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯430
42.2 会话0隔离机制⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯432
42.3 增强安全性⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯432

### 第43章	内核6中的DLL注入⋯⋯⋯⋯⋯⋯⋯⋯433
43.1 再现DLL注入失败⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯433
43.1.1 源代码…………………………………………………433
43.1.2 注入测试⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯435
43.2 原因分析⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯436
43.2.1 调试#1⋯⋯⋯⋯⋯⋯⋯436
43.2.2 调试#2⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯438
43.3 练习：使CreateRemoteThread()正常工作⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯440
43.3.1 方法#1: 修改CreateSuspended参数值⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯440
43.3.2 方法#2: 操纵条件分支……………441

## Windows Visual Studio 的常用命令，例如：编译、连接、生成可执行文件等等

在 **Windows Visual Studio** 环境中，常用的命令涉及编译、链接、构建项目等操作。这些命令可以通过 **Visual Studio 命令行工具**（如 `Developer Command Prompt` 或 `Developer PowerShell`）执行，也可以集成到脚本中实现自动化构建。以下是核心命令及其用途和示例：

---

### **一、核心命令行工具**
#### **1. `MSBuild`（项目构建工具）**
- **作用**：用于构建 `.sln` 解决方案文件或 `.vcxproj` 项目文件。
- **常用命令**：
  ```bash
  # 构建整个解决方案（默认配置）
  MSBuild MySolution.sln

  # 指定配置（Debug/Release）和平台（x86/x64）
  MSBuild MySolution.sln /p:Configuration=Release /p:Platform=x64

  # 仅构建指定项目
  MSBuild MyProject.vcxproj /t:Build
  ```

#### **2. `cl.exe`（C/C++ 编译器）**
- **作用**：编译 C/C++ 源文件（`.cpp`、`.c`）生成对象文件（`.obj`）。
- **常用命令**：
  ```bash
  # 编译单个文件（默认生成同名 .obj）
  cl /c main.cpp

  # 指定输出文件名和优化选项
  cl /c /O2 /Fomain.obj main.cpp

  # 多文件编译（生成多个 .obj）
  cl /c file1.cpp file2.cpp
  ```

#### **3. `link.exe`（链接器）**
- **作用**：将对象文件（`.obj`）和库文件（`.lib`）链接为可执行文件（`.exe`）或动态库（`.dll`）。
- **常用命令**：
  ```bash
  # 链接生成可执行文件
  link main.obj utils.obj /OUT:MyApp.exe

  # 链接动态库（生成 .dll）
  link /DLL math.obj /OUT:MathLibrary.dll

  # 指定依赖库（如 Windows API）
  link main.obj user32.lib gdi32.lib /OUT:MyApp.exe
  ```

---

### **二、常用编译和链接参数**
#### **1. 编译器参数（`cl.exe`）**
| **参数**          | **说明**                                                                 |
|--------------------|-------------------------------------------------------------------------|
| `/c`               | 仅编译，不链接（生成 `.obj` 文件）                                      |
| `/O1`, `/O2`, `/Ox`| 优化等级（最小体积、最大速度、全优化）                                   |
| `/I<目录>`         | 添加头文件搜索目录（如 `/I"C:\MyLib\include"`）                         |
| `/D<宏>`           | 定义预处理器宏（如 `/DDEBUG`）                                          |
| `/EHsc`            | 启用 C++ 异常处理（必须用于包含异常的代码）                              |

#### **2. 链接器参数（`link.exe`）**
| **参数**          | **说明**                                                                 |
|--------------------|-------------------------------------------------------------------------|
| `/OUT:<文件名>`    | 指定输出文件名（默认基于第一个输入文件）                                 |
| `/LIBPATH:<目录>`  | 添加库文件搜索目录（如 `/LIBPATH:"C:\MyLib\lib"`）                      |
| `/SUBSYSTEM:CONSOLE` | 控制台应用程序（显示命令行窗口）                                       |
| `/SUBSYSTEM:WINDOWS` | GUI 应用程序（不显示命令行窗口）                                      |
| `/DEBUG`           | 生成调试信息（需与 `/Zi` 编译选项配合）                                 |

---

### **三、完整构建流程示例**
#### **1. 手动编译链接**
```bash
# 编译源文件
cl /c /EHsc /Iinclude /O2 src\main.cpp src\utils.cpp

# 链接生成可执行文件
link main.obj utils.obj /OUT:MyApp.exe /LIBPATH:lib user32.lib
```

#### **2. 使用 `devenv` 命令（集成 IDE 功能）**
```bash
# 构建解决方案（不打开 IDE）
devenv MySolution.sln /Build "Release|x64"

# 清理项目
devenv MySolution.sln /Clean
```

---

### **四、实用环境配置**
#### **1. 设置环境变量**
- 运行 `Developer Command Prompt` 或 `Developer PowerShell`，它们已自动配置以下路径：
  - **编译器/链接器路径**：如 `C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\bin\Hostx64\x64`。
  - **库和头文件路径**：自动包含 Windows SDK 和 CRT 路径。

#### **2. 查看工具版本**
```bash
# 查看 cl.exe 版本
cl /?

# 查看 link.exe 版本
link /?
```

---

### **五、进阶工具与场景**
#### **1. `nmake`（Makefile 构建）**
- **作用**：通过 `Makefile` 文件管理构建流程。
- **示例**：
  ```bash
  # 生成 Makefile（需编写规则）
  nmake /f MyMakefile.mak
  ```

#### **2. `vcpkg`（包管理）**
- **作用**：集成第三方库（如 OpenSSL、Boost）。
- **示例**：
  ```bash
  # 安装库并集成到项目
  vcpkg install zlib:x64-windows
  ```

#### **3. `dumpbin.exe`（查看二进制信息）**
- **作用**：分析可执行文件或库的符号、依赖项。
- **示例**：
  ```bash
  # 查看 DLL 的导出函数
  dumpbin /exports MyLibrary.dll
  ```

---

### **总结**
通过上述命令，可以在 **Visual Studio** 环境中实现高效的项目构建与管理。掌握 `MSBuild`、`cl.exe` 和 `link.exe` 的核心用法，能够灵活应对从简单编译到复杂项目构建的需求，同时结合 `Developer Command Prompt` 的环境配置，确保编译链接过程无缝衔接。