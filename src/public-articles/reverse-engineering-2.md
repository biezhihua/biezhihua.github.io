# x86/x64 汇编 有什么区别呢？ 那个是主流。

在日常所说的「x86」和「x64」中，x86 通常指 32 位的处理器/指令集架构（全称可写作 x86_32），而 x64 则指 64 位的处理器/指令集架构（也称 x86_64 或 AMD64）。汇编层面上的区别，主要体现在寄存器的数量与宽度、函数调用约定、内存寻址等方面。以下是一些主要差异：

---

## 1. 寄存器数量与命名

- **x86（32 位）**  
  - 经典的通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP  
  - 每个寄存器的宽度都是 32 位，以 `E` 前缀表示 (Extended Register)。  
  - 例如：EAX 表示 32 位 AX；AX 低 16 位也可继续拆分成 AH、AL 等更小段。

- **x64（64 位）**  
  - 保留了 x86 的 8 个通用寄存器，并额外增加了 8 个（R8 ~ R15），总共有 16 个可用的通用寄存器。  
  - 每个寄存器的宽度扩大到 64 位，以 `R` 前缀表示 (Register)。  
  - 例如：RAX 表示 64 位 A 寄存器；也可以访问 RAX 的低 32 位（EAX）、低 16 位（AX）以及 8 位（AH、AL）。

---

## 2. 函数调用约定（Calling Convention）

- **x86**  
  - 常见的调用约定有 cdecl、stdcall、fastcall、thiscall 等，不同编译器/平台可能默认不同。  
  - 一般来说，函数参数多采用「栈传递」，调用者或被调用者负责清理栈空间。  

- **x64**  
  - 在 64 位平台上，主流操作系统通常统一调用约定，让编译器之间更具兼容性。  
  - **Windows 平台 (Microsoft x64 Calling Convention)**：前四个整型/指针参数分别由寄存器 RCX、RDX、R8、R9 传递；额外的参数再压栈。  
  - **Linux / macOS (System V AMD64 ABI)**：前六个整型/指针参数通过 RDI、RSI、RDX、RCX、R8、R9 传递；额外的参数再压栈。  
  - 函数返回值则通过 RAX 或者 XMM0（浮点）等寄存器返回。

---

## 3. 地址空间与内存寻址

- **x86**  
  - 理论上最大可寻址内存为 4GB，寄存器/指针宽度 32 位。  
  - 对一些特别大的数据处理需求，可能需要额外的扩展（PAE 等），但整体内存空间受限。

- **x64**  
  - 寄存器/指针宽度扩大至 64 位，理论上可寻址极其庞大的内存（当前实现多为 48 位物理寻址或更高）。  
  - x64 程序可以更方便地进行大内存的运算、管理。

---

## 4. 指令集扩展

- x86 汇编只保证最基本的 32 位指令集和部分 SSE 指令，需要额外检测 CPU 是否支持更高等级的 SSE/AVX 等扩展。  
- x64 则默认包含了更完整、更高版本的指令扩展（如 SSE2、SSE4.2 等）。在 64 位模式下，一些原 x86 的 “遗留” 指令可能被废弃或行为变化。

---

## 5. 现今主流选择

在个人电脑（PC）、服务器以及绝大多数桌面应用领域，**x64（64 位）已是绝对主流**。主要原因包括：

1. **操作系统普遍 64 位化**：主流操作系统（Windows、Linux、macOS 等）均提供 64 位内核与 64 位用户态支持，能够突破 32 位系统的内存限制。  
2. **硬件演进**：CPU 生产商（Intel、AMD）在新产品线上更多地聚焦 64 位处理器的优化，32 位处理器在消费级市场基本停产或只在特定场景保留。  
3. **软件生态**：绝大多数大型软件和游戏都已经转向 64 位，以支持更大内存、更高效的浮点/向量运算。  
4. **兼容性**：x64 仍能兼容运行许多 32 位软件（在 Windows 上借助 WoW64 子系统等），因此迁移的成本相对可控。

然而，**x86（32 位）** 并未完全消失。在一些 **老旧设备、嵌入式系统、工控机** 等场景，由于硬件或系统的限制，可能还在使用 32 位的架构。另外，在逆向工程和安全研究领域，有时也需要分析老版本 32 位程序，因此对 x86 汇编依然要有一定掌握。

---

## 小结

- **x86 和 x64 的核心差别**主要在于：寄存器宽度与数量、函数调用约定、可寻址内存空间以及指令集扩展。  
- 目前 **主流的桌面、服务器平台** 都已转向 x64（64 位），对于学习和工作来说，x64 的重要性更高。  
- 对于逆向工程或系统底层开发而言，**x86 的知识依然不可或缺**，因为很多老软件、驱动、嵌入式仍基于 32 位环境，需要能够读懂 x86 汇编。  
- 如果从零起步，可以将 x86 视作基础再过渡到 x64，毕竟它们在指令层面有很多相通之处（x64 是在 x86 基础上扩展而来）。实际项目中，大多数场景还是建议重点掌握 x64，兼顾熟悉 x86，以便应对可能遇到的多平台需求。