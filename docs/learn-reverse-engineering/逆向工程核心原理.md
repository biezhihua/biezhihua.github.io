# 逆向工程核心原理

那么，读者应该如何使用本书学习逆向分析技术呢？对此，我给出如下几点建议，供各位参考。
第一，技术书不是装饰书架的道具，它们是提高各位技术水平的工具。所以阅读时要勾画出重要部分，在书页空白处写下自己的想法与心得等。阅读时，在书页上记录相关技术、注意事项、技术优缺点、与作者的不同见解等，让它成为只属于你的书。读完这样一本逆向分析技术书后，不知不觉间就构建出自己独特的逆向分析世界，最终成为代码逆向分析专家。

第二，拥有积极乐观的心态。逆向分析是一项深奥的技术，会涉及OS底层知识。要学的内容很多，并且大部分内容需要亲自测试并确认才能最终理解。必须用积极乐观的心态对待这一过程，学习逆向技术无关聪明与否，只跟投入时间的多少有关。学习时，不要太急躁，请保持轻松的心态。

第三，不断挑战。逆向分析不尽如人意时，不要停下来，要尝试其他方法，不断挑战。要相信一定会有解决的方法，可能几年前早已有人成功过了。搜索相关资料并不断尝试，不仅能提高自身技术水平，解决问题后，心里还能感受到一种成就感。这样的成功经验一点点积累起来，自信心就会大大增强，自身的逆向分析水平也会得到明显提高。这种从经验中获得的自信会不知不觉地对逆向分析过程产生积极影响，让逆向分析往更好的方向发展。

希望本书能够帮助各位把“心愿表”上的愿望一一实现，也希望各位把本书讲解的知识、技术广泛应用到逆向分析过程中，发挥更大的作用。谢谢。

## 第1章 关于逆向工程

1.1 逆向工程

1.2 代码逆向工程


1.2.1 逆向分析法


1.2.2  源代码、十六进制代码、汇编代码


1.2.3  “打补丁”与“破解”

1.3 代码逆向准备
1.3.1 目标
1.3.2 激情
1.3.3 谷歌

1.4  学习逆向分析技术的禁忌
1.4.1 贪心
1.4.2 急躁
1.5 逆向分析技术的乐趣

## 第2章	逆向分析Hello World!程序


00FB1000


2.1 Hello World!程序
2.2 调试HelloWorld. exe程序
2.2.1 调试目标
2.2.2 开始调试
2.2.3 入口点
2.2.4 跟踪40270C函数
2.2.5 跟踪40104F跳转语句
2.2.6 查找main()函数
2.3 进一步熟悉调试器
2.3.1 调试器指令
2.3.2  “大本营”
2.3.3 设置“大本营”的四种方法
2.4 快速查找指定代码的四种方法
2.4.1 代码执行法
2.4.2 字符串检索法
2.4.3 API检索法 (1): 在调用代码中设置断点
2.4.4 API检索法 (2): 在API代码中设置断点
2.5 使用“打补丁”方式修改“HelloWorld!”字符串
2.5.1  “打补丁”
2.5.2 修改字符串的两种方法
2.6 小结


## 第3章	小端序标记法⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯31
3.1 字节序⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯31
3.1.1 大端序与小端序⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯32
3.1.2 在OllyDbg中查看小端序⋯⋯⋯⋯⋯⋯32
## 第4章 IA-32寄存器基本讲解⋯⋯⋯⋯⋯⋯⋯⋯⋯34
4.1 什么是CPU寄存器⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯34
4.2 IA-32寄存器⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯34
4.3 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯40
## 第5章	栈…………………………………………………………………41
5.1 栈………………………………………………………………………41
5.1.1 栈的特征⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯41
5.1.2 栈操作示例⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯41
## 第6章	分析abex' crackme#1………………………44
6.1 abex' crackme #1⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯44
6.1.1 开始调试⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯45
6.1.2 分析代码⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯45
6.2 破解⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯47
6.3 将参数压入栈⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯47
6.4 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯48

## 第7章	栈帧	…………………………………49
7.1 栈帧	…………………49
7.2 调试示例：stackframe. exe-	…………………49
7.2.1 StackFrame. cpp	………………50
7.2.2 开始执行main()函数&生成栈帧··51
7.2.3 设置局部变量……………………………………………52
7.2.4 add()函数参数传递与调用⋯⋯⋯⋯⋯⋯53
第7章	栈帧	…………………………………49
7.1 栈帧	…………………49
7.2 调试示例：stackframe. exe-	…………………49
7.2.1 StackFrame. cpp	………………50
7.2.2 开始执行main()函数&生成栈帧··51
7.2.3 设置局部变量……………………………………………52
7.2.4 add()函数参数传递与调用⋯⋯⋯⋯⋯⋯53
7.2.5 开始执行add()函数&生成栈帧……54
7.2.6 设置add()函数的局部变量(x,y)…………………………………………55
7.2.7 ADD运算⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯55
7.2.8 删除函数add()的栈帧&函数
执行完毕（返回）⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯56
7.2.9 从栈中删除函数add()的参数（整理栈）……………………………………………………57
7.2.10 调用printf()函数⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯58
7.2.11 设置返回值⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯58
7.2.12 删除栈帧& main()函数终止……………58
7.3 设置OllyDbg选项⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯59
7.3.1 Disasm选项…………………………………………59
7.3.2 Analysis1选项⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯60
7.4 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯61


## 第8章 abex' crackme#2⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯62
8.1 运行abex' crackme#2⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯62
8.2 Visual Basic文件的特征⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯63
8.2.1 VB专用引擎⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯63
8.2.2 本地代码和伪代码⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯63
8.2.3 事件处理程序⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯63
8.2.4 未文档化的结构体⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯63
8.3 开始调试⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯63
8.3.1 间接调用⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯64
8.3.2 RT MainStruct结构体………………………64
8.3.3 ThunRTMain()函数⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯65
8.4 分析crackme⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯65
8.4.1 检索字符串⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯65
8.4.2 查找字符串地址⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯66
8.4.3 生成Serial的算法⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯68
8.4.4 预测代码⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯69
8.4.5 读取Name字符串的代码………………69
8.4.6 加密循环⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯70
8.4.7 加密方法⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯70
8.5 小结⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯72
## 第9章 Process Explorer———最优秀的进程管理工具⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯74
9.1 Process Explorer………………………………………………………74
9.2 具体有哪些优点呢⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯75
9.3 sysinternals⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯ 75

## 第10章	函数调用约定⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯76
10.1 函数调用约定-	……………………76
10.1.1 cdecl	·76

10.1.2 stdcall⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯77
10.1.3 fastcall⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯78
## 第11章	视频讲座……………………………………………………79
11.1 运行⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯79
11.2 分析⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯79
11.2.1 目标 (1): 去除消息框………………79
11.2.2 打补丁 (1): 去除消息框…………81
11.2.3 目标 (2): 查找注册码………………83
11.3 小结………………………………………………………………………85
## 第12章	究竟应当如何学习代码逆向分析⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯86
12.1 逆向工程⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯86
12.1.1 任何学习都应当有目标⋯⋯⋯⋯⋯⋯86
12.1.2 拥有积极心态⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯86
12.1.3 要感受其中的乐趣⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯86
12.1.4  让检索成为日常生活的一部分……………………………………………………87
12.1.5 最重要的是实践………………………………87
12.1.6 请保持平和的心态⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯87
## 第二部分 PE文件格式


## windows visual studio 的常用命令，例如：编译、连接、生成可执行文件等等


在 **Windows Visual Studio** 环境中，常用的命令涉及编译、链接、构建项目等操作。这些命令可以通过 **Visual Studio 命令行工具**（如 `Developer Command Prompt` 或 `Developer PowerShell`）执行，也可以集成到脚本中实现自动化构建。以下是核心命令及其用途和示例：

---

### **一、核心命令行工具**
#### **1. `MSBuild`（项目构建工具）**
- **作用**：用于构建 `.sln` 解决方案文件或 `.vcxproj` 项目文件。
- **常用命令**：
  ```bash
  # 构建整个解决方案（默认配置）
  MSBuild MySolution.sln

  # 指定配置（Debug/Release）和平台（x86/x64）
  MSBuild MySolution.sln /p:Configuration=Release /p:Platform=x64

  # 仅构建指定项目
  MSBuild MyProject.vcxproj /t:Build
  ```

#### **2. `cl.exe`（C/C++ 编译器）**
- **作用**：编译 C/C++ 源文件（`.cpp`、`.c`）生成对象文件（`.obj`）。
- **常用命令**：
  ```bash
  # 编译单个文件（默认生成同名 .obj）
  cl /c main.cpp

  # 指定输出文件名和优化选项
  cl /c /O2 /Fomain.obj main.cpp

  # 多文件编译（生成多个 .obj）
  cl /c file1.cpp file2.cpp
  ```

#### **3. `link.exe`（链接器）**
- **作用**：将对象文件（`.obj`）和库文件（`.lib`）链接为可执行文件（`.exe`）或动态库（`.dll`）。
- **常用命令**：
  ```bash
  # 链接生成可执行文件
  link main.obj utils.obj /OUT:MyApp.exe

  # 链接动态库（生成 .dll）
  link /DLL math.obj /OUT:MathLibrary.dll

  # 指定依赖库（如 Windows API）
  link main.obj user32.lib gdi32.lib /OUT:MyApp.exe
  ```

---

### **二、常用编译和链接参数**
#### **1. 编译器参数（`cl.exe`）**
| **参数**          | **说明**                                                                 |
|--------------------|-------------------------------------------------------------------------|
| `/c`               | 仅编译，不链接（生成 `.obj` 文件）                                      |
| `/O1`, `/O2`, `/Ox`| 优化等级（最小体积、最大速度、全优化）                                   |
| `/I<目录>`         | 添加头文件搜索目录（如 `/I"C:\MyLib\include"`）                         |
| `/D<宏>`           | 定义预处理器宏（如 `/DDEBUG`）                                          |
| `/EHsc`            | 启用 C++ 异常处理（必须用于包含异常的代码）                              |

#### **2. 链接器参数（`link.exe`）**
| **参数**          | **说明**                                                                 |
|--------------------|-------------------------------------------------------------------------|
| `/OUT:<文件名>`    | 指定输出文件名（默认基于第一个输入文件）                                 |
| `/LIBPATH:<目录>`  | 添加库文件搜索目录（如 `/LIBPATH:"C:\MyLib\lib"`）                      |
| `/SUBSYSTEM:CONSOLE` | 控制台应用程序（显示命令行窗口）                                       |
| `/SUBSYSTEM:WINDOWS` | GUI 应用程序（不显示命令行窗口）                                      |
| `/DEBUG`           | 生成调试信息（需与 `/Zi` 编译选项配合）                                 |

---

### **三、完整构建流程示例**
#### **1. 手动编译链接**
```bash
# 编译源文件
cl /c /EHsc /Iinclude /O2 src\main.cpp src\utils.cpp

# 链接生成可执行文件
link main.obj utils.obj /OUT:MyApp.exe /LIBPATH:lib user32.lib
```

#### **2. 使用 `devenv` 命令（集成 IDE 功能）**
```bash
# 构建解决方案（不打开 IDE）
devenv MySolution.sln /Build "Release|x64"

# 清理项目
devenv MySolution.sln /Clean
```

---

### **四、实用环境配置**
#### **1. 设置环境变量**
- 运行 `Developer Command Prompt` 或 `Developer PowerShell`，它们已自动配置以下路径：
  - **编译器/链接器路径**：如 `C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.30.30705\bin\Hostx64\x64`。
  - **库和头文件路径**：自动包含 Windows SDK 和 CRT 路径。

#### **2. 查看工具版本**
```bash
# 查看 cl.exe 版本
cl /?

# 查看 link.exe 版本
link /?
```

---

### **五、进阶工具与场景**
#### **1. `nmake`（Makefile 构建）**
- **作用**：通过 `Makefile` 文件管理构建流程。
- **示例**：
  ```bash
  # 生成 Makefile（需编写规则）
  nmake /f MyMakefile.mak
  ```

#### **2. `vcpkg`（包管理）**
- **作用**：集成第三方库（如 OpenSSL、Boost）。
- **示例**：
  ```bash
  # 安装库并集成到项目
  vcpkg install zlib:x64-windows
  ```

#### **3. `dumpbin.exe`（查看二进制信息）**
- **作用**：分析可执行文件或库的符号、依赖项。
- **示例**：
  ```bash
  # 查看 DLL 的导出函数
  dumpbin /exports MyLibrary.dll
  ```

---

### **总结**
通过上述命令，可以在 **Visual Studio** 环境中实现高效的项目构建与管理。掌握 `MSBuild`、`cl.exe` 和 `link.exe` 的核心用法，能够灵活应对从简单编译到复杂项目构建的需求，同时结合 `Developer Command Prompt` 的环境配置，确保编译链接过程无缝衔接。