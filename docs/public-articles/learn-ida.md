# Learn IDA


## 第一部分　IDA简介

### 第1章　反汇编简介

#### 1.1　反汇编理论

#### 1.2　何为反汇编

在传统的软件开发模型中，程序员使用编译器、汇编器和链接器中的一个或几个创建可执行程序。

为了回溯编程过程（或对程序进行逆向工程），我们使用各种工具来撤销汇编和编译过程。毫不奇怪，这些工具就叫做反汇编器 和反编译器 ，名副其实。

反汇编器撤销汇编过程，因此，我们可以得到汇编语言形式的输出结果（以机器语言作为输入）

反编译器则以汇编语言甚至是机器语言为输入，其输出结果为高级语言。

#### 1.3　为何反汇编

动态分析和静态分析是分析恶意软件的两种主要技术。
动态分析 （dynamic analysis ）是指在严格控制的环境（沙盒）中执行恶意软件，并使用系统检测实用工具记录其所有行为。
相反，静态分析 （static analysis ）则试图通过浏览程序代码来理解程序的行为。

#### 1.4　如何反汇编

以最常见的情形——反汇编可执行文件——为例，该文件必须符合可执行文件的某种通用格式，如 Windows 所使用的可移植可执行 （Portable Executable ，PE）格式或许多 Unix 系统常用的可执行和链接格式 （Executable and linking format ，ELF ）。

这些格式通常含有一种机制，用来确定文件中包含代码和代码入口点的部分的位置（通常表现为层级文件头的形式）。

代码入口点是一个指令地址，一旦程序加载到内存，操作系统就将控制权交给该指令。

表查找，将二进制操作码的值与它的汇编语言助记符对应起来。

有多种汇编语言输出格式可供选择。例如，x86 汇编语言所使用的两种主要格式为 Intel 格式和AT & T 格式。

AT & T 汇编语法以%作为所有寄存器名称的前缀，以$作为文字常量（也叫做立即操作数）的前缀。它这样对操作数排序：源操作数位于左边，目的操作数位于右边。使用AT & T 语法，EAX寄存器加4 的指令为： add $0x4,%eax。GNU汇编器（Gas）和许多其他GNU工具（如 gcc 和gdb）都使用AT & T 语法。

Intel 语法与AT & T 语法不同，它不需要寄存器和文字前缀，它的操作数排序方式与AT & T语法操作数恰恰相反：源操作数位于右边，目的操作数位于左边。使用 Intel 语法，上述加法的指令为：add eax, 0x4 。使用 Intel 语法的汇编器包括微软汇编器（MASM）、Borland的Turbo汇编器（TASM ）和Netwide汇编器（NASM ）。

线性扫描 （linear sweep）和递归下降 （recursive descent ）是两种最主要的反汇编算法。

GNU调试器（gdb）、微软公司的 WinDbg调试器和 objdump 实用工具的反汇编引擎均采用线性扫描算法

如果CPU 首先存储一个多字节值的最高有效字节，则称该CPU 为大端（big-endian）CPU ；如果该CPU 首先存储最低有效字节，则称为小端（little-endial ）CPU 。

#### 1.5　小结

## 第2章　逆向与反汇编工具

2.1　分类工具

文件扩展名并无实际意义。

幻数文件的默认位置因操作系统而异，常见的位置包括/usr/share/file/magic、/usr/share/misc/magic 和/etc/magic。

在逆向工程过程中，绝不要完全相信任何工具所提供的结果，除非该结果得到其他几款工具和手动分析的确认，这是一个良好的习惯。

2.2　摘要工具

2.3　深度检测工具

2.4　小结

## 第3章　IDA Pro 背景知识

3.1　Hex-Rays公司的反盗版策略

3.2　获取IDA Pro

3.3　IDA 支持资源

3.4　安装IDA

3.5　IDA 用户界面

3.6　小结

## 第二部分　IDA基本用法

第4章　IDA入门

4.1　启动IDA

4.2　IDA 数据库文件

4.3　IDA 桌面简介

4.4　初始分析时的桌面行为

4.5　IDA 桌面提示和技巧

4.6　报告bug

4.7　小结

## 第5章　IDA 数据显示窗口

5.1　IDA 主要的数据显示窗口

5.2　次要的IDA 显示窗口

5.3　其他IDA 显示窗口

5.4　小结

## 第6章　反汇编导航

6.1　基本IDA 导航

6.2　栈帧

6.3　搜索数据库

6.4　小结

第7章　反汇编操作

7.1　名称与命名

7.2　IDA 中的注释

7.3　基本代码转换

7.4　基本数据转换

7.5　小结

第8章　数据类型与数据结构

8.1　识别数据结构的用法

8.2　创建IDA 结构体

8.3　使用结构体模板

8.4　导入新的结构体

8.5　使用标准结构体

8.6　IDA TIL 文件

8.7　C++ 逆向工程基础

8.8　小结

第9章　交叉引用与绘图功能

9.1　交叉引用

9.2　IDA 绘图

9.3　小结

第10章　IDA的多种面孔

10.1　控制台模式IDA

10.2　使用IDA 的批量模式

10.3　小结

第三部分　IDA高级应用

第11章　定制IDA

11.1　配置文件

11.2　其他IDA 配置选项

11.3　小结

第12章　使用FLIRT 签名来识别库

12.1　快速库识别和鉴定技术

12.2　应用FLIRT 签名

12.3　创建FLIRT 签名文件

12.4　小结

第13章　扩展IDA 的知识

13.1　扩充函数信息

13.2　使用loadint 扩充预定义注释

13.3　小结

第14章　修补二进制文件及其他IDA 限制

14.1　隐藏的补丁程序菜单

14.2　IDA 输出文件与补丁生成

14.3　小结

第四部分　扩展IDA的功能

第15章　编写IDA 脚本

15.1　执行脚本的基础知识

15.2　IDC 语言

15.3　关联IDC 脚本与热键

15.4　有用的IDC 函数

15.5　IDC 脚本示例

15.6　IDAPython

15.7　IDAPython 脚本示例

15.8　小结

第16章　IDA 软件开发工具包

16.1　SDK简介

16.2　IDA 应用编程接口

16.3　小结

第17章　IDA 插件体系结构

17.1　编写插件

17.2　构建插件

17.3　插件安装

17.4　插件配置

17.5　扩展IDC

17.6　插件用户界面选项

17.7　脚本化插件

17.8　小结

第18章　二进制文件与 IDA 加载器模块

18.1　未知文件分析

18.2　手动加载一个Windows PE文件

18.3　IDA 加载器模块

18.4　使用SDK编写IDA 加载器

18.5　其他加载器策略

18.6　编写脚本化加载器

18.7　小结

第19章　IDA 处理器模块

19.1　Python字节码

19.2　Python解释器

19.3　使用SDK编写处理器模块

19.4　构建处理器模块

19.5　定制现有的处理器

19.6　处理器模块体系结构

19.7　编写处理器模块

19.8　小结

第五部分　实际应用

第20章　编译器变体

20.1　跳转表与分支语句

20.2　RTTI实现

20.3　定位main函数

20.4　调试版与发行版二进制文件

20.5　其他调用约定

20.6　小结

第21章　模糊代码分析

21.1　反静态分析技巧

21.2　反动态分析技巧

21.3　使用IDA 对二进制文件进行“静态去模糊”

21.4　基于虚拟机的模糊

21.5　小结

第22章　漏洞分析

22.1　使用IDA 发现新的漏洞

22.2　使用IDA 在事后发现漏洞

22.3　IDA 与破解程序开发过程

22.4　分析shellcode

22.5　小结

第23章　实用IDA 插件

23.1　 Hex-Rays

23.2　IDAPython

23.3　collabREate

23.4　ida-x86emu

23.5　Class Informer

23.6　MyNav

23.7　IdaPdf

23.8　小结

第六部分　IDA调试器

第24章　IDA 调试器

24.1　启动调试器

24.2　调试器的基本显示

24.3　进程控制

24.4　调试器任务自动化

24.5　小结

第25章　反汇编器/ 调试器集成

25.1　背景知识

25.2　IDA 数据库与IDA 调试器

25.3　调试模糊代码

25.4　IDAStealth

25.5　处理异常

25.6　小结

第26章　其他调试功能

26.1　使用IDA 进行远程调试

26.2　使用Bochs 进行调试

26.3　Appcall

26.4　小结

附录A　使用IDA 免费版本5.0

A.1　IDA 免费版本的限制

A.2　使用IDA 免费版本

附录B　IDC/SDK交叉引用

　　　

 