---
article: false
---

# Perfetto - 01 - Tracing 101

本页提供了性能分析的鸟瞰图。目的是引导那些不知道什么是“追踪”的人。

## Introduction to...

### Performance 性能

性能分析是为了使软件更好地运行。“更好”的定义因情况而异，差别很大。例子包括：
- 用更少的资源（CPU、内存、网络、电池等）完成同样的工作

- 提高可用资源的利用率

- 完全识别和消除不必要的工作

提高性能的大部分困难来自于确定性能问题的根本原因。现代软件系统是复杂的，有很多组件和交叉交互的网络。帮助工程师理解系统执行和查明关键问题的技术。

跟踪和分析（Tracing and profiling）是两种用于性能分析的广泛使用的技术。Perfetto是一套开源工具，结合了跟踪和分析（Tracing and profiling），为用户提供了对其系统的强大洞察。

### Tracing 跟踪

跟踪（Tracing）包括收集关于系统执行的非常详细的数据。单个连续的记录会话称为跟踪文件或简称trace。

跟踪包含足够的细节来完全重建事件的时间轴。它们通常包括低级内核事件，如调度器上下文切换、线程唤醒、系统调用等。有了“正确的”跟踪，就不需要重现性能错误，因为跟踪提供了所有必要的上下文。

应用程序代码也会在程序被认为重要的区域中进行检测。这种检测可以跟踪程序在一段时间内所做的事情（例如，哪些函数正在运行，或者每个调用花费了多长时间）和执行的上下文（例如，函数调用的参数是什么，或者为什么要运行函数）。

跟踪的详细程度使得在除最简单的情况之外的所有情况下都像读取日志文件一样直接读取跟踪文件是不切实际的。而是使用跟踪分析库和跟踪查看器的组合。跟踪分析库为用户提供了一种以编程方式提取和汇总跟踪事件的方法。跟踪查看器在时间轴上可视化跟踪中的事件，为用户提供其系统随时间推移所执行的操作的图形视图。

#### Logging vs Tracing

一个很好的直觉是，日志记录之于功能测试，就像跟踪之于性能分析一样。从某种意义上说，跟踪是“结构化”日志记录：跟踪不是从系统的某些部分发出任意字符串，而是以结构化的方式反映系统的详细状态，以允许重建事件的时间线。

此外，跟踪框架（如Perfetto）非常强调最小化开销。这是至关重要的，这样框架就不会显著地破坏正在测量的任何东西：现代框架足够快，它们可以在纳秒级别上测量执行，而不会显著影响程序的执行速度。

题外话：理论上讲，跟踪框架足够强大，可以充当日志记录系统。然而，在实践中，两者的使用是不同的，以至于两者往往是分开的。

#### Metrics vs Tracing 

度量是一种数值，可以跟踪系统在一段时间内的性能。通常指标映射到高级概念。指标的例子包括：CPU使用率、内存使用率、网络带宽等。指标是在程序运行时直接从应用程序或操作系统收集的。

在了解了跟踪的强大功能之后，一个自然的问题就产生了：为什么要为高级指标而烦恼呢？为什么不直接使用使用跟踪并计算结果跟踪的度量呢？在某些情况下，这可能确实是正确的方法。在本地和实验室环境中，使用基于跟踪的指标（其中指标是从跟踪计算而不是直接收集它们）是一种强大的方法。如果一个指标倒退了，很容易打开对发生这种情况的根本原因的跟踪。

然而，基于跟踪的度量并不是通用的解决方案。在生产环境中运行时，跟踪的重量级特性使得全天候收集它们变得不切实际。使用跟踪计算度量可能需要兆字节的数据，而直接收集度量则需要字节。

当您想要了解系统随时间推移的性能，但又不想或无法支付收集跟踪的成本时，使用指标是正确的选择。在这些情况下，应将跟踪用作根本原因工具。当您的指标显示存在问题时，可以推出有针对性的跟踪，以了解回归可能发生的原因。

### Profiling 分析

分析（Profiling）包括对程序使用资源的情况进行抽样。一个连续的记录会话被称为一个配置文件（profile）。

每个示例收集函数调用堆栈（即代码行以及所有调用函数）。通常，此信息在整个配置文件（profile）中聚合。对于每个看到的调用堆栈，聚合提供该调用堆栈对资源的使用百分比。到目前为止，最常见的分析类型（most common types of profiling）是内存分析（memory profiling）和 CPU 分析（CPU profiling）。

内存分析（memory profiling）用于了解程序的哪些部分在堆上分配内存。剖析器通常挂钩（hook）到本机（C / C++ / Rust /等）程序的 malloc （和 free ）调用，以对调用 malloc 的调用栈进行采样。关于分配了多少字节的信息也被保留。CPU分析（CPU profiling）用于了解程序在哪里花费CPU时间。分析器捕获CPU上运行的调用堆栈。通常这是周期性的（例如每50ms），但也可以在操作系统中发生某些事件时执行。

#### Profiling vs Tracing 分析与跟踪

比较分析（Profiling）和跟踪（Tracing）有两个主要问题：

- 当我可以追踪所有内容时，为什么要统计地分析我的程序？
- 当分析能提供使用最多资源的精确代码行时，为什么还要使用跟踪（Tracing）来重建事件的时间轴呢？

##### When to use profiling over tracing 什么时候使用分析而不是跟踪

跟踪（tracing）不可能捕获极端高频事件的执行，例如每个函数调用。分析工具（Profiling tools）填补了这一利基：通过抽样（sampling），它们可以显著减少存储的信息量。配置文件（profile）的统计性质很少是一个问题；配置文件（profile）的采样算法是专门为捕获高度代表实际资源使用情况的数据而设计的。

另外：有一些非常专业的跟踪工具可以捕获每个函数调用（例如magic-trace），但它们每秒输出千兆字节的数据，这使得它们不适合用于调查小代码片段以外的任何事情。它们通常比一般用途的跟踪工具有更高的开销。

##### When to use tracing over profiling 什么时候使用跟踪而不是分析

虽然配置文件（profile）给出调用栈的资源被使用的位置，但它们缺乏关于为什么会发生这种情况的信息。例如，为什么malloc被函数foo（）调用了这么多次？它们只是说foo（）通过Y次调用分配X字节给malloc。跟踪（tracing）在提供这种确切的上下文方面非常出色：应用程序插装和低级内核事件一起提供了对为什么首先运行代码的深入视角。

注：Perfetto支持同时收集、分析和可视化配置文件和跟踪（profiles and traces），这样你就可以两全齐美!

## Perfetto

Perfetto是一套用于软件性能分析的工具。它的目的是使工程师能够了解他们的系统正在使用哪些资源。它有助于确定他们可以为提高性能而做出的更改，并验证这些更改的影响。

> 注意：在Perfetto中，由于分析和跟踪（profiles and traces）可以同时收集，所以我们称所有内容为“跟踪”，即使其中可能只包含（仅）分析（profiling）数据。

### Recording traces

在记录轨迹时，Perfetto是高度可配置的。实际上有数百个旋钮可以调节来控制收集什么数据，应该如何收集，跟踪应该包含多少信息等等。

如果您不熟悉Perfetto，那么在Linux上记录跟踪是一个很好的开始。对于Android开发人员来说，在Android快速入门上记录轨迹将更加适用。跟踪配置页面作为参考也很有用。

下面的小节概述了在记录Perfetto轨迹时值得考虑的各个点。

#### Kernel tracing 内核跟踪

Perfetto与Linux内核的ftrace跟踪系统紧密集成，以记录内核事件（例如调度、系统调用、唤醒）。调度、系统调用和CPU频率数据源页面给出了配置ftrace收集的示例。

本地支持的ftrace事件可以在这个原型消息的字段中找到。Perfetto还支持将它不理解的ftrace事件（即它没有protobuf消息）收集为“通用”事件。这些事件被编码为键值对，类似于JSON字典。

强烈建议在生产用例中依赖通用事件：低效的编码会导致跟踪大小膨胀，并且跟踪处理器无法有意义地解析它们。相反，应该为Perfetto添加解析重要ftrace事件的支持：下面是一组简单的步骤。

##### Instrumentation with Perfetto SDK 使用Perfetto SDK进行检测

Perfetto有一个C++ SDK，可以用来检测程序来发出跟踪事件。SDK被设计成开销非常低，并且以一个.cc和一个.h文件的“合并”形式分发，这使得它很容易集成到任何构建系统中。

一个C SDK正在积极开发中，应该会在2023年第二季度发布。有关详细信息，请参阅此文档（注意，查看此文档需要成为该组的成员）

一个用于Android的Java/Kotlin SDK（作为JetPack库）。这还在开发中，但官方发布的时间还没有确定。

###### android.os.Trace （atrace） vs Perfetto SDK

perfeto比atrace有显著的优势。一些最大的优势包括：

- 性能：从系统/应用程序代码跟踪到Perfetto只需要一个内存写入，这远远快于由atrace造成的系统调用延迟。这通常使Perfetto比atrace快3-4倍。
- 特性：atrace的API非常有限，缺乏对调试参数、自定义时钟、流事件的支持。Perfetto拥有更丰富的API，允许数据流的自然表示。
- trace size： Perfetto支持各种特性（delta编码的时间戳、互缩字符串、protobuf编码），这些特性极大地减小了跟踪文件的大小。

不幸的是，也有一些缺点：
- 专用线程：每个想要跟踪到Perfetto的进程都需要一个专用于Perfetto的线程。
- 在跟踪开始时唤醒：目前，当跟踪（tracing ）开始时，每个为跟踪注册的进程都会被唤醒，这极大地限制了可以跟踪的进程数量。这一限制将在未来几个季度被取消。

目前，Perfetto团队的建议是继续在大多数用例中使用atrace：如果你认为你有一个用例可以从SDK中受益，请直接与团队联系。到2023年中期，应在解决当前SDK的局限性方面取得重大进展，允许更广泛地采用SDK。


## Reference

- https：//perfetto.dev/docs/
- https://perfetto.dev/docs/contributing/common-tasks#add-a-new-ftrace-event