import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as a,f as n,o as e}from"./app-D8AnVMyo.js";const l={};function t(h,i){return e(),a("div",null,i[0]||(i[0]=[n(`<h1 id="android-aosp-知识扩展" tabindex="-1"><a class="header-anchor" href="#android-aosp-知识扩展"><span>Android | AOSP | 知识扩展</span></a></h1><h2 id="td-optional" tabindex="-1"><a class="header-anchor" href="#td-optional"><span>td::optional</span></a></h2><p><code>std::optional</code> 是 C++17 中引入的一种容器，用于表示一个可能不存在的对象。其类模板的定义如下：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typename</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> optional</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    optional</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 构造函数，创建一个空的 optional 对象</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    optional</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 构造函数，创建一个存放了 value 值的 optional 对象</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    optional</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 赋值运算符，将 value 赋值给 optional 对象</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">*();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 返回存储在 optional 对象中的值的引用</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">*() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 返回存储在 optional 对象中的值的 const 引用</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 返回存储在 optional 对象中的值的指针</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 返回存储在 optional 对象中的值的 const 指针</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    explicit</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> bool() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 检查 optional 对象是否包含一个值</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 返回存储在 optional 对象中的值的引用，如果对象为空则抛出 std::bad_optional_access 异常</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> T</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 返回存储在 optional 对象中的值的 const 引用，如果对象为空则抛出 std::bad_optional_access 异常</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>std::optional</code> 可以用来避免在代码中使用空指针或无效引用，从而降低代码出错的可能性。在某些情况下，我们需要一个变量可能存在或不存在，这时就可以使用 <code>std::optional</code> 来表示这种可能性。例如：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::optional</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;int&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> num;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 创建一个空的 optional 对象</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">num </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 42</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 将 42 赋值给 optional 对象</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (num) {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 检查 optional 对象是否包含一个值</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;num is &quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">num </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::endl;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 访问存储在 optional 对象中的值</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;num is not set&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::endl;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们使用 <code>std::optional</code> 来表示一个整数变量可能存在或不存在的情况。如果 optional 对象包含一个值，则通过解引用操作符 <code>*</code> 来访问该值。否则，我们可以通过检查对象是否包含值来避免访问未定义的内存。</p><h2 id="std-optional-中-emplace" tabindex="-1"><a class="header-anchor" href="#std-optional-中-emplace"><span>std::optional 中 emplace</span></a></h2><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">... </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">_Args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            class</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> enable_if_t</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                    &lt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                        is_constructible_v&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">value_type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, _Args...&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                    &gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            &gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">_LIBCPP_INLINE_VISIBILITY</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">_Tp </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">emplace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(_Args</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">... __args)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    reset</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">__construct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">_VSTD</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">forward</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">_Args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(__args)...);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">__get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码是<code>std::optional</code>中<code>emplace</code>成员函数的模板实现。<code>emplace</code>函数的主要作用是在<code>std::optional</code>对象中构造一个新的值，使用传入的参数作为构造函数的参数。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 定义emplace成员函数模板</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">... </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">_Args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">          class</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> enable_if_t</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                  &lt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                      is_constructible_v&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">value_type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, _Args...&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                  &gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">         &gt;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 设置内联可见性，使得编译器可以在编译时优化函数调用</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">_LIBCPP_INLINE_VISIBILITY</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 定义emplace函数，返回值类型为模板参数_Tp的引用，接受可变数量的模板参数_Args</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">_Tp </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">emplace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(_Args</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">... __args)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 调用reset()函数，清除optional对象当前的值，为新值做好准备</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    reset</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 使用完美转发将传入的参数列表(__args)转发给构造函数</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">__construct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">_VSTD</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">forward</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">_Args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;(__args)...);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 返回新构造值的引用</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">__get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>emplace</code>函数首先调用<code>reset()</code>方法清除<code>std::optional</code>对象中的当前值。接下来，使用完美转发将传入的参数列表(<code>__args</code>)转发给<code>value_type</code>的构造函数，<code>value_type</code>是存储在<code>std::optional</code>中的类型。最后，返回新构造值的引用。</p><ul><li><a href="https://cs.android.com/android/platform/superproject/+/refs/heads/master:external/libcxx/include/optional;drc=7346c436e5a11ce08f6a80dcfeb8ef941ca30176;bpv=0;bpt=1;l=820?hl=zh-cn" target="_blank" rel="noopener noreferrer">https://cs.android.com/android/platform/superproject/+/refs/heads/master:external/libcxx/include/optional;drc=7346c436e5a11ce08f6a80dcfeb8ef941ca30176;bpv=0;bpt=1;l=820?hl=zh-cn</a></li></ul><h2 id="sys-nanosleep" tabindex="-1"><a class="header-anchor" href="#sys-nanosleep"><span>sys_nanosleep</span></a></h2><p><code>sys_nanosleep</code>是一个操作系统内核系统调用，它用于暂停当前进程一段指定的时间。在Linux系统中，这个系统调用的原型如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;time.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> sys_nanosleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> timespec </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">req</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> timespec </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">rem</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个参数<code>req</code>是一个指向<code>timespec</code>结构体的指针，表示要暂停的时间长度。该结构体包含两个成员变量，分别为<code>tv_sec</code>和<code>tv_nsec</code>，分别表示秒数和纳秒数。第二个参数<code>rem</code>是一个指向<code>timespec</code>结构体的指针，表示剩余未暂停的时间长度。如果在暂停的过程中被信号打断，那么<code>rem</code>将会被设置为剩余未暂停的时间。</p><p><code>sys_nanosleep</code>的返回值为0表示暂停成功，返回-1表示暂停失败，错误码保存在<code>errno</code>中。</p><h2 id="sys-ioctl" tabindex="-1"><a class="header-anchor" href="#sys-ioctl"><span>sys_ioctl</span></a></h2><p><code>sys_ioctl</code>是一个操作系统内核系统调用，用于操作设备文件的I/O控制。在Linux系统中，这个系统调用的原型如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;sys/ioctl.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> sys_ioctl</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> fd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> cmd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> arg</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个参数<code>fd</code>是一个整数类型，表示要进行I/O控制的设备文件描述符。第二个参数<code>cmd</code>是一个无符号整数类型，表示要进行的I/O操作，通常是一个预定义的常量。第三个参数<code>arg</code>是一个无符号长整型，表示I/O操作的参数，可以是一个指针或一个整数。</p><p>不同的设备文件可能支持不同的I/O操作，因此<code>cmd</code>参数的含义也不同。例如，对于网络设备文件，可能有<code>SIOCGIFADDR</code>操作，用于获取设备的IP地址；对于串口设备文件，可能有<code>TCGETS</code>操作，用于获取串口的配置信息。</p><p><code>sys_ioctl</code>的返回值为0表示I/O操作成功，返回-1表示I/O操作失败，错误码保存在<code>errno</code>中。</p><h2 id="android-init-脚本" tabindex="-1"><a class="header-anchor" href="#android-init-脚本"><span>Android init 脚本</span></a></h2><p>Android init 脚本是一种 Android 系统启动时用于配置和启动各种服务、设置属性和创建目录等操作的脚本。它们主要用于定义系统的启动流程和配置各种组件。这些脚本通常位于 Android 源码中的各个子项目和设备特定代码中，如 <code>system/core/rootdir</code>、<code>device/&lt;manufacturer&gt;/&lt;device&gt;/rootdir</code> 等。</p><p>Android init 脚本的作用包括：</p><ol><li>设置系统属性：用于配置系统行为、开关和设备特性等。</li><li>创建目录和文件：用于在启动过程中创建必要的目录结构和文件。</li><li>设置权限：用于设定系统目录和文件的访问权限，以确保正确的访问控制。</li><li>启动服务：用于配置和启动系统中的各种守护进程和服务。</li></ol><p>Android init 脚本使用一种名为 <code>init</code> 的简单语言编写，该语言包含一系列命令和关键字，用于表示不同的操作。例如：</p><ul><li><code>service</code>：定义一个服务，包括服务名、可执行文件路径和相关参数。</li><li><code>on</code>：定义在特定事件触发时要执行的操作。</li><li><code>setprop</code>：设置系统属性。</li><li><code>mkdir</code>：创建目录。</li><li><code>chmod</code>：更改文件或目录权限。</li></ul><p>要使用 Android init 脚本，您需要：</p><ol><li>在 Android 源码中找到相关的 init 脚本，如 <code>init.rc</code>、<code>init.&lt;device&gt;.rc</code> 或设备特定的 init 脚本。</li><li>阅读和理解脚本中的命令和关键字，以及它们在系统启动过程中的作用。</li><li>修改或添加 init 脚本中的命令和关键字，以满足您的需求。</li><li>编译并刷入新的 Android 系统映像，然后观察更改后的系统行为。</li></ol><ul><li><p><a href="https://android.googlesource.com/platform/system/core/+/master/init/README.md" target="_blank" rel="noopener noreferrer">https://android.googlesource.com/platform/system/core/+/master/init/README.md</a></p></li><li><p><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/native/services/surfaceflinger/Android.bp?hl=zh-cn" target="_blank" rel="noopener noreferrer">https://cs.android.com/android/platform/superproject/+/master:frameworks/native/services/surfaceflinger/Android.bp?hl=zh-cn</a></p></li></ul><h2 id="android-bp的作用" tabindex="-1"><a class="header-anchor" href="#android-bp的作用"><span>Android.bp的作用</span></a></h2><p><code>Android.bp</code> 是 Android 开源项目 (AOSP) 中的一种构建脚本，它使用类似 Makefile 的语法来描述如何构建 Android 应用程序、库和模块。它是 AOSP 中使用的 Soong 构建系统的核心组件之一，是 Android 7.0 及更高版本中用于构建的主要构建系统。</p><p><code>Android.bp</code> 文件中描述了一个模块的依赖关系、编译选项、源代码文件列表等信息，构建系统将基于这些信息来生成构建脚本和构建产物。相比于之前使用的 GNU Make 工具链，Soong 构建系统更加灵活、可扩展和高效，能够更好地支持 Android 平台的复杂构建需求。</p><p>在 Android 源代码中，每个模块都有一个相应的 <code>Android.bp</code> 文件，用于描述该模块的构建规则。这些模块包括 Android 系统本身、应用程序、共享库、静态库、插件等。开发者可以修改这些 <code>Android.bp</code> 文件来增加、删除或修改模块的构建规则，以满足自己的需求。</p><p>总之，<code>Android.bp</code> 文件是 AOSP 中描述如何构建 Android 应用程序、库和模块的核心文件，它是 Soong 构建系统的核心组件之一。</p><h2 id="emplace" tabindex="-1"><a class="header-anchor" href="#emplace"><span>emplace</span></a></h2><p><a href="https://en.cppreference.com/w/cpp/utility/optional/emplace" target="_blank" rel="noopener noreferrer">https://en.cppreference.com/w/cpp/utility/optional/emplace</a></p><h2 id="emplace-back" tabindex="-1"><a class="header-anchor" href="#emplace-back"><span>emplace_back</span></a></h2><p><a href="https://en.cppreference.com/w/cpp/container/vector/emplace_back" target="_blank" rel="noopener noreferrer">https://en.cppreference.com/w/cpp/container/vector/emplace_back</a></p><h2 id="surfaceflinger" tabindex="-1"><a class="header-anchor" href="#surfaceflinger"><span>surfaceflinger</span></a></h2><p>service surfaceflinger /system/bin/surfaceflinger class core animation user system group graphics drmrpc readproc capabilities SYS_NICE onrestart restart --only-if-running zygote task_profiles HighPerformance socket pdx/system/vr/display/client stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0 socket pdx/system/vr/display/manager stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0 socket pdx/system/vr/display/vsync stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0</p><p><code>surfaceflinger.rc</code> 是一个 Android init 脚本，用于定义 SurfaceFlinger 服务的配置。SurfaceFlinger 是 Android 系统的核心组件，负责合成和显示图形。该文件定义了 SurfaceFlinger 服务的启动方式和权限。现在让我们分析文件的每一行内容：</p><ol><li><p><code>service surfaceflinger /system/bin/surfaceflinger</code>定义一个名为 &quot;surfaceflinger&quot; 的服务，它的可执行文件位于 <code>/system/bin/surfaceflinger</code>。</p></li><li><p><code>class core animation</code>将 SurfaceFlinger 服务分配到 &quot;core&quot; 和 &quot;animation&quot; 类别。这些类别用于在特定条件下控制服务的启动和关闭。</p></li><li><p><code>user system</code>设置 SurfaceFlinger 服务运行在 &quot;system&quot; 用户上下文中。</p></li><li><p><code>group graphics drmrpc readproc</code>将 SurfaceFlinger 服务的组设置为 &quot;graphics&quot;、&quot;drmrpc&quot; 和 &quot;readproc&quot;。这些组定义了服务的权限。</p></li><li><p><code>capabilities SYS_NICE</code>赋予 SurfaceFlinger 服务 SYS_NICE 功能。这允许服务更改其调度优先级，以便在需要时获得更多 CPU 时间。</p></li><li><p><code>onrestart restart --only-if-running zygote</code>如果 SurfaceFlinger 服务重启，该行命令会尝试重启名为 &quot;zygote&quot; 的服务。<code>--only-if-running</code> 参数确保仅在 &quot;zygote&quot; 服务已运行时执行重启操作。</p></li><li><p><code>task_profiles HighPerformance</code>为 SurfaceFlinger 服务分配 &quot;HighPerformance&quot; 任务配置文件。这可能会调整服务的性能参数。</p></li></ol><p>8-10. <code>socket pdx/...</code>这三行定义了 SurfaceFlinger 服务用于与客户端通信的 UNIX 域套接字。套接字的权限、所有者和安全上下文在这些行中定义。</p><p>总之，<code>surfaceflinger.rc</code> 文件定义了 SurfaceFlinger 服务的启动配置、权限和通信方式。这个文件在 Android 系统启动时被 init 进程读取，用于正确地启动和运行 SurfaceFlinger 服务。</p>`,48)]))}const d=s(l,[["render",t],["__file","extend.html.vue"]]),r=JSON.parse('{"path":"/learn-android/aosp/extend.html","title":"Android | AOSP | 知识扩展","lang":"zh-CN","frontmatter":{"tag":["android","aosp"],"description":"Android | AOSP | 知识扩展 td::optional std::optional 是 C++17 中引入的一种容器，用于表示一个可能不存在的对象。其类模板的定义如下： std::optional 可以用来避免在代码中使用空指针或无效引用，从而降低代码出错的可能性。在某些情况下，我们需要一个变量可能存在或不存在，这时就可以使用 std::...","head":[["meta",{"property":"og:url","content":"https://github.com/biezhihua/learn-android/aosp/extend.html"}],["meta",{"property":"og:site_name","content":"biezhihua的日常"}],["meta",{"property":"og:title","content":"Android | AOSP | 知识扩展"}],["meta",{"property":"og:description","content":"Android | AOSP | 知识扩展 td::optional std::optional 是 C++17 中引入的一种容器，用于表示一个可能不存在的对象。其类模板的定义如下： std::optional 可以用来避免在代码中使用空指针或无效引用，从而降低代码出错的可能性。在某些情况下，我们需要一个变量可能存在或不存在，这时就可以使用 std::..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-08T14:25:34.000Z"}],["meta",{"property":"article:tag","content":"android"}],["meta",{"property":"article:tag","content":"aosp"}],["meta",{"property":"article:modified_time","content":"2025-03-08T14:25:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Android | AOSP | 知识扩展\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-08T14:25:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"别志华\\",\\"url\\":\\"https://github.com/biezhihua\\"}]}"]]},"git":{"createdTime":1683214282000,"updatedTime":1741443934000,"contributors":[{"name":"biezhihua","username":"biezhihua","email":"biezhihua@gmail.com","commits":9,"url":"https://github.com/biezhihua"}]},"readingTime":{"minutes":8.36,"words":2509},"filePathRelative":"learn-android/aosp/extend.md","localizedDate":"2023年5月4日","excerpt":"","autoDesc":true}');export{d as comp,r as data};
