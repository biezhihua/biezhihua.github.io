import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as i,f as e,o as n}from"./app-CeWOgC-6.js";const t={};function r($,a){return n(),i("div",null,a[0]||(a[0]=[e('<h1 id="算法思想" tabindex="-1"><a class="header-anchor" href="#算法思想"><span>算法思想</span></a></h1><h2 id="算法基本思想" tabindex="-1"><a class="header-anchor" href="#算法基本思想"><span>算法基本思想</span></a></h2><p>在计算机科学中，常用的算法设计思想包括以下几种：</p><ul><li><p>贪心算法：</p><ul><li>贪心算法是一种简单而有效的算法设计思想，其核心思想是通过每一步选择最优的局部解，最终得到全局最优解。贪心算法通常适用于那些具有最优子结构的问题，即问题的最优解可以通过局部最优解推导得到。</li><li>贪心算法通常用于最优化间题，我们做出一组选择来达到最优解。贪心算法的思想是每步选择都追求局部最优。一个简单的例子是找零间题：为了最小化找零的硬币数量，我们反复选择不大于剩余金额的最大面额的硬币。贪心方法对很多间题都能求得最优解，而且速度比动态规划方法决得多。但是，我们并不总能简单地判断出贪心算法是否有效。</li></ul></li><li><p>分治算法：分治算法是一种将问题划分成多个子问题来求解的算法思想。该方法通常通过递归的方式，将原问题分解为更小的子问题，然后将子问题的解合并起来得到原问题的解。分治算法通常适用于那些可以划分为多个相似的子问题的问题，如归并排序和快速排序等。</p></li><li><p>动态规划算法：</p><ul><li>动态规划算法是一种通过将问题划分为多个子问题来求解的算法思想，但与分治算法不同的是，它通常使用迭代的方式来求解子问题，并将子问题的解保存下来，以避免重复计算。动态规划算法通常适用于那些具有重叠子问题和最优子结构的问题，如背包问题和最长公共子序列问题等。</li><li>动态规划通常用来解决最优化间题，在这类间题中，我们通过做出一组选择来达到最优解。在做出每个选择的同时，通常会生成与原间题形式相同的子间题。当多千一个选择子集都生成相同的子间题时，动态规划技术通常就会很有效，其关键技术就是对每个这样的子问题都保存其解，当其重复出现时即可避免重复求解。</li></ul></li><li><p>回溯算法：回溯算法是一种通过逐步构建可能的解来求解问题的算法思想。该方法通常通过递归的方式，将问题转化为子问题，然后构建可能的解，并检查其是否满足问题的要求。如果不满足要求，则撤销上一步并继续搜索下一种可能的解。回溯算法通常适用于那些求解所有可能解的问题，如八皇后问题和旅行商问题等。</p></li><li><p>分支限界算法：分支限界算法是一种通过逐步构建可能的解来求解问题的算法思想。该方法通常通过将问题的解空间划分为多个子空间，并为每个子空间定义一个界限值，然后按照某种策略搜索子空间。分支限界算法通常适用于那些具有可行解和最优解的问题，如旅行商问题和0/1背包问题等。</p></li><li><p>摊还分析：</p><ul><li>摊还分析方法分析一类特定的算法，这类算法执行一组相似的操作组成的序列。摊还分析并不是通过分别分析每个操作的实际代价的界来分析操作序列的代价的界，而是直接分析序列整体的实际代价的界。这种方法的一个好处是，虽然某些操作的代价可能很高，但其他很多操作的代价可能很低。换旬话说，很多操作的运行时间都会在最坏清况时间之内。摊还分析并不仅仅是一种分析工具，它还是一种思考算法设计的方式，因为算法设计和算法运行时间的分析常常是交织在—起的。</li></ul></li></ul><p>以上是常用的算法设计思想，不同的算法和情况可能适用不同的方法。在实际应用中，通常需要结合具体的问题选择最合适的方法进行设计。</p><h2 id="分治算法" tabindex="-1"><a class="header-anchor" href="#分治算法"><span>分治算法</span></a></h2><p>分治算法是一种将问题划分成多个子问题来求解的算法思想。该方法通常通过递归的方式，将原问题分解为更小的子问题，然后将子问题的解合并起来得到原问题的解。分治算法通常适用于那些可以划分为多个相似的子问题的问题，如归并排序和快速排序等。</p><h3 id="分治算法-思路" tabindex="-1"><a class="header-anchor" href="#分治算法-思路"><span>分治算法 - 思路</span></a></h3><p>在分治策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤：</p><ul><li>分解(Divide)步骤将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。</li><li>解决(Conquer)步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。</li><li>合井(Combine)步骤将子问题的解组合成原问题的解。</li></ul><p>当子问题足够大，需要递归求解时，我们称之为递归情况(recursive case)。 当子问题变得足够小，不再需要递归时，我们说递归已经＂触底“，进入了基本情况(base case)。</p><h3 id="分治算法-递归式" tabindex="-1"><a class="header-anchor" href="#分治算法-递归式"><span>分治算法 - 递归式</span></a></h3><p>三种求解递归式的方法，即得出算法的&quot;$\\Theta$&quot;或&quot;$O$&quot;渐近界的方法：</p><ul><li>代入法我们猜测一个界，然后用数学归纳法证明这个界是正确的。</li><li>递归树法将递归式转换为一棵树，其结点表示不同层次的递归调用产生的代价。然后采用边界和技术来求解递归式。</li><li>主方法 可求解形如下面公式的递归式的界： <ul><li>$T(n) = aT(n/b) + f(n)$，其中$a &gt;= 1， b &gt;= 1， f(n)$是一个给定的函数。</li><li>这种形式的递归式很常见，它刻画了这样一个分治算法：生成$a$个子问题，每个子问题的规模是原问题规模的$1/b$，分解和合并步骤总共花费时间为$f(n)$。</li></ul></li></ul><p>其他情况，偶尔会遇到不是等式而是不等式的递归式：</p><ul><li>如果不等式为$T(n) &lt;= 2T(n/2) + \\Theta(n)$，则这种递归式仅描述了$T(n)$的一个上界，因此可以用$O$符号而不是$\\Theta$符号来描述其解。</li><li>如果不等式为$T(n) &gt;= 2T(n/2) + \\Theta(n)$，则这种递归式仅描述了$T(n)$的一个下界，因此可以用$\\Omega$符号来描述其解。</li></ul><h3 id="分治算法-被忽略的技术细节" tabindex="-1"><a class="header-anchor" href="#分治算法-被忽略的技术细节"><span>分治算法 - 被忽略的技术细节</span></a></h3><p>当声明、求解递归式时，我们常常忽略向下取整、向上取整及边界条件。</p><ul><li>向下取整、向上取整及边界条件： <ul><li>如果对$n$个元素调用MERGE-SORT，当$n$为奇数时，两个子问题的规模分别为$\\left \\lfloor 2/n \\right \\rfloor$和$\\left \\lceil 2/n \\right \\rceil$，准确来说都不是$n/2$，因为当$n$是奇数时，$n/2$不是一个整数。技术上，描述MERGE-SORT最坏情况运行时间的准确的递归式为: <ul><li>$T(n) = \\left{\\begin{matrix} \\Theta(1) &amp; 若n = 1 \\ T(\\left \\lfloor 2/n \\right \\rfloor) + T(\\left \\lceil 2/n \\right \\rceil) + \\Theta(n) &amp; 若n &gt;= 1 \\ \\end{matrix}\\right.$</li></ul></li></ul></li><li>忽略数据规模： <ul><li>由于对于一个常量规模的输入，算法的运行时间为常量，因此对于足够小的$n$，表示算法运行时间的递归式一般为$T(n)=\\Theta(1)$。因此，出于方便，我们一般忽略递归式的边界条件，假设对很小的$n$，$T(n)$为常量。 <ul><li>$T(n) = 2T(2/n) + \\Theta(n)$</li><li>去掉了$n$很小时函数值的显式描述。原因在于，虽然改变$T(1)$的值会改变递归式的精确解，但改变幅度不会超过一个常数因子，因而函数的增长阶不会变化。</li></ul></li></ul></li></ul><p>我们先忽略这些细节，稍后再确定这些细节对结果是否有较大影响。通常影响不大，但你需要知道什么时候会影响不大。这一方面可以依靠经验来判断，另一方面，一些定理也表明，对于很多刻画分治算法的递归式，这些细节不会影响其渐近界。</p><h3 id="分治算法-用代入法求解递归式" tabindex="-1"><a class="header-anchor" href="#分治算法-用代入法求解递归式"><span>分治算法 - 用代入法求解递归式</span></a></h3><p>未学习</p><h3 id="分治算法-用递归树法求解递归式" tabindex="-1"><a class="header-anchor" href="#分治算法-用递归树法求解递归式"><span>分治算法 - 用递归树法求解递归式</span></a></h3><p>未学习</p><h3 id="分治算法-用主方法求解递归式" tabindex="-1"><a class="header-anchor" href="#分治算法-用主方法求解递归式"><span>分治算法 - 用主方法求解递归式</span></a></h3><p>主方法为如下形式的递归式提供了一种”菜谱”式的求解方法：</p><ul><li>$T(n) = aT(n/b) + f(n)$，其中$a &gt;= 1$和$b &gt; 1$是常数，$f(n)$是渐近正函数。</li></ul><p>递归式描述的是这样一种算法的运行时间：它将规模为$n$的问题分解为$a$个子问题，每个子问题规模为$n/b$，其中$a$和$b$都是正常数。$a$个子问题递归地进行求解，每个花费时间$T(n/b)$。函数$f(n)$包含了问题分解和子问题解合并的代价。</p><p>主方法依赖于下面的定理:</p><ul><li>令$a &gt;= 1$和$b &gt; 1$是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式：$T(n) = aT(n/b) + f(n)$，其中我们将$n/$b解释为$\\left \\lfloor n/b \\right \\rfloor$或$\\left \\lceil n/b \\right \\rceil$。那么$T(n)$有如下渐近界： <ul><li><ol><li>若对某个常数 $\\varepsilon &gt; 0$ 有 $f(n)=O(n^{log_{b}{a-\\varepsilon}})$，则 $T(n)=\\Theta(n^{log_{b}{a}})$。</li></ol></li><li><ol start="2"><li>若 $f(n)=\\Theta(n^{log_{b}{a}})$，则 $T(n)=\\Theta(n^{log_{b}{a}}lgn)$。</li></ol></li><li><ol start="3"><li>若对某个常数 $\\varepsilon &gt; 0$ 有 $f(n)=\\Omega(n^{log_{b}{a+\\varepsilon}})$，且对某个常数 $c &lt; 1$ 和所有足够大的 $n$ 有 $af(n/b) &lt;= cf(n)$，则 $T(n)=\\Theta(f(n))$。</li></ol></li></ul></li></ul><p>对于三种情况的每一种，我们将函数 $f(n)$ 与函数 $n^{log_{b}{a}}$ 进行比较。直觉上，两个函数较大者决定了递归式的解。</p><ul><li>若函数 $n^{log_{b}{a}}$ 更大，如情况1，则解为$T(n)=\\Theta(n^{log_{b}{a}})$）。</li><li>若函数 $f(n)$ 更大，如情况3，则解为 $T(n)=\\Theta(f(n))$。</li><li>若两个函数大小相当，如情况2，则乘上一个对数因子，解为 $T(n)=\\Theta(n^{log_{b}{a}}lgn)$。</li></ul><p>在第一种情况中，不是$f(n)$小于$n^{log_{b}{a}}$就够了，而是要多项式意义上的小于。也就是说，$f(n)$必须渐近小于$n^{log_{b}{a}}$要相差一个因子$n^{\\varepsilon}$，其中$\\varepsilon$是大于0的常数。</p><p>在第三种情况中，不是$f(n)$大于$n^{log_{b}{a}}$就够了，而是要多项式意义上的大于，而且还要满足“正则”条件$af(n/b) &lt;= cf(n)$。</p><h2 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划"><span><a href="https://oi-wiki.org/dp/" target="_blank" rel="noopener noreferrer">动态规划</a></span></a></h2><p>动态规划(dynamic programming)与分治方法相似，都是通过组合子问题的解来求解原问题。</p><p>动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。在这种情况下，分治算法会做许多不必要的工作，它会反复地求解那些公共子子问题。而动态规划算法对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了这种不必要的计算工作。</p><p>动态规划方法通常用来求解最优化问题(optimization problem)。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们称这样的解为问题的一个最优解(an optimal solution), 而不是最优解(the optimal solution) , 因为可能有多个解都达到最优值。</p><p>我们通常按如下4个步骤来设计一个动态规划算法：</p><ul><li><ol><li>刻画一个最优解的结构特征。</li></ol></li><li><ol start="2"><li>递归地定义最优解的值。</li></ol></li><li><ol start="3"><li>计算最优解的值，通常采用自底向上的方法。</li></ol></li><li><ol start="4"><li>利用计算出的信息构造一个最优解。</li></ol></li></ul><p>步骤1~3是动态规划算法求解问题的基础。如果我们仅仅需要一个最优解的值，而非解本身，可以忽略步骤4。如果确实要做步骤4,有时就需要在执行步骤3的过程中维护一些额外信息，以便用来构造一个最优解。</p><h3 id="钢条切割" tabindex="-1"><a class="header-anchor" href="#钢条切割"><span>钢条切割</span></a></h3><h3 id="矩阵链乘法" tabindex="-1"><a class="header-anchor" href="#矩阵链乘法"><span>矩阵链乘法</span></a></h3><h3 id="动态规划原理" tabindex="-1"><a class="header-anchor" href="#动态规划原理"><span>动态规划原理</span></a></h3><h3 id="最长公共子序列" tabindex="-1"><a class="header-anchor" href="#最长公共子序列"><span>最长公共子序列</span></a></h3><h3 id="最优二叉搜索树" tabindex="-1"><a class="header-anchor" href="#最优二叉搜索树"><span>最优二叉搜索树</span></a></h3><h2 id="贪心算法" tabindex="-1"><a class="header-anchor" href="#贪心算法"><span>贪心算法</span></a></h2><h2 id="摊还分析" tabindex="-1"><a class="header-anchor" href="#摊还分析"><span>摊还分析</span></a></h2>',48)]))}const p=l(t,[["render",r],["__file","Algorithms-thinking.html.vue"]]),s=JSON.parse('{"path":"/learn-leetcode/Algorithms-thinking.html","title":"算法思想","lang":"zh-CN","frontmatter":{"description":"算法思想 算法基本思想 在计算机科学中，常用的算法设计思想包括以下几种： 贪心算法： 贪心算法是一种简单而有效的算法设计思想，其核心思想是通过每一步选择最优的局部解，最终得到全局最优解。贪心算法通常适用于那些具有最优子结构的问题，即问题的最优解可以通过局部最优解推导得到。 贪心算法通常用于最优化间题，我们做出一组选择来达到最优解。贪心算法的思想是每步选...","head":[["meta",{"property":"og:url","content":"https://github.com/biezhihua/learn-leetcode/Algorithms-thinking.html"}],["meta",{"property":"og:site_name","content":"biezhihua的日常"}],["meta",{"property":"og:title","content":"算法思想"}],["meta",{"property":"og:description","content":"算法思想 算法基本思想 在计算机科学中，常用的算法设计思想包括以下几种： 贪心算法： 贪心算法是一种简单而有效的算法设计思想，其核心思想是通过每一步选择最优的局部解，最终得到全局最优解。贪心算法通常适用于那些具有最优子结构的问题，即问题的最优解可以通过局部最优解推导得到。 贪心算法通常用于最优化间题，我们做出一组选择来达到最优解。贪心算法的思想是每步选..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-08T14:25:34.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-08T14:25:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"算法思想\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-08T14:25:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"别志华\\",\\"url\\":\\"https://github.com/biezhihua\\"}]}"]]},"git":{"createdTime":1678770176000,"updatedTime":1741443934000,"contributors":[{"name":"biezhihua","username":"biezhihua","email":"biezhihua@gmail.com","commits":2,"url":"https://github.com/biezhihua"}]},"readingTime":{"minutes":10.94,"words":3282},"filePathRelative":"learn-leetcode/Algorithms-thinking.md","localizedDate":"2023年3月14日","excerpt":"","autoDesc":true}');export{p as comp,s as data};
