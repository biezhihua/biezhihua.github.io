import{_ as n,Y as s,Z as a,a2 as t}from"./framework-301d0703.js";const o={},e=t(`<h1 id="python中-async-在执行耗时任务时会通过await让出控制权-那么耗时任务是在哪个线程中执行的-我不太理解。" tabindex="-1"><a class="header-anchor" href="#python中-async-在执行耗时任务时会通过await让出控制权-那么耗时任务是在哪个线程中执行的-我不太理解。" aria-hidden="true">#</a> python中 async 在执行耗时任务时会通过await让出控制权， 那么耗时任务是在哪个线程中执行的？ 我不太理解。</h1><p>在 Python 的 <code>asyncio</code> 异步编程模型中，<code>async</code> 和 <code>await</code> 关键字用于编写异步协程，以实现高效的单线程并发。当一个协程在执行过程中遇到 <code>await</code> 时，会将控制权让回给事件循环，以便其他协程能够运行。</p><p><strong>您的问题是：在协程通过 <code>await</code> 让出控制权时，耗时任务是在哪个线程中执行的？</strong></p><hr><h2 id="关键概念" tabindex="-1"><a class="header-anchor" href="#关键概念" aria-hidden="true">#</a> <strong>关键概念</strong></h2><h3 id="_1-事件循环和单线程" tabindex="-1"><a class="header-anchor" href="#_1-事件循环和单线程" aria-hidden="true">#</a> <strong>1. 事件循环和单线程</strong></h3><ul><li><strong>事件循环（Event Loop）</strong>：<code>asyncio</code> 的核心，用于调度和执行协程。</li><li><strong>单线程执行</strong>：默认情况下，<code>asyncio</code> 事件循环在单线程中运行，所有协程也在同一线程中执行。</li></ul><h3 id="_2-协程和-await" tabindex="-1"><a class="header-anchor" href="#_2-协程和-await" aria-hidden="true">#</a> <strong>2. 协程和 <code>await</code></strong></h3><ul><li><strong>协程（Coroutine）</strong>：由 <code>async def</code> 定义的函数，可以在执行过程中暂停和恢复。</li><li><strong><code>await</code> 关键字</strong>：用于等待一个可等待对象（如另一个协程、<code>Future</code>、<code>Task</code> 等）完成。当协程遇到 <code>await</code> 时，会将控制权让回给事件循环。</li></ul><h3 id="_3-非阻塞-i-o-操作" tabindex="-1"><a class="header-anchor" href="#_3-非阻塞-i-o-操作" aria-hidden="true">#</a> <strong>3. 非阻塞 I/O 操作</strong></h3><ul><li><strong>非阻塞操作</strong>：如网络 I/O、文件 I/O，在等待数据的过程中不阻塞线程。</li><li><strong>协程的优势</strong>：在 I/O 等待期间，让出控制权，使事件循环可以调度其他协程执行。</li></ul><hr><h2 id="耗时任务的执行位置" tabindex="-1"><a class="header-anchor" href="#耗时任务的执行位置" aria-hidden="true">#</a> <strong>耗时任务的执行位置</strong></h2><h3 id="_1-非阻塞的异步任务" tabindex="-1"><a class="header-anchor" href="#_1-非阻塞的异步任务" aria-hidden="true">#</a> <strong>1. 非阻塞的异步任务</strong></h3><ul><li><strong>执行线程</strong>：仍然在事件循环所在的主线程中执行。</li><li><strong>控制权让出</strong>：当协程遇到 <code>await</code> 一个非阻塞的异步操作时，它会暂停执行，让出控制权给事件循环。</li><li><strong>事件循环管理</strong>：事件循环会在后台管理这些异步操作，一旦操作完成，协程会被恢复执行。</li></ul><p><strong>示例：</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> asyncio

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">async_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;异步任务开始&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment"># 非阻塞地等待 2 秒</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;异步任务完成&quot;</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">await</span> async_task<span class="token punctuation">(</span><span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>解释</strong>：<code>asyncio.sleep(2)</code> 是一个异步非阻塞操作，在等待期间，事件循环可以调度其他协程。</li></ul><h3 id="_2-阻塞的同步任务" tabindex="-1"><a class="header-anchor" href="#_2-阻塞的同步任务" aria-hidden="true">#</a> <strong>2. 阻塞的同步任务</strong></h3><ul><li><strong>问题</strong>：如果协程中包含耗时的同步阻塞操作（如复杂的计算、<code>time.sleep()</code> 等），会阻塞事件循环，无法让出控制权。</li><li><strong>执行线程</strong>：阻塞操作在事件循环所在的主线程中执行，导致整个事件循环被阻塞。</li><li><strong>后果</strong>：其他协程无法被调度，程序的并发性受损。</li></ul><p><strong>示例：</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> time

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">blocking_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;阻塞任务开始&quot;</span><span class="token punctuation">)</span>
    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment"># 阻塞操作</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;阻塞任务完成&quot;</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">await</span> blocking_task<span class="token punctuation">(</span><span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>问题</strong>：<code>time.sleep(5)</code> 是阻塞的同步操作，会阻塞事件循环 5 秒。</li></ul><h3 id="_3-解决方案-将阻塞任务移至线程或进程" tabindex="-1"><a class="header-anchor" href="#_3-解决方案-将阻塞任务移至线程或进程" aria-hidden="true">#</a> <strong>3. 解决方案：将阻塞任务移至线程或进程</strong></h3><ul><li><strong>使用线程池或进程池</strong>：将耗时的阻塞操作放在其他线程或进程中执行，避免阻塞事件循环。</li><li><strong><code>run_in_executor</code> 方法</strong>：<code>asyncio</code> 提供的机制，可以将阻塞操作移至线程池或进程池。</li></ul><p><strong>示例：</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> time

<span class="token keyword">def</span> <span class="token function">blocking_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;阻塞任务开始，线程：</span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;阻塞任务完成，线程：</span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_running_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> loop<span class="token punctuation">.</span>run_in_executor<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> blocking_task<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;协程任务完成&quot;</span><span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>解释</strong>： <ul><li><code>loop.run_in_executor(None, blocking_task)</code>：将 <code>blocking_task</code> 放入默认的线程池中执行。</li><li><strong>执行线程</strong>：<code>blocking_task</code> 在新的线程中执行，不会阻塞事件循环。</li><li><strong>协程让出控制权</strong>：在等待 <code>blocking_task</code> 完成的过程中，协程让出了控制权。</li></ul></li></ul><hr><h2 id="详细解析" tabindex="-1"><a class="header-anchor" href="#详细解析" aria-hidden="true">#</a> <strong>详细解析</strong></h2><h3 id="_1-当协程遇到-await-时发生了什么" tabindex="-1"><a class="header-anchor" href="#_1-当协程遇到-await-时发生了什么" aria-hidden="true">#</a> <strong>1. 当协程遇到 <code>await</code> 时发生了什么？</strong></h3><ul><li><strong>暂停执行</strong>：协程在 <code>await</code> 处暂停，等待被等待的对象完成。</li><li><strong>控制权让出</strong>：事件循环可以调度其他可运行的协程。</li><li><strong>恢复执行</strong>：一旦被等待的对象完成，协程会从暂停的地方继续执行。</li></ul><h3 id="_2-耗时任务的执行" tabindex="-1"><a class="header-anchor" href="#_2-耗时任务的执行" aria-hidden="true">#</a> <strong>2. 耗时任务的执行</strong></h3><ul><li><strong>非阻塞异步任务</strong>： <ul><li><strong>例子</strong>：<code>await asyncio.sleep(2)</code>、网络请求（使用支持异步的库，如 <code>aiohttp</code>）。</li><li><strong>执行位置</strong>：事件循环管理的主线程中，但不会阻塞，因为操作是非阻塞的。</li></ul></li><li><strong>阻塞同步任务</strong>： <ul><li><strong>例子</strong>：复杂计算、<code>time.sleep()</code>、不支持异步的文件 I/O。</li><li><strong>问题</strong>：在协程中直接执行会阻塞事件循环。</li></ul></li></ul><h3 id="_3-如何避免阻塞事件循环" tabindex="-1"><a class="header-anchor" href="#_3-如何避免阻塞事件循环" aria-hidden="true">#</a> <strong>3. 如何避免阻塞事件循环？</strong></h3><ul><li><p><strong>将阻塞操作移至线程或进程</strong>：</p><ul><li><strong>线程池执行器</strong>：适用于 I/O 密集型的阻塞操作。</li><li><strong>进程池执行器</strong>：适用于 CPU 密集型的阻塞操作。</li></ul></li><li><p><strong>代码示例</strong>：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> concurrent<span class="token punctuation">.</span>futures

<span class="token keyword">def</span> <span class="token function">cpu_bound_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 模拟耗时的 CPU 密集型任务</span>
    result <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>i <span class="token operator">*</span> i <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">**</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_running_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">with</span> concurrent<span class="token punctuation">.</span>futures<span class="token punctuation">.</span>ProcessPoolExecutor<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>
        result <span class="token operator">=</span> <span class="token keyword">await</span> loop<span class="token punctuation">.</span>run_in_executor<span class="token punctuation">(</span>pool<span class="token punctuation">,</span> cpu_bound_task<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f&quot;计算结果：</span><span class="token interpolation"><span class="token punctuation">{</span>result<span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>解释</strong>： <ul><li><strong><code>ProcessPoolExecutor</code></strong>：使用进程池来执行 CPU 密集型任务。</li><li><strong><code>run_in_executor</code></strong>：协程等待任务完成，但不会阻塞事件循环。</li></ul></li></ul></li></ul><hr><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> <strong>总结</strong></h2><ul><li><strong>默认情况下</strong>，协程中的代码（包括耗时任务）是在事件循环所在的主线程中执行的。</li><li><strong>当协程遇到 <code>await</code> 时</strong>，如果等待的是一个异步非阻塞操作，协程会暂停执行，事件循环可以调度其他协程。</li><li><strong>如果协程中包含阻塞的同步操作</strong>，会阻塞事件循环，阻碍其他协程的执行。</li><li><strong>为避免阻塞事件循环</strong>，需要将耗时的阻塞操作移至线程池或进程池中执行。</li></ul><hr><h2 id="完整示例" tabindex="-1"><a class="header-anchor" href="#完整示例" aria-hidden="true">#</a> <strong>完整示例</strong></h2><p><strong>假设我们有一个需要读取大量数据的函数，但它是同步阻塞的：</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">read_large_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">&#39;large_file.txt&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;r&#39;</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
        <span class="token keyword">return</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>如果直接在协程中调用会阻塞事件循环：</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    data <span class="token operator">=</span> read_large_file<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 阻塞事件循环</span>
    process_data<span class="token punctuation">(</span>data<span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>正确的做法是使用线程池：</strong></p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> asyncio

<span class="token keyword">def</span> <span class="token function">read_large_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">&#39;large_file.txt&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;r&#39;</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
        <span class="token keyword">return</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_running_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
    data <span class="token operator">=</span> <span class="token keyword">await</span> loop<span class="token punctuation">.</span>run_in_executor<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> read_large_file<span class="token punctuation">)</span>
    process_data<span class="token punctuation">(</span>data<span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>解释</strong>： <ul><li><code>loop.run_in_executor(None, read_large_file)</code>：将 <code>read_large_file</code> 函数放入默认的线程池中执行。</li><li><strong>线程池中的执行</strong>：<code>read_large_file</code> 在新的线程中执行，不会阻塞事件循环。</li><li><strong>协程等待结果</strong>：<code>await</code> 用于等待函数的返回结果，但在等待期间，事件循环可以调度其他协程。</li></ul></li></ul><hr><h2 id="回答您的疑问" tabindex="-1"><a class="header-anchor" href="#回答您的疑问" aria-hidden="true">#</a> <strong>回答您的疑问</strong></h2><ul><li><p><strong>耗时任务在哪个线程中执行？</strong></p><ul><li><strong>非阻塞的异步任务</strong>：在事件循环的主线程中执行，不会阻塞，因为它们在等待 I/O 操作完成时让出了控制权。</li><li><strong>阻塞的同步任务</strong>：如果直接在协程中调用，会在主线程中执行，阻塞事件循环。为了避免阻塞，需要将其移至线程池或进程池中执行。</li></ul></li><li><p><strong>为什么要让出控制权？</strong></p><ul><li><strong>提高并发性</strong>：通过在 <code>await</code> 处让出控制权，其他协程可以被调度执行，提高程序的并发性能。</li><li><strong>避免阻塞事件循环</strong>：让出控制权确保事件循环可以持续运行，处理 I/O 事件和调度协程。</li></ul></li><li><p><strong>如何决定任务的执行位置？</strong></p><ul><li><strong>非阻塞的异步操作</strong>：可以直接在协程中 <code>await</code>，由事件循环管理。</li><li><strong>阻塞的同步操作</strong>：应使用 <code>run_in_executor</code> 将其移至线程池或进程池中执行。</li></ul></li></ul><hr><h2 id="额外提示" tabindex="-1"><a class="header-anchor" href="#额外提示" aria-hidden="true">#</a> <strong>额外提示</strong></h2><ul><li><strong>使用异步库</strong>：在可能的情况下，使用支持异步的库（如 <code>aiohttp</code>）来执行 I/O 操作，避免阻塞事件循环。</li><li><strong>避免在协程中使用阻塞操作</strong>：如 <code>time.sleep()</code>、阻塞的文件 I/O 等，应替换为异步版本（如 <code>asyncio.sleep()</code>）。</li><li><strong>线程池 vs. 进程池</strong>： <ul><li><strong>线程池（ThreadPoolExecutor）</strong>：适用于 I/O 密集型的阻塞任务，因为线程在等待 I/O 时不会占用 GIL。</li><li><strong>进程池（ProcessPoolExecutor）</strong>：适用于 CPU 密集型的阻塞任务，因为进程有独立的 Python 解释器，不受 GIL 的限制。</li></ul></li></ul><hr><h2 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> <strong>总结</strong></h2><ul><li><strong>事件循环在单线程中运行，默认情况下，协程也是在同一线程中执行的。</strong></li><li><strong>当协程遇到 <code>await</code> 时，会将控制权让回给事件循环，以便调度其他协程。</strong></li><li><strong>耗时的非阻塞异步任务（如网络 I/O）在主线程中执行，但不会阻塞，因为它们在等待时让出了控制权。</strong></li><li><strong>耗时的阻塞同步任务会阻塞事件循环，需要使用 <code>run_in_executor</code> 将其移至线程池或进程池中执行。</strong></li></ul><p>希望这能帮助您理解 Python 中 <code>async</code> 和 <code>await</code> 的执行机制，以及耗时任务的执行位置。如果您还有其他疑问，请随时提问！</p>`,58),p=[e];function i(c,l){return s(),a("div",null,p)}const r=n(o,[["render",i],["__file","python-async-block-unblock.html.vue"]]);export{r as default};
