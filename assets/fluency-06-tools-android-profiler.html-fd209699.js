import{_ as i,C as o,Y as t,Z as n,$ as e,a0 as a,a1 as l,a2 as d}from"./framework-301d0703.js";const c="/learn-android/performance/fluency-tools-android-cpu-profiler-traces.png",s="/learn-android/performance/fluency-tools-android-cpu-profiler-system-trace-record.png",p="/learn-android/performance/fluency-tools-android-cpu-profiler-java-kotlin-method-trace.png",u="/learn-android/performance/fluency-tools-android-cpu-profiler-callstack-sample-record.png",h={},f=d('<h1 id="android-性能优化-流畅性-第06篇-性能分析工具-android-cpu-profiler" tabindex="-1"><a class="header-anchor" href="#android-性能优化-流畅性-第06篇-性能分析工具-android-cpu-profiler" aria-hidden="true">#</a> Android | 性能优化 | 流畅性 - 第06篇 - 性能分析工具 - Android CPU Profiler</h1><h2 id="android-cpu-profiler-介绍" tabindex="-1"><a class="header-anchor" href="#android-cpu-profiler-介绍" aria-hidden="true">#</a> Android CPU Profiler 介绍</h2><p>Android Profiler 是 Android Studio 内置的一个性能分析工具，用于监控和分析应用的性能。在 CPU 分析器中，有三种主要的跟踪类型：Callstack Sample、System Trace 和 Java/Kotlin Method Trace。</p><p>Callstack Sample 适用于快速定位性能瓶颈，System Trace 适用于分析应用程序与系统的交互，而 Java/Kotlin Method Trace 适用于深入分析代码中的性能问题。通过使用这些工具，可以更有效地发现并解决应用程序中的性能问题。</p><p>下面介绍这三种跟踪类型的使用场景和实现原理以及优缺点。</p><p><img src="'+c+'" alt="fluency-tools-android-cpu-profiler-traces"></p><h3 id="callstack-sample" tabindex="-1"><a class="header-anchor" href="#callstack-sample" aria-hidden="true">#</a> Callstack Sample</h3><p>使用场景：</p><ul><li>Callstack Sample 适用于分析应用程序中可能存在的性能瓶颈。它会提供Java和Native方法的调用堆栈的采样，帮助你找到可能导致性能问题的函数。</li></ul><p>实现原理：</p><ul><li>Callstack Sample 它使用 Simpleperf 采样 Java/Kotlin 和 Native 代码，通过周期性地获取应用程序的调用堆栈来分析应用程序的性能。它不会记录所有方法的调用信息，而是在指定的时间间隔内捕获调用堆栈的快照。通过这些快照，可以确定应用程序的性能瓶颈所在。</li></ul><p>优缺点：</p><ul><li>优点： <ul><li>低开销：由于采样的方式，Callstack Sample 对应用程序性能的影响较小，可以在实际运行过程中进行性能分析。</li><li>快速定位：可以迅速发现 CPU 使用率高的线程和函数，便于快速定位性能瓶颈。</li></ul></li><li>缺点： <ul><li>不够精确：采样的方式可能导致一些较短时间执行的方法被忽略，从而无法发现所有的性能问题。</li><li>难以发现具体问题：仅提供了方法调用栈的概览，可能难以找到具体的性能问题。</li></ul></li></ul><h3 id="system-trace" tabindex="-1"><a class="header-anchor" href="#system-trace" aria-hidden="true">#</a> System Trace</h3><p>使用场景：</p><ul><li>System Trace 适用于分析应用程序与操作系统之间的交互，以及与其他应用程序或系统组件之间的交互。System Trace 可以帮助你理解应用程序在系统范围内的性能表现，例如 CPU 调度、线程同步和其他系统级事件。</li></ul><p>实现原理：</p><ul><li>System Trace 使用 Android 操作系统内置的跟踪工具 (如 Systrace 或 Perfetto) 收集操作系统级别的事件数据。这些工具可以捕获详细的系统事件，包括 CPU 调度、线程状态变化、锁争用、内存分配等。通过分析这些事件，可以了解应用程序与系统资源的交互情况，从而找到性能瓶颈。</li></ul><p>优缺点：</p><ul><li>优点： <ul><li>系统级信息：可以捕获操作系统级别的详细事件数据，帮助你了解应用程序与系统资源的交互情况。</li><li>多方面分析：可以分析 CPU 调度、线程同步、内存分配等多方面的性能问题。</li></ul></li><li>缺点： <ul><li>开销较大：由于收集的数据量较大，可能会对应用程序的性能产生一定影响。</li><li>分析复杂：由于涉及系统级事件，分析 System Trace 可能需要更深入的操作系统知识。</li></ul></li></ul><h3 id="java-kotlin-method-trace" tabindex="-1"><a class="header-anchor" href="#java-kotlin-method-trace" aria-hidden="true">#</a> Java/Kotlin Method Trace</h3><p>使用场景：</p><ul><li>Java/Kotlin Method Trace 适用于深入分析 Java 或 Kotlin 代码的性能问题。它可以帮助你了解代码中每个方法的执行时间和调用次数，从而发现潜在的性能问题。</li></ul><p>实现原理：</p><ul><li>Java/Kotlin Method Trace 通过在应用程序运行时记录每个方法的调用信息来分析性能。当你开始方法跟踪时，Android Profiler 会通知应用程序启用方法跟踪。之后，应用程序会在每次方法调用时记录相关信息，包括方法名称、开始时间、执行时间等。在跟踪结束后，Android Profiler 会收集这些数据并生成一个详细的方法调用报告，供你分析性能问题。</li></ul><p>优缺点：</p><ul><li>优点： <ul><li>详细信息：可以获取每个方法的执行时间和调用次数，有助于深入分析代码中的性能问题。</li><li>针对性强：专注于 Java/Kotlin 代码，使得在分析代码性能时更加针对性。</li></ul></li><li>缺点： <ul><li>开销较大：由于需要记录每个方法的调用信息，可能会对应用程序的性能产生较大影响。</li><li>可能不全面：仅针对 Java/Kotlin 代码，可能无法发现底层系统或原生代码中的性能问题。</li></ul></li></ul><h2 id="android-cpu-profiler-实践中的应用" tabindex="-1"><a class="header-anchor" href="#android-cpu-profiler-实践中的应用" aria-hidden="true">#</a> Android CPU Profiler 实践中的应用</h2><p>Android CPU Profiler 在这些场景中要如何使用呢？基本的思路是：</p><ul><li>先录制 System Trace，利用 Trace Points 初步分析、定位问题。</li><li>再借助 Java/Kotlin Method Trace 分析 Java 层代码的问题。</li><li>再借助 Callstack Sample Trace 分析 Native 层代码的问题。</li></ul><p>Android CPU Profiler 最大优势是集成了各种子工具，在一个地方就能操作一切，对应用开发者来说是非常方便的，下面通过一个简单的案例来看一下Android CPU Profiler中的各个模式是如何配合的。</p><p>当碰到性能问题时，先通过 Android CPU Profiler 录制一个 System Trace 如下：</p><p><img src="'+s+'" alt="fluency-tools-android-cpu-profiler-system-trace-record"></p>',33),m={href:"https://ui.perfetto.dev/",target:"_blank",rel:"noopener noreferrer"},_=e("p",null,"要分析 Java/Kotlin 函数耗时情况，我们要录制一个 Java/Kotlin Method Trace，如下：",-1),v=e("p",null,[e("img",{src:p,alt:"fluency-tools-android-cpu-profiler-java-kotlin-method-trace"})],-1),P=e("p",null,"通过上面 Trace 很容易发现是一个叫做 Utils.stringFromJNI 的 native 函数耗时，因为涉及到C/C++ 代码，所以要再录制一个 Callstack Sample Trace 进一步分析，如下：",-1),T=e("p",null,[e("img",{src:u,alt:"fluency-tools-android-cpu-profiler-callstack-sample-record"})],-1),y=e("p",null,"可以发现在 native 的 Java_com_example_myapplication_Utils_stringFromJNI 中代码执行了 sleep，它就是导致了性能问题的原因。",-1),C=e("h2",{id:"引用",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#引用","aria-hidden":"true"},"#"),a(" 引用")],-1),k={href:"https://www.androidperformance.com/2022/01/07/The-Performace-1-Performance-Tools",target:"_blank",rel:"noopener noreferrer"},S=e("h2",{id:"版权声明",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#版权声明","aria-hidden":"true"},"#"),a(" 版权声明")],-1),J={href:"https://creativecommons.org/licenses/by-nc/4.0/",target:"_blank",rel:"noopener noreferrer"};function x(g,A){const r=o("ExternalLinkIcon");return t(),n("div",null,[f,e("p",null,[a("通过上面 Trace 可以知道是在主线程中的 doFrame内的View#draw() 操作耗时，如果发现不了问题，建议导出到 "),e("a",m,[a("https://ui.perfetto.dev/"),l(r)]),a(" 进一步分析，通过查找发现是 View#draw() 方法内的名为 LowView-onDraw 的 Java方法耗时。")]),_,v,P,T,y,C,e("ul",null,[e("li",null,[e("a",k,[a("https://www.androidperformance.com/2022/01/07/The-Performace-1-Performance-Tools"),l(r)])])]),S,e("p",null,[a("本文采用"),e("a",J,[a("知识共享署名-非商业性使用 4.0 国际许可协议"),l(r)]),a("进行许可")])])}const w=i(h,[["render",x],["__file","fluency-06-tools-android-profiler.html.vue"]]);export{w as default};
