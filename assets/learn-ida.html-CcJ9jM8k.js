import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e,f as t,o as n}from"./app-D8AnVMyo.js";const i={};function r(h,p){return n(),e("div",null,p[0]||(p[0]=[t('<h1 id="learn-ida" tabindex="-1"><a class="header-anchor" href="#learn-ida"><span>Learn IDA</span></a></h1><h2 id="第一部分-ida简介" tabindex="-1"><a class="header-anchor" href="#第一部分-ida简介"><span>第一部分　IDA简介</span></a></h2><h3 id="第1章-反汇编简介" tabindex="-1"><a class="header-anchor" href="#第1章-反汇编简介"><span>第1章　反汇编简介</span></a></h3><h4 id="_1-1-反汇编理论" tabindex="-1"><a class="header-anchor" href="#_1-1-反汇编理论"><span>1.1　反汇编理论</span></a></h4><h4 id="_1-2-何为反汇编" tabindex="-1"><a class="header-anchor" href="#_1-2-何为反汇编"><span>1.2　何为反汇编</span></a></h4><p>在传统的软件开发模型中，程序员使用编译器、汇编器和链接器中的一个或几个创建可执行程序。</p><p>为了回溯编程过程（或对程序进行逆向工程），我们使用各种工具来撤销汇编和编译过程。毫不奇怪，这些工具就叫做反汇编器 和反编译器 ，名副其实。</p><p>反汇编器撤销汇编过程，因此，我们可以得到汇编语言形式的输出结果（以机器语言作为输入）</p><p>反编译器则以汇编语言甚至是机器语言为输入，其输出结果为高级语言。</p><h4 id="_1-3-为何反汇编" tabindex="-1"><a class="header-anchor" href="#_1-3-为何反汇编"><span>1.3　为何反汇编</span></a></h4><p>动态分析和静态分析是分析恶意软件的两种主要技术。 动态分析 （dynamic analysis ）是指在严格控制的环境（沙盒）中执行恶意软件，并使用系统检测实用工具记录其所有行为。 相反，静态分析 （static analysis ）则试图通过浏览程序代码来理解程序的行为。</p><h4 id="_1-4-如何反汇编" tabindex="-1"><a class="header-anchor" href="#_1-4-如何反汇编"><span>1.4　如何反汇编</span></a></h4><p>以最常见的情形——反汇编可执行文件——为例，该文件必须符合可执行文件的某种通用格式，如 Windows 所使用的可移植可执行 （Portable Executable ，PE）格式或许多 Unix 系统常用的可执行和链接格式 （Executable and linking format ，ELF ）。</p><p>这些格式通常含有一种机制，用来确定文件中包含代码和代码入口点的部分的位置（通常表现为层级文件头的形式）。</p><p>代码入口点是一个指令地址，一旦程序加载到内存，操作系统就将控制权交给该指令。</p><p>表查找，将二进制操作码的值与它的汇编语言助记符对应起来。</p><p>有多种汇编语言输出格式可供选择。例如，x86 汇编语言所使用的两种主要格式为 Intel 格式和AT &amp; T 格式。</p><p>AT &amp; T 汇编语法以%作为所有寄存器名称的前缀，以$作为文字常量（也叫做立即操作数）的前缀。它这样对操作数排序：源操作数位于左边，目的操作数位于右边。使用AT &amp; T 语法，EAX寄存器加4 的指令为： add $0x4,%eax。GNU汇编器（Gas）和许多其他GNU工具（如 gcc 和gdb）都使用AT &amp; T 语法。</p><p>Intel 语法与AT &amp; T 语法不同，它不需要寄存器和文字前缀，它的操作数排序方式与AT &amp; T语法操作数恰恰相反：源操作数位于右边，目的操作数位于左边。使用 Intel 语法，上述加法的指令为：add eax, 0x4 。使用 Intel 语法的汇编器包括微软汇编器（MASM）、Borland的Turbo汇编器（TASM ）和Netwide汇编器（NASM ）。</p><p>线性扫描 （linear sweep）和递归下降 （recursive descent ）是两种最主要的反汇编算法。</p><p>GNU调试器（gdb）、微软公司的 WinDbg调试器和 objdump 实用工具的反汇编引擎均采用线性扫描算法</p><p>如果CPU 首先存储一个多字节值的最高有效字节，则称该CPU 为大端（big-endian）CPU ；如果该CPU 首先存储最低有效字节，则称为小端（little-endial ）CPU 。</p><h4 id="_1-5-小结" tabindex="-1"><a class="header-anchor" href="#_1-5-小结"><span>1.5　小结</span></a></h4><h2 id="第2章-逆向与反汇编工具" tabindex="-1"><a class="header-anchor" href="#第2章-逆向与反汇编工具"><span>第2章　逆向与反汇编工具</span></a></h2><p>2.1　分类工具</p><p>文件扩展名并无实际意义。</p><p>幻数文件的默认位置因操作系统而异，常见的位置包括/usr/share/file/magic、/usr/share/misc/magic 和/etc/magic。</p><p>在逆向工程过程中，绝不要完全相信任何工具所提供的结果，除非该结果得到其他几款工具和手动分析的确认，这是一个良好的习惯。</p><p>2.2　摘要工具</p><p>2.3　深度检测工具</p><p>2.4　小结</p><h2 id="第3章-ida-pro-背景知识" tabindex="-1"><a class="header-anchor" href="#第3章-ida-pro-背景知识"><span>第3章　IDA Pro 背景知识</span></a></h2><p>3.1　Hex-Rays公司的反盗版策略</p><p>3.2　获取IDA Pro</p><p>3.3　IDA 支持资源</p><p>3.4　安装IDA</p><p>3.5　IDA 用户界面</p><p>3.6　小结</p><h2 id="第二部分-ida基本用法" tabindex="-1"><a class="header-anchor" href="#第二部分-ida基本用法"><span>第二部分　IDA基本用法</span></a></h2><p>第4章　IDA入门</p><p>4.1　启动IDA</p><p>4.2　IDA 数据库文件</p><p>4.3　IDA 桌面简介</p><p>4.4　初始分析时的桌面行为</p><p>4.5　IDA 桌面提示和技巧</p><p>4.6　报告bug</p><p>4.7　小结</p><h2 id="第5章-ida-数据显示窗口" tabindex="-1"><a class="header-anchor" href="#第5章-ida-数据显示窗口"><span>第5章　IDA 数据显示窗口</span></a></h2><p>5.1　IDA 主要的数据显示窗口</p><p>5.2　次要的IDA 显示窗口</p><p>5.3　其他IDA 显示窗口</p><p>5.4　小结</p><h2 id="第6章-反汇编导航" tabindex="-1"><a class="header-anchor" href="#第6章-反汇编导航"><span>第6章　反汇编导航</span></a></h2><p>6.1　基本IDA 导航</p><p>6.2　栈帧</p><p>6.3　搜索数据库</p><p>6.4　小结</p><p>第7章　反汇编操作</p><p>7.1　名称与命名</p><p>7.2　IDA 中的注释</p><p>7.3　基本代码转换</p><p>7.4　基本数据转换</p><p>7.5　小结</p><p>第8章　数据类型与数据结构</p><p>8.1　识别数据结构的用法</p><p>8.2　创建IDA 结构体</p><p>8.3　使用结构体模板</p><p>8.4　导入新的结构体</p><p>8.5　使用标准结构体</p><p>8.6　IDA TIL 文件</p><p>8.7　C++ 逆向工程基础</p><p>8.8　小结</p><p>第9章　交叉引用与绘图功能</p><p>9.1　交叉引用</p><p>9.2　IDA 绘图</p><p>9.3　小结</p><p>第10章　IDA的多种面孔</p><p>10.1　控制台模式IDA</p><p>10.2　使用IDA 的批量模式</p><p>10.3　小结</p><p>第三部分　IDA高级应用</p><p>第11章　定制IDA</p><p>11.1　配置文件</p><p>11.2　其他IDA 配置选项</p><p>11.3　小结</p><p>第12章　使用FLIRT 签名来识别库</p><p>12.1　快速库识别和鉴定技术</p><p>12.2　应用FLIRT 签名</p><p>12.3　创建FLIRT 签名文件</p><p>12.4　小结</p><p>第13章　扩展IDA 的知识</p><p>13.1　扩充函数信息</p><p>13.2　使用loadint 扩充预定义注释</p><p>13.3　小结</p><p>第14章　修补二进制文件及其他IDA 限制</p><p>14.1　隐藏的补丁程序菜单</p><p>14.2　IDA 输出文件与补丁生成</p><p>14.3　小结</p><p>第四部分　扩展IDA的功能</p><p>第15章　编写IDA 脚本</p><p>15.1　执行脚本的基础知识</p><p>15.2　IDC 语言</p><p>15.3　关联IDC 脚本与热键</p><p>15.4　有用的IDC 函数</p><p>15.5　IDC 脚本示例</p><p>15.6　IDAPython</p><p>15.7　IDAPython 脚本示例</p><p>15.8　小结</p><p>第16章　IDA 软件开发工具包</p><p>16.1　SDK简介</p><p>16.2　IDA 应用编程接口</p><p>16.3　小结</p><p>第17章　IDA 插件体系结构</p><p>17.1　编写插件</p><p>17.2　构建插件</p><p>17.3　插件安装</p><p>17.4　插件配置</p><p>17.5　扩展IDC</p><p>17.6　插件用户界面选项</p><p>17.7　脚本化插件</p><p>17.8　小结</p><p>第18章　二进制文件与 IDA 加载器模块</p><p>18.1　未知文件分析</p><p>18.2　手动加载一个Windows PE文件</p><p>18.3　IDA 加载器模块</p><p>18.4　使用SDK编写IDA 加载器</p><p>18.5　其他加载器策略</p><p>18.6　编写脚本化加载器</p><p>18.7　小结</p><p>第19章　IDA 处理器模块</p><p>19.1　Python字节码</p><p>19.2　Python解释器</p><p>19.3　使用SDK编写处理器模块</p><p>19.4　构建处理器模块</p><p>19.5　定制现有的处理器</p><p>19.6　处理器模块体系结构</p><p>19.7　编写处理器模块</p><p>19.8　小结</p><p>第五部分　实际应用</p><p>第20章　编译器变体</p><p>20.1　跳转表与分支语句</p><p>20.2　RTTI实现</p><p>20.3　定位main函数</p><p>20.4　调试版与发行版二进制文件</p><p>20.5　其他调用约定</p><p>20.6　小结</p><p>第21章　模糊代码分析</p><p>21.1　反静态分析技巧</p><p>21.2　反动态分析技巧</p><p>21.3　使用IDA 对二进制文件进行“静态去模糊”</p><p>21.4　基于虚拟机的模糊</p><p>21.5　小结</p><p>第22章　漏洞分析</p><p>22.1　使用IDA 发现新的漏洞</p><p>22.2　使用IDA 在事后发现漏洞</p><p>22.3　IDA 与破解程序开发过程</p><p>22.4　分析shellcode</p><p>22.5　小结</p><p>第23章　实用IDA 插件</p><p>23.1　 Hex-Rays</p><p>23.2　IDAPython</p><p>23.3　collabREate</p><p>23.4　ida-x86emu</p><p>23.5　Class Informer</p><p>23.6　MyNav</p><p>23.7　IdaPdf</p><p>23.8　小结</p><p>第六部分　IDA调试器</p><p>第24章　IDA 调试器</p><p>24.1　启动调试器</p><p>24.2　调试器的基本显示</p><p>24.3　进程控制</p><p>24.4　调试器任务自动化</p><p>24.5　小结</p><p>第25章　反汇编器/ 调试器集成</p><p>25.1　背景知识</p><p>25.2　IDA 数据库与IDA 调试器</p><p>25.3　调试模糊代码</p><p>25.4　IDAStealth</p><p>25.5　处理异常</p><p>25.6　小结</p><p>第26章　其他调试功能</p><p>26.1　使用IDA 进行远程调试</p><p>26.2　使用Bochs 进行调试</p><p>26.3　Appcall</p><p>26.4　小结</p><p>附录A　使用IDA 免费版本5.0</p><p>A.1　IDA 免费版本的限制</p><p>A.2　使用IDA 免费版本</p><p>附录B　IDC/SDK交叉引用</p><p></p>',191)]))}const o=a(i,[["render",r],["__file","learn-ida.html.vue"]]),c=JSON.parse('{"path":"/public-articles/learn-ida.html","title":"Learn IDA","lang":"zh-CN","frontmatter":{"description":"Learn IDA 第一部分 IDA简介 第1章 反汇编简介 1.1 反汇编理论 1.2 何为反汇编 在传统的软件开发模型中，程序员使用编译器、汇编器和链接器中的一个或几个创建可执行程序。 为了回溯编程过程（或对程序进行逆向工程），我们使用各种工具来撤销汇编和编译过程。毫不奇怪，这些工具就叫做反汇编器 和反编译器 ，名副其实。 反汇编器撤销汇编过程，因...","head":[["meta",{"property":"og:url","content":"https://github.com/biezhihua/public-articles/learn-ida.html"}],["meta",{"property":"og:site_name","content":"biezhihua的日常"}],["meta",{"property":"og:title","content":"Learn IDA"}],["meta",{"property":"og:description","content":"Learn IDA 第一部分 IDA简介 第1章 反汇编简介 1.1 反汇编理论 1.2 何为反汇编 在传统的软件开发模型中，程序员使用编译器、汇编器和链接器中的一个或几个创建可执行程序。 为了回溯编程过程（或对程序进行逆向工程），我们使用各种工具来撤销汇编和编译过程。毫不奇怪，这些工具就叫做反汇编器 和反编译器 ，名副其实。 反汇编器撤销汇编过程，因..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-08T14:25:34.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-08T14:25:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Learn IDA\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-08T14:25:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"别志华\\",\\"url\\":\\"https://github.com/biezhihua\\"}]}"]]},"git":{"createdTime":1710486796000,"updatedTime":1741443934000,"contributors":[{"name":"biezhihua","username":"biezhihua","email":"biezhihua@gmail.com","commits":2,"url":"https://github.com/biezhihua"}]},"readingTime":{"minutes":6.91,"words":2074},"filePathRelative":"public-articles/learn-ida.md","localizedDate":"2024年3月15日","excerpt":"","autoDesc":true}');export{o as comp,c as data};
