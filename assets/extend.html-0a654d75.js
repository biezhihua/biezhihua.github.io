import{_ as c,C as i,Y as t,Z as d,$ as n,a0 as e,a1 as a,a2 as o}from"./framework-301d0703.js";const l={},p=o(`<h1 id="android-aosp-知识扩展" tabindex="-1"><a class="header-anchor" href="#android-aosp-知识扩展" aria-hidden="true">#</a> Android | AOSP | 知识扩展</h1><h2 id="td-optional" tabindex="-1"><a class="header-anchor" href="#td-optional" aria-hidden="true">#</a> td::optional</h2><p><code>std::optional</code> 是 C++17 中引入的一种容器，用于表示一个可能不存在的对象。其类模板的定义如下：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>template &lt;typename T&gt;
class optional {
public:
    optional(); // 构造函数，创建一个空的 optional 对象
    optional(const T&amp; value); // 构造函数，创建一个存放了 value 值的 optional 对象
    optional&amp; operator=(const T&amp; value); // 赋值运算符，将 value 赋值给 optional 对象
    T&amp; operator*(); // 返回存储在 optional 对象中的值的引用
    const T&amp; operator*() const; // 返回存储在 optional 对象中的值的 const 引用
    T* operator-&gt;(); // 返回存储在 optional 对象中的值的指针
    const T* operator-&gt;() const; // 返回存储在 optional 对象中的值的 const 指针
    explicit operator bool() const; // 检查 optional 对象是否包含一个值
    T&amp; value(); // 返回存储在 optional 对象中的值的引用，如果对象为空则抛出 std::bad_optional_access 异常
    const T&amp; value() const; // 返回存储在 optional 对象中的值的 const 引用，如果对象为空则抛出 std::bad_optional_access 异常
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>std::optional</code> 可以用来避免在代码中使用空指针或无效引用，从而降低代码出错的可能性。在某些情况下，我们需要一个变量可能存在或不存在，这时就可以使用 <code>std::optional</code> 来表示这种可能性。例如：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>std::optional&lt;int&gt; num; // 创建一个空的 optional 对象
num = 42; // 将 42 赋值给 optional 对象
if (num) { // 检查 optional 对象是否包含一个值
    std::cout &lt;&lt; &quot;num is &quot; &lt;&lt; *num &lt;&lt; std::endl; // 访问存储在 optional 对象中的值
} else {
    std::cout &lt;&lt; &quot;num is not set&quot; &lt;&lt; std::endl;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们使用 <code>std::optional</code> 来表示一个整数变量可能存在或不存在的情况。如果 optional 对象包含一个值，则通过解引用操作符 <code>*</code> 来访问该值。否则，我们可以通过检查对象是否包含值来避免访问未定义的内存。</p><h2 id="std-optional-中-emplace" tabindex="-1"><a class="header-anchor" href="#std-optional-中-emplace" aria-hidden="true">#</a> std::optional 中 emplace</h2><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>template &lt;class... _Args,
            class = enable_if_t
                    &lt;
                        is_constructible_v&lt;value_type, _Args...&gt;
                    &gt;
            &gt;
_LIBCPP_INLINE_VISIBILITY
_Tp &amp;
emplace(_Args&amp;&amp;... __args)
{
    reset();
    this-&gt;__construct(_VSTD::forward&lt;_Args&gt;(__args)...);
    return this-&gt;__get();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码是<code>std::optional</code>中<code>emplace</code>成员函数的模板实现。<code>emplace</code>函数的主要作用是在<code>std::optional</code>对象中构造一个新的值，使用传入的参数作为构造函数的参数。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 定义emplace成员函数模板</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> _Args<span class="token punctuation">,</span>
          <span class="token keyword">class</span> <span class="token operator">=</span> enable_if_t
                  <span class="token operator">&lt;</span>
                      is_constructible_v<span class="token operator">&lt;</span>value_type<span class="token punctuation">,</span> _Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span>
                  <span class="token operator">&gt;</span>
         <span class="token operator">&gt;</span>
<span class="token comment">// 设置内联可见性，使得编译器可以在编译时优化函数调用</span>
_LIBCPP_INLINE_VISIBILITY
<span class="token comment">// 定义emplace函数，返回值类型为模板参数_Tp的引用，接受可变数量的模板参数_Args</span>
_Tp <span class="token operator">&amp;</span>
<span class="token function">emplace</span><span class="token punctuation">(</span>_Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> __args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 调用reset()函数，清除optional对象当前的值，为新值做好准备</span>
    <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用完美转发将传入的参数列表(__args)转发给构造函数</span>
    <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">__construct</span><span class="token punctuation">(</span>_VSTD<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>_Args<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>__args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回新构造值的引用</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">__get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>emplace</code>函数首先调用<code>reset()</code>方法清除<code>std::optional</code>对象中的当前值。接下来，使用完美转发将传入的参数列表(<code>__args</code>)转发给<code>value_type</code>的构造函数，<code>value_type</code>是存储在<code>std::optional</code>中的类型。最后，返回新构造值的引用。</p>`,12),r={href:"https://cs.android.com/android/platform/superproject/+/refs/heads/master:external/libcxx/include/optional;drc=7346c436e5a11ce08f6a80dcfeb8ef941ca30176;bpv=0;bpt=1;l=820?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},u=o(`<h2 id="sys-nanosleep" tabindex="-1"><a class="header-anchor" href="#sys-nanosleep" aria-hidden="true">#</a> sys_nanosleep</h2><p><code>sys_nanosleep</code>是一个操作系统内核系统调用，它用于暂停当前进程一段指定的时间。在Linux系统中，这个系统调用的原型如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">sys_nanosleep</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>req<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>rem<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个参数<code>req</code>是一个指向<code>timespec</code>结构体的指针，表示要暂停的时间长度。该结构体包含两个成员变量，分别为<code>tv_sec</code>和<code>tv_nsec</code>，分别表示秒数和纳秒数。第二个参数<code>rem</code>是一个指向<code>timespec</code>结构体的指针，表示剩余未暂停的时间长度。如果在暂停的过程中被信号打断，那么<code>rem</code>将会被设置为剩余未暂停的时间。</p><p><code>sys_nanosleep</code>的返回值为0表示暂停成功，返回-1表示暂停失败，错误码保存在<code>errno</code>中。</p><h2 id="sys-ioctl" tabindex="-1"><a class="header-anchor" href="#sys-ioctl" aria-hidden="true">#</a> sys_ioctl</h2><p><code>sys_ioctl</code>是一个操作系统内核系统调用，用于操作设备文件的I/O控制。在Linux系统中，这个系统调用的原型如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ioctl.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">sys_ioctl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个参数<code>fd</code>是一个整数类型，表示要进行I/O控制的设备文件描述符。第二个参数<code>cmd</code>是一个无符号整数类型，表示要进行的I/O操作，通常是一个预定义的常量。第三个参数<code>arg</code>是一个无符号长整型，表示I/O操作的参数，可以是一个指针或一个整数。</p><p>不同的设备文件可能支持不同的I/O操作，因此<code>cmd</code>参数的含义也不同。例如，对于网络设备文件，可能有<code>SIOCGIFADDR</code>操作，用于获取设备的IP地址；对于串口设备文件，可能有<code>TCGETS</code>操作，用于获取串口的配置信息。</p><p><code>sys_ioctl</code>的返回值为0表示I/O操作成功，返回-1表示I/O操作失败，错误码保存在<code>errno</code>中。</p><h2 id="android-init-脚本" tabindex="-1"><a class="header-anchor" href="#android-init-脚本" aria-hidden="true">#</a> Android init 脚本</h2><p>Android init 脚本是一种 Android 系统启动时用于配置和启动各种服务、设置属性和创建目录等操作的脚本。它们主要用于定义系统的启动流程和配置各种组件。这些脚本通常位于 Android 源码中的各个子项目和设备特定代码中，如 <code>system/core/rootdir</code>、<code>device/&lt;manufacturer&gt;/&lt;device&gt;/rootdir</code> 等。</p><p>Android init 脚本的作用包括：</p><ol><li>设置系统属性：用于配置系统行为、开关和设备特性等。</li><li>创建目录和文件：用于在启动过程中创建必要的目录结构和文件。</li><li>设置权限：用于设定系统目录和文件的访问权限，以确保正确的访问控制。</li><li>启动服务：用于配置和启动系统中的各种守护进程和服务。</li></ol><p>Android init 脚本使用一种名为 <code>init</code> 的简单语言编写，该语言包含一系列命令和关键字，用于表示不同的操作。例如：</p><ul><li><code>service</code>：定义一个服务，包括服务名、可执行文件路径和相关参数。</li><li><code>on</code>：定义在特定事件触发时要执行的操作。</li><li><code>setprop</code>：设置系统属性。</li><li><code>mkdir</code>：创建目录。</li><li><code>chmod</code>：更改文件或目录权限。</li></ul><p>要使用 Android init 脚本，您需要：</p><ol><li>在 Android 源码中找到相关的 init 脚本，如 <code>init.rc</code>、<code>init.&lt;device&gt;.rc</code> 或设备特定的 init 脚本。</li><li>阅读和理解脚本中的命令和关键字，以及它们在系统启动过程中的作用。</li><li>修改或添加 init 脚本中的命令和关键字，以满足您的需求。</li><li>编译并刷入新的 Android 系统映像，然后观察更改后的系统行为。</li></ol>`,19),m={href:"https://android.googlesource.com/platform/system/core/+/master/init/README.md",target:"_blank",rel:"noopener noreferrer"},v={href:"https://cs.android.com/android/platform/superproject/+/master:frameworks/native/services/surfaceflinger/Android.bp?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},k=o('<h2 id="android-bp的作用" tabindex="-1"><a class="header-anchor" href="#android-bp的作用" aria-hidden="true">#</a> Android.bp的作用</h2><p><code>Android.bp</code> 是 Android 开源项目 (AOSP) 中的一种构建脚本，它使用类似 Makefile 的语法来描述如何构建 Android 应用程序、库和模块。它是 AOSP 中使用的 Soong 构建系统的核心组件之一，是 Android 7.0 及更高版本中用于构建的主要构建系统。</p><p><code>Android.bp</code> 文件中描述了一个模块的依赖关系、编译选项、源代码文件列表等信息，构建系统将基于这些信息来生成构建脚本和构建产物。相比于之前使用的 GNU Make 工具链，Soong 构建系统更加灵活、可扩展和高效，能够更好地支持 Android 平台的复杂构建需求。</p><p>在 Android 源代码中，每个模块都有一个相应的 <code>Android.bp</code> 文件，用于描述该模块的构建规则。这些模块包括 Android 系统本身、应用程序、共享库、静态库、插件等。开发者可以修改这些 <code>Android.bp</code> 文件来增加、删除或修改模块的构建规则，以满足自己的需求。</p><p>总之，<code>Android.bp</code> 文件是 AOSP 中描述如何构建 Android 应用程序、库和模块的核心文件，它是 Soong 构建系统的核心组件之一。</p><h2 id="emplace" tabindex="-1"><a class="header-anchor" href="#emplace" aria-hidden="true">#</a> emplace</h2>',6),g={href:"https://en.cppreference.com/w/cpp/utility/optional/emplace",target:"_blank",rel:"noopener noreferrer"},b=n("h2",{id:"emplace-back",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#emplace-back","aria-hidden":"true"},"#"),e(" emplace_back")],-1),_={href:"https://en.cppreference.com/w/cpp/container/vector/emplace_back",target:"_blank",rel:"noopener noreferrer"},h=o('<h2 id="surfaceflinger" tabindex="-1"><a class="header-anchor" href="#surfaceflinger" aria-hidden="true">#</a> surfaceflinger</h2><p>service surfaceflinger /system/bin/surfaceflinger class core animation user system group graphics drmrpc readproc capabilities SYS_NICE onrestart restart --only-if-running zygote task_profiles HighPerformance socket pdx/system/vr/display/client stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0 socket pdx/system/vr/display/manager stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0 socket pdx/system/vr/display/vsync stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0</p><p><code>surfaceflinger.rc</code> 是一个 Android init 脚本，用于定义 SurfaceFlinger 服务的配置。SurfaceFlinger 是 Android 系统的核心组件，负责合成和显示图形。该文件定义了 SurfaceFlinger 服务的启动方式和权限。现在让我们分析文件的每一行内容：</p><ol><li><p><code>service surfaceflinger /system/bin/surfaceflinger</code>定义一个名为 &quot;surfaceflinger&quot; 的服务，它的可执行文件位于 <code>/system/bin/surfaceflinger</code>。</p></li><li><p><code>class core animation</code>将 SurfaceFlinger 服务分配到 &quot;core&quot; 和 &quot;animation&quot; 类别。这些类别用于在特定条件下控制服务的启动和关闭。</p></li><li><p><code>user system</code>设置 SurfaceFlinger 服务运行在 &quot;system&quot; 用户上下文中。</p></li><li><p><code>group graphics drmrpc readproc</code>将 SurfaceFlinger 服务的组设置为 &quot;graphics&quot;、&quot;drmrpc&quot; 和 &quot;readproc&quot;。这些组定义了服务的权限。</p></li><li><p><code>capabilities SYS_NICE</code>赋予 SurfaceFlinger 服务 SYS_NICE 功能。这允许服务更改其调度优先级，以便在需要时获得更多 CPU 时间。</p></li><li><p><code>onrestart restart --only-if-running zygote</code>如果 SurfaceFlinger 服务重启，该行命令会尝试重启名为 &quot;zygote&quot; 的服务。<code>--only-if-running</code> 参数确保仅在 &quot;zygote&quot; 服务已运行时执行重启操作。</p></li><li><p><code>task_profiles HighPerformance</code>为 SurfaceFlinger 服务分配 &quot;HighPerformance&quot; 任务配置文件。这可能会调整服务的性能参数。</p></li></ol><p>8-10. <code>socket pdx/...</code>这三行定义了 SurfaceFlinger 服务用于与客户端通信的 UNIX 域套接字。套接字的权限、所有者和安全上下文在这些行中定义。</p><p>总之，<code>surfaceflinger.rc</code> 文件定义了 SurfaceFlinger 服务的启动配置、权限和通信方式。这个文件在 Android 系统启动时被 init 进程读取，用于正确地启动和运行 SurfaceFlinger 服务。</p>',6);function f(y,A){const s=i("ExternalLinkIcon");return t(),d("div",null,[p,n("ul",null,[n("li",null,[n("a",r,[e("https://cs.android.com/android/platform/superproject/+/refs/heads/master:external/libcxx/include/optional;drc=7346c436e5a11ce08f6a80dcfeb8ef941ca30176;bpv=0;bpt=1;l=820?hl=zh-cn"),a(s)])])]),u,n("ul",null,[n("li",null,[n("p",null,[n("a",m,[e("https://android.googlesource.com/platform/system/core/+/master/init/README.md"),a(s)])])]),n("li",null,[n("p",null,[n("a",v,[e("https://cs.android.com/android/platform/superproject/+/master:frameworks/native/services/surfaceflinger/Android.bp?hl=zh-cn"),a(s)])])])]),k,n("p",null,[n("a",g,[e("https://en.cppreference.com/w/cpp/utility/optional/emplace"),a(s)])]),b,n("p",null,[n("a",_,[e("https://en.cppreference.com/w/cpp/container/vector/emplace_back"),a(s)])]),h])}const S=c(l,[["render",f],["__file","extend.html.vue"]]);export{S as default};
