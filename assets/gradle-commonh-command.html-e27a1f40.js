import{_ as e,Y as o,Z as d,a2 as i}from"./framework-301d0703.js";const a={},c=i('<h1 id="gralde-common-command" tabindex="-1"><a class="header-anchor" href="#gralde-common-command" aria-hidden="true">#</a> Gralde Common Command</h1><p>在 Gradle 中，用于依赖管理的关键字有几个，主要用于配置项目中库的依赖关系。随着 Gradle 版本的更新，某些术语已经被新的替换或者有了更加明确的用途。以下是一些常用的依赖配置关键字及其作用：</p><h3 id="_1-compile-已废弃" tabindex="-1"><a class="header-anchor" href="#_1-compile-已废弃" aria-hidden="true">#</a> 1. <code>compile</code> (已废弃)</h3><ul><li><strong>用途</strong>：<code>compile</code> 是旧版 Gradle 中用来添加库依赖的。被依赖的库会参与到编译、运行时的类路径中。</li><li><strong>问题</strong>：它不区分编译时和运行时依赖，所有依赖都会被打包进最终构建的 APK 或 JAR 中，可能导致不必要的库膨胀。</li></ul><h3 id="_2-api-替代-compile" tabindex="-1"><a class="header-anchor" href="#_2-api-替代-compile" aria-hidden="true">#</a> 2. <code>api</code> (替代 <code>compile</code>)</h3><ul><li><strong>用途</strong>：在 Android Gradle 插件 3.0 以上使用。当你的库在公共 API 中暴露了其他模块的类型时使用。依赖传递给消费者。</li><li><strong>特点</strong>：对于库模块，如果一个依赖是通过 <code>api</code> 配置的，那么这个依赖会出现在库的使用者的编译路径上。</li></ul><h3 id="_3-implementation-替代-compile" tabindex="-1"><a class="header-anchor" href="#_3-implementation-替代-compile" aria-hidden="true">#</a> 3. <code>implementation</code> (替代 <code>compile</code>)</h3><ul><li><strong>用途</strong>：推荐用来替换 <code>compile</code>。它只会将库包含在编译类路径中，不会暴露给消费者。</li><li><strong>特点</strong>：这意味着使用 <code>implementation</code> 声明的依赖不会被传递给依赖项的消费者。这有助于减少模块间的耦合，并可能减少编译时间。</li></ul><h3 id="_4-compileonly-类似于-maven-的-provided" tabindex="-1"><a class="header-anchor" href="#_4-compileonly-类似于-maven-的-provided" aria-hidden="true">#</a> 4. <code>compileOnly</code> (类似于 Maven 的 <code>provided</code>)</h3><ul><li><strong>用途</strong>：只在编译时有效，运行时无效。适用于只需要在编译时期参与编译的库，比如注解处理器。</li><li><strong>特点</strong>：运行时需要保证这些依赖由环境提供，常用于插件或容器提供的 API。</li></ul><h3 id="_5-providedcompile-已废弃" tabindex="-1"><a class="header-anchor" href="#_5-providedcompile-已废弃" aria-hidden="true">#</a> 5. <code>providedCompile</code> (已废弃)</h3><ul><li><strong>用途</strong>：旧版 Gradle 中的用法，类似于 <code>compileOnly</code>，用于指定编译时需要，但不打包到最终产物中的依赖。</li><li><strong>问题</strong>：随着 Gradle 版本的升级，通常被 <code>compileOnly</code> 替代。</li></ul><h3 id="_6-provided-已废弃" tabindex="-1"><a class="header-anchor" href="#_6-provided-已废弃" aria-hidden="true">#</a> 6. <code>provided</code> (已废弃)</h3><ul><li><strong>用途</strong>：类似于 <code>providedCompile</code>，旧的依赖管理方式，现在通常使用 <code>compileOnly</code>。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结：</h3><ul><li>使用 <code>api</code> 和 <code>implementation</code> 来替代老的 <code>compile</code>，具体选择取决于是否想将依赖的库暴露给消费者。</li><li>使用 <code>compileOnly</code> 替代 <code>providedCompile</code> 和 <code>provided</code>，用于那些仅在编译时需要而运行时由执行环境提供的库。</li></ul>',16),l=[c];function r(n,t){return o(),d("div",null,l)}const h=e(a,[["render",r],["__file","gradle-commonh-command.html.vue"]]);export{h as default};
