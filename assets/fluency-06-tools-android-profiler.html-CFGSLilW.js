import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as a,f as o,o as i}from"./app-D4ZtVCQo.js";const l="/learn-android/performance/fluency-tools-android-cpu-profiler-traces.png",t="/learn-android/performance/fluency-tools-android-cpu-profiler-system-trace-record.png",n="/learn-android/performance/fluency-tools-android-cpu-profiler-java-kotlin-method-trace.png",p="/learn-android/performance/fluency-tools-android-cpu-profiler-callstack-sample-record.png",d={};function c(s,e){return i(),a("div",null,e[0]||(e[0]=[o('<h1 id="android-性能优化-流畅性-第06篇-性能分析工具-android-cpu-profiler" tabindex="-1"><a class="header-anchor" href="#android-性能优化-流畅性-第06篇-性能分析工具-android-cpu-profiler"><span>Android | 性能优化 | 流畅性 - 第06篇 - 性能分析工具 - Android CPU Profiler</span></a></h1><h2 id="android-cpu-profiler-介绍" tabindex="-1"><a class="header-anchor" href="#android-cpu-profiler-介绍"><span>Android CPU Profiler 介绍</span></a></h2><p>Android Profiler 是 Android Studio 内置的一个性能分析工具，用于监控和分析应用的性能。在 CPU 分析器中，有三种主要的跟踪类型：Callstack Sample、System Trace 和 Java/Kotlin Method Trace。</p><p>Callstack Sample 适用于快速定位性能瓶颈，System Trace 适用于分析应用程序与系统的交互，而 Java/Kotlin Method Trace 适用于深入分析代码中的性能问题。通过使用这些工具，可以更有效地发现并解决应用程序中的性能问题。</p><p>下面介绍这三种跟踪类型的使用场景和实现原理以及优缺点。</p><p><img src="'+l+'" alt="fluency-tools-android-cpu-profiler-traces"></p><h3 id="callstack-sample" tabindex="-1"><a class="header-anchor" href="#callstack-sample"><span>Callstack Sample</span></a></h3><p>使用场景：</p><ul><li>Callstack Sample 适用于分析应用程序中可能存在的性能瓶颈。它会提供Java和Native方法的调用堆栈的采样，帮助你找到可能导致性能问题的函数。</li></ul><p>实现原理：</p><ul><li>Callstack Sample 它使用 Simpleperf 采样 Java/Kotlin 和 Native 代码，通过周期性地获取应用程序的调用堆栈来分析应用程序的性能。它不会记录所有方法的调用信息，而是在指定的时间间隔内捕获调用堆栈的快照。通过这些快照，可以确定应用程序的性能瓶颈所在。</li></ul><p>优缺点：</p><ul><li>优点： <ul><li>低开销：由于采样的方式，Callstack Sample 对应用程序性能的影响较小，可以在实际运行过程中进行性能分析。</li><li>快速定位：可以迅速发现 CPU 使用率高的线程和函数，便于快速定位性能瓶颈。</li></ul></li><li>缺点： <ul><li>不够精确：采样的方式可能导致一些较短时间执行的方法被忽略，从而无法发现所有的性能问题。</li><li>难以发现具体问题：仅提供了方法调用栈的概览，可能难以找到具体的性能问题。</li></ul></li></ul><h3 id="system-trace" tabindex="-1"><a class="header-anchor" href="#system-trace"><span>System Trace</span></a></h3><p>使用场景：</p><ul><li>System Trace 适用于分析应用程序与操作系统之间的交互，以及与其他应用程序或系统组件之间的交互。System Trace 可以帮助你理解应用程序在系统范围内的性能表现，例如 CPU 调度、线程同步和其他系统级事件。</li></ul><p>实现原理：</p><ul><li>System Trace 使用 Android 操作系统内置的跟踪工具 (如 Systrace 或 Perfetto) 收集操作系统级别的事件数据。这些工具可以捕获详细的系统事件，包括 CPU 调度、线程状态变化、锁争用、内存分配等。通过分析这些事件，可以了解应用程序与系统资源的交互情况，从而找到性能瓶颈。</li></ul><p>优缺点：</p><ul><li>优点： <ul><li>系统级信息：可以捕获操作系统级别的详细事件数据，帮助你了解应用程序与系统资源的交互情况。</li><li>多方面分析：可以分析 CPU 调度、线程同步、内存分配等多方面的性能问题。</li></ul></li><li>缺点： <ul><li>开销较大：由于收集的数据量较大，可能会对应用程序的性能产生一定影响。</li><li>分析复杂：由于涉及系统级事件，分析 System Trace 可能需要更深入的操作系统知识。</li></ul></li></ul><h3 id="java-kotlin-method-trace" tabindex="-1"><a class="header-anchor" href="#java-kotlin-method-trace"><span>Java/Kotlin Method Trace</span></a></h3><p>使用场景：</p><ul><li>Java/Kotlin Method Trace 适用于深入分析 Java 或 Kotlin 代码的性能问题。它可以帮助你了解代码中每个方法的执行时间和调用次数，从而发现潜在的性能问题。</li></ul><p>实现原理：</p><ul><li>Java/Kotlin Method Trace 通过在应用程序运行时记录每个方法的调用信息来分析性能。当你开始方法跟踪时，Android Profiler 会通知应用程序启用方法跟踪。之后，应用程序会在每次方法调用时记录相关信息，包括方法名称、开始时间、执行时间等。在跟踪结束后，Android Profiler 会收集这些数据并生成一个详细的方法调用报告，供你分析性能问题。</li></ul><p>优缺点：</p><ul><li>优点： <ul><li>详细信息：可以获取每个方法的执行时间和调用次数，有助于深入分析代码中的性能问题。</li><li>针对性强：专注于 Java/Kotlin 代码，使得在分析代码性能时更加针对性。</li></ul></li><li>缺点： <ul><li>开销较大：由于需要记录每个方法的调用信息，可能会对应用程序的性能产生较大影响。</li><li>可能不全面：仅针对 Java/Kotlin 代码，可能无法发现底层系统或原生代码中的性能问题。</li></ul></li></ul><h2 id="android-cpu-profiler-实践中的应用" tabindex="-1"><a class="header-anchor" href="#android-cpu-profiler-实践中的应用"><span>Android CPU Profiler 实践中的应用</span></a></h2><p>Android CPU Profiler 在这些场景中要如何使用呢？基本的思路是：</p><ul><li>先录制 System Trace，利用 Trace Points 初步分析、定位问题。</li><li>再借助 Java/Kotlin Method Trace 分析 Java 层代码的问题。</li><li>再借助 Callstack Sample Trace 分析 Native 层代码的问题。</li></ul><p>Android CPU Profiler 最大优势是集成了各种子工具，在一个地方就能操作一切，对应用开发者来说是非常方便的，下面通过一个简单的案例来看一下Android CPU Profiler中的各个模式是如何配合的。</p><p>当碰到性能问题时，先通过 Android CPU Profiler 录制一个 System Trace 如下：</p><p><img src="'+t+'" alt="fluency-tools-android-cpu-profiler-system-trace-record"></p><p>通过上面 Trace 可以知道是在主线程中的 doFrame内的View#draw() 操作耗时，如果发现不了问题，建议导出到 <a href="https://ui.perfetto.dev/" target="_blank" rel="noopener noreferrer">https://ui.perfetto.dev/</a> 进一步分析，通过查找发现是 View#draw() 方法内的名为 LowView-onDraw 的 Java方法耗时。</p><p>要分析 Java/Kotlin 函数耗时情况，我们要录制一个 Java/Kotlin Method Trace，如下：</p><p><img src="'+n+'" alt="fluency-tools-android-cpu-profiler-java-kotlin-method-trace"></p><p>通过上面 Trace 很容易发现是一个叫做 Utils.stringFromJNI 的 native 函数耗时，因为涉及到C/C++ 代码，所以要再录制一个 Callstack Sample Trace 进一步分析，如下：</p><p><img src="'+p+'" alt="fluency-tools-android-cpu-profiler-callstack-sample-record"></p><p>可以发现在 native 的 Java_com_example_myapplication_Utils_stringFromJNI 中代码执行了 sleep，它就是导致了性能问题的原因。</p><h2 id="引用" tabindex="-1"><a class="header-anchor" href="#引用"><span>引用</span></a></h2><ul><li><a href="https://www.androidperformance.com/2022/01/07/The-Performace-1-Performance-Tools" target="_blank" rel="noopener noreferrer">https://www.androidperformance.com/2022/01/07/The-Performace-1-Performance-Tools</a></li></ul><h2 id="版权声明" tabindex="-1"><a class="header-anchor" href="#版权声明"><span>版权声明</span></a></h2><p>本文采用<a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener noreferrer">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>',43)]))}const f=r(d,[["render",c],["__file","fluency-06-tools-android-profiler.html.vue"]]),u=JSON.parse('{"path":"/learn-android/performance/fluency-06-tools-android-profiler.html","title":"Android | 性能优化 | 流畅性 - 第06篇 - 性能分析工具 - Android CPU Profiler","lang":"zh-CN","frontmatter":{"tag":["android","performance","fluency"],"description":"Android | 性能优化 | 流畅性 - 第06篇 - 性能分析工具 - Android CPU Profiler Android CPU Profiler 介绍 Android Profiler 是 Android Studio 内置的一个性能分析工具，用于监控和分析应用的性能。在 CPU 分析器中，有三种主要的跟踪类型：Callstack Sa...","head":[["meta",{"property":"og:url","content":"https://github.com/biezhihua/learn-android/performance/fluency-06-tools-android-profiler.html"}],["meta",{"property":"og:site_name","content":"biezhihua的日常"}],["meta",{"property":"og:title","content":"Android | 性能优化 | 流畅性 - 第06篇 - 性能分析工具 - Android CPU Profiler"}],["meta",{"property":"og:description","content":"Android | 性能优化 | 流畅性 - 第06篇 - 性能分析工具 - Android CPU Profiler Android CPU Profiler 介绍 Android Profiler 是 Android Studio 内置的一个性能分析工具，用于监控和分析应用的性能。在 CPU 分析器中，有三种主要的跟踪类型：Callstack Sa..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://github.com/biezhihua/learn-android/performance/fluency-tools-android-cpu-profiler-traces.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-08T14:25:34.000Z"}],["meta",{"property":"article:tag","content":"android"}],["meta",{"property":"article:tag","content":"performance"}],["meta",{"property":"article:tag","content":"fluency"}],["meta",{"property":"article:modified_time","content":"2025-03-08T14:25:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Android | 性能优化 | 流畅性 - 第06篇 - 性能分析工具 - Android CPU Profiler\\",\\"image\\":[\\"https://github.com/biezhihua/learn-android/performance/fluency-tools-android-cpu-profiler-traces.png\\",\\"https://github.com/biezhihua/learn-android/performance/fluency-tools-android-cpu-profiler-system-trace-record.png\\",\\"https://github.com/biezhihua/learn-android/performance/fluency-tools-android-cpu-profiler-java-kotlin-method-trace.png\\",\\"https://github.com/biezhihua/learn-android/performance/fluency-tools-android-cpu-profiler-callstack-sample-record.png\\"],\\"dateModified\\":\\"2025-03-08T14:25:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"别志华\\",\\"url\\":\\"https://github.com/biezhihua\\"}]}"]]},"git":{"createdTime":1679211791000,"updatedTime":1741443934000,"contributors":[{"name":"biezhihua","username":"biezhihua","email":"biezhihua@gmail.com","commits":9,"url":"https://github.com/biezhihua"}]},"readingTime":{"minutes":5.33,"words":1600},"filePathRelative":"learn-android/performance/fluency-06-tools-android-profiler.md","localizedDate":"2023年3月19日","excerpt":"","autoDesc":true}');export{f as comp,u as data};
