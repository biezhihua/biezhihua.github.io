import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as t,f as l,o as n}from"./app-CJwaQKG3.js";const r={};function a(o,e){return n(),t("div",null,e[0]||(e[0]=[l('<h1 id="x86-x64-汇编-有什么区别呢-那个是主流。" tabindex="-1"><a class="header-anchor" href="#x86-x64-汇编-有什么区别呢-那个是主流。"><span>x86/x64 汇编 有什么区别呢？ 那个是主流。</span></a></h1><p>在日常所说的「x86」和「x64」中，x86 通常指 32 位的处理器/指令集架构（全称可写作 x86_32），而 x64 则指 64 位的处理器/指令集架构（也称 x86_64 或 AMD64）。汇编层面上的区别，主要体现在寄存器的数量与宽度、函数调用约定、内存寻址等方面。以下是一些主要差异：</p><hr><h2 id="_1-寄存器数量与命名" tabindex="-1"><a class="header-anchor" href="#_1-寄存器数量与命名"><span>1. 寄存器数量与命名</span></a></h2><ul><li><p><strong>x86（32 位）</strong></p><ul><li>经典的通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP</li><li>每个寄存器的宽度都是 32 位，以 <code>E</code> 前缀表示 (Extended Register)。</li><li>例如：EAX 表示 32 位 AX；AX 低 16 位也可继续拆分成 AH、AL 等更小段。</li></ul></li><li><p><strong>x64（64 位）</strong></p><ul><li>保留了 x86 的 8 个通用寄存器，并额外增加了 8 个（R8 ~ R15），总共有 16 个可用的通用寄存器。</li><li>每个寄存器的宽度扩大到 64 位，以 <code>R</code> 前缀表示 (Register)。</li><li>例如：RAX 表示 64 位 A 寄存器；也可以访问 RAX 的低 32 位（EAX）、低 16 位（AX）以及 8 位（AH、AL）。</li></ul></li></ul><hr><h2 id="_2-函数调用约定-calling-convention" tabindex="-1"><a class="header-anchor" href="#_2-函数调用约定-calling-convention"><span>2. 函数调用约定（Calling Convention）</span></a></h2><ul><li><p><strong>x86</strong></p><ul><li>常见的调用约定有 cdecl、stdcall、fastcall、thiscall 等，不同编译器/平台可能默认不同。</li><li>一般来说，函数参数多采用「栈传递」，调用者或被调用者负责清理栈空间。</li></ul></li><li><p><strong>x64</strong></p><ul><li>在 64 位平台上，主流操作系统通常统一调用约定，让编译器之间更具兼容性。</li><li><strong>Windows 平台 (Microsoft x64 Calling Convention)</strong>：前四个整型/指针参数分别由寄存器 RCX、RDX、R8、R9 传递；额外的参数再压栈。</li><li><strong>Linux / macOS (System V AMD64 ABI)</strong>：前六个整型/指针参数通过 RDI、RSI、RDX、RCX、R8、R9 传递；额外的参数再压栈。</li><li>函数返回值则通过 RAX 或者 XMM0（浮点）等寄存器返回。</li></ul></li></ul><hr><h2 id="_3-地址空间与内存寻址" tabindex="-1"><a class="header-anchor" href="#_3-地址空间与内存寻址"><span>3. 地址空间与内存寻址</span></a></h2><ul><li><p><strong>x86</strong></p><ul><li>理论上最大可寻址内存为 4GB，寄存器/指针宽度 32 位。</li><li>对一些特别大的数据处理需求，可能需要额外的扩展（PAE 等），但整体内存空间受限。</li></ul></li><li><p><strong>x64</strong></p><ul><li>寄存器/指针宽度扩大至 64 位，理论上可寻址极其庞大的内存（当前实现多为 48 位物理寻址或更高）。</li><li>x64 程序可以更方便地进行大内存的运算、管理。</li></ul></li></ul><hr><h2 id="_4-指令集扩展" tabindex="-1"><a class="header-anchor" href="#_4-指令集扩展"><span>4. 指令集扩展</span></a></h2><ul><li>x86 汇编只保证最基本的 32 位指令集和部分 SSE 指令，需要额外检测 CPU 是否支持更高等级的 SSE/AVX 等扩展。</li><li>x64 则默认包含了更完整、更高版本的指令扩展（如 SSE2、SSE4.2 等）。在 64 位模式下，一些原 x86 的 “遗留” 指令可能被废弃或行为变化。</li></ul><hr><h2 id="_5-现今主流选择" tabindex="-1"><a class="header-anchor" href="#_5-现今主流选择"><span>5. 现今主流选择</span></a></h2><p>在个人电脑（PC）、服务器以及绝大多数桌面应用领域，<strong>x64（64 位）已是绝对主流</strong>。主要原因包括：</p><ol><li><strong>操作系统普遍 64 位化</strong>：主流操作系统（Windows、Linux、macOS 等）均提供 64 位内核与 64 位用户态支持，能够突破 32 位系统的内存限制。</li><li><strong>硬件演进</strong>：CPU 生产商（Intel、AMD）在新产品线上更多地聚焦 64 位处理器的优化，32 位处理器在消费级市场基本停产或只在特定场景保留。</li><li><strong>软件生态</strong>：绝大多数大型软件和游戏都已经转向 64 位，以支持更大内存、更高效的浮点/向量运算。</li><li><strong>兼容性</strong>：x64 仍能兼容运行许多 32 位软件（在 Windows 上借助 WoW64 子系统等），因此迁移的成本相对可控。</li></ol><p>然而，<strong>x86（32 位）</strong> 并未完全消失。在一些 <strong>老旧设备、嵌入式系统、工控机</strong> 等场景，由于硬件或系统的限制，可能还在使用 32 位的架构。另外，在逆向工程和安全研究领域，有时也需要分析老版本 32 位程序，因此对 x86 汇编依然要有一定掌握。</p><hr><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><ul><li><strong>x86 和 x64 的核心差别</strong>主要在于：寄存器宽度与数量、函数调用约定、可寻址内存空间以及指令集扩展。</li><li>目前 <strong>主流的桌面、服务器平台</strong> 都已转向 x64（64 位），对于学习和工作来说，x64 的重要性更高。</li><li>对于逆向工程或系统底层开发而言，<strong>x86 的知识依然不可或缺</strong>，因为很多老软件、驱动、嵌入式仍基于 32 位环境，需要能够读懂 x86 汇编。</li><li>如果从零起步，可以将 x86 视作基础再过渡到 x64，毕竟它们在指令层面有很多相通之处（x64 是在 x86 基础上扩展而来）。实际项目中，大多数场景还是建议重点掌握 x64，兼顾熟悉 x86，以便应对可能遇到的多平台需求。</li></ul>',22)]))}const c=i(r,[["render",a],["__file","reverse-engineering-2.html.vue"]]),p=JSON.parse('{"path":"/public-articles/reverse-engineering-2.html","title":"x86/x64 汇编 有什么区别呢？ 那个是主流。","lang":"zh-CN","frontmatter":{"description":"x86/x64 汇编 有什么区别呢？ 那个是主流。 在日常所说的「x86」和「x64」中，x86 通常指 32 位的处理器/指令集架构（全称可写作 x86_32），而 x64 则指 64 位的处理器/指令集架构（也称 x86_64 或 AMD64）。汇编层面上的区别，主要体现在寄存器的数量与宽度、函数调用约定、内存寻址等方面。以下是一些主要差异： 1....","head":[["meta",{"property":"og:url","content":"https://github.com/biezhihua/public-articles/reverse-engineering-2.html"}],["meta",{"property":"og:site_name","content":"biezhihua的日常"}],["meta",{"property":"og:title","content":"x86/x64 汇编 有什么区别呢？ 那个是主流。"}],["meta",{"property":"og:description","content":"x86/x64 汇编 有什么区别呢？ 那个是主流。 在日常所说的「x86」和「x64」中，x86 通常指 32 位的处理器/指令集架构（全称可写作 x86_32），而 x64 则指 64 位的处理器/指令集架构（也称 x86_64 或 AMD64）。汇编层面上的区别，主要体现在寄存器的数量与宽度、函数调用约定、内存寻址等方面。以下是一些主要差异： 1...."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-08T14:25:34.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-08T14:25:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"x86/x64 汇编 有什么区别呢？ 那个是主流。\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-08T14:25:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"别志华\\",\\"url\\":\\"https://github.com/biezhihua\\"}]}"]]},"git":{"createdTime":1735183861000,"updatedTime":1741443934000,"contributors":[{"name":"biezhihua","username":"biezhihua","email":"biezhihua@gmail.com","commits":2,"url":"https://github.com/biezhihua"}]},"readingTime":{"minutes":4.05,"words":1216},"filePathRelative":"public-articles/reverse-engineering-2.md","localizedDate":"2024年12月26日","excerpt":"","autoDesc":true}');export{c as comp,p as data};
