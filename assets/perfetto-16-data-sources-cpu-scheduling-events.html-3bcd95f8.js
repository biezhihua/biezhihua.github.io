import{_ as e,Y as a,Z as n,a2 as i}from"./framework-301d0703.js";const c={},t=i('<h1 id="perfetto-16-cpu-scheduling-events-cpu调度事件" tabindex="-1"><a class="header-anchor" href="#perfetto-16-cpu-scheduling-events-cpu调度事件" aria-hidden="true">#</a> Perfetto - 16 - CPU Scheduling events CPU调度事件</h1><p>在Android和Linux上，Perfetto可以通过Linux内核ftrace基础设施收集调度器跟踪信息。</p><p>这允许获取细粒度的调度事件，例如：</p><p>任何时间点哪些线程在哪个CPU核上调度，精确到纳秒。 正在运行的线程被取消调度的原因（例如，抢占，阻塞在互斥锁上，阻塞的系统调用或任何其他等待队列）。 一个线程何时变为可执行状态的时间点，即使它没有立即被放置在任何CPU运行队列中，还可以查看使其可执行的源线程。 用户界面</p><h2 id="ui" tabindex="-1"><a class="header-anchor" href="#ui" aria-hidden="true">#</a> UI</h2><p>当缩小界面时，UI显示了CPU使用情况的量化视图，其中折叠了调度信息：</p><p>但是，通过放大视图，可以看到单个调度事件：</p><p>单击CPU切片会在详细面板中显示相关信息：</p><p>向下滚动时，当展开单个进程时，调度事件也会为每个线程创建一个跟踪，这允许跟踪单个线程状态的演变：</p><h2 id="sql" tabindex="-1"><a class="header-anchor" href="#sql" aria-hidden="true">#</a> SQL</h2><h2 id="traceconfig" tabindex="-1"><a class="header-anchor" href="#traceconfig" aria-hidden="true">#</a> TraceConfig</h2><h2 id="scheduling-wakeups-and-latency-analysis-调度唤醒和延迟分析" tabindex="-1"><a class="header-anchor" href="#scheduling-wakeups-and-latency-analysis-调度唤醒和延迟分析" aria-hidden="true">#</a> Scheduling wakeups and latency analysis 调度唤醒和延迟分析</h2><p>通过在TraceConfig中进一步启用以下内容，ftrace数据源将记录调度唤醒事件：</p><p>ftrace_events:“sched/sched_wakeup_new” ftrace_events:“sched/sched_waking”</p><p>只有当线程处于R（可运行）状态并且正在CPU运行队列上运行时，才会发出sched_switch事件，而当任何事件导致线程状态发生变化时，就会发出sched_waking事件。</p><p>考虑以下示例：</p><p>线程A condition_variable.wait() 线程B condition_variable.notify()</p><p>当线程A在wait（）上暂停时，它将进入S（睡眠）状态并从CPU运行队列中删除。当线程B通知变量时，内核将线程A转换为R（可运行）状态。此时，线程A有资格重新放回运行队列。但是，这可能需要一些时间，因为，例如：</p><ul><li>所有CPU可能都在忙于运行其他线程，线程A需要等待以分配运行队列插槽（或其他线程具有更高的优先级）。</li><li>除当前CPU外的其他某些CPU，但是调度器负载平衡器可能需要一些时间才能将线程移动到另一个CPU。</li></ul><p>除非使用实时线程优先级，否则大多数Linux内核调度器配置都不是严格的工作保存配置。例如，调度器可能希望等待一段时间，以便在当前CPU上运行的线程进入空闲状态，避免跨CPU迁移，这可能在开销和功率方面更昂贵。</p><p>注意：sched_waking和sched_wakeup提供几乎相同的信息。差异在于跨CPU的唤醒事件，涉及跨处理器中断。前者在源（wakee）CPU上发出，后者在目标（waked）CPU上发出。sched_waking通常足以进行延迟分析，除非您要分解由于跨处理器信令而导致的延迟。</p><p>启用sched_waking事件后，在选择CPU片段时，将出现以下内容：</p><h3 id="decoding-end-state" tabindex="-1"><a class="header-anchor" href="#decoding-end-state" aria-hidden="true">#</a> Decoding end_state</h3><p>sched_slice表包含了系统调度活动的信息:</p><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2><ul><li>https://perfetto.dev/docs/data-sources/cpu-scheduling</li><li>https://perfetto.dev/docs/analysis/sql-tables#sched_slice</li></ul>',26),d=[t];function s(r,h){return a(),n("div",null,d)}const l=e(c,[["render",s],["__file","perfetto-16-data-sources-cpu-scheduling-events.html.vue"]]);export{l as default};
