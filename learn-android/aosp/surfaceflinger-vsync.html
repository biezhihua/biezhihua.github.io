<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <title>Android | AOSP | SurfaceFlinger模块-VSYNC研究 | 转载&加工 | biezhihua的日常</title><meta name="description" content=" ">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-4e824e77.css" as="style"><link rel="stylesheet" href="/assets/style-4e824e77.css">
    <link rel="modulepreload" href="/assets/app-ea0f097a.js"><link rel="modulepreload" href="/assets/framework-301d0703.js"><link rel="modulepreload" href="/assets/surfaceflinger-vsync.html-4e947102.js"><link rel="modulepreload" href="/assets/surfaceflinger-vsync.html-975894fc.js"><link rel="prefetch" href="/assets/index.html-8f7d46d2.js" as="script"><link rel="prefetch" href="/assets/about-me.html-0aba838f.js" as="script"><link rel="prefetch" href="/assets/index.html-61f5d4e5.js" as="script"><link rel="prefetch" href="/assets/index.html-14645dd8.js" as="script"><link rel="prefetch" href="/assets/index.html-a0547254.js" as="script"><link rel="prefetch" href="/assets/difficult-sentence.html-06283e2e.js" as="script"><link rel="prefetch" href="/assets/Algorithms-analysis.html-b66fb5de.js" as="script"><link rel="prefetch" href="/assets/Algorithms-apply.html-4650ed25.js" as="script"><link rel="prefetch" href="/assets/Algorithms-math-base.html-3a3a7fe9.js" as="script"><link rel="prefetch" href="/assets/Algorithms-thinking.html-0d744ef0.js" as="script"><link rel="prefetch" href="/assets/Algorithms.html-0a7f8461.js" as="script"><link rel="prefetch" href="/assets/Data-structure.html-f38ebd02.js" as="script"><link rel="prefetch" href="/assets/index.html-1f3aeb3c.js" as="script"><link rel="prefetch" href="/assets/algorithms-graph.html-bb7bc117.js" as="script"><link rel="prefetch" href="/assets/android-逆向学习.html-9176ba32.js" as="script"><link rel="prefetch" href="/assets/滴水三期.html-3cf4b633.js" as="script"><link rel="prefetch" href="/assets/计算机组成原理.html-0cdc9ea0.js" as="script"><link rel="prefetch" href="/assets/Assembly-Language-4th-Edition-Wang-Shuang.html-41f3c22c.js" as="script"><link rel="prefetch" href="/assets/Learn-Reverse-Engineering.html-4895b5c7.js" as="script"><link rel="prefetch" href="/assets/SELinux.html-97322150.js" as="script"><link rel="prefetch" href="/assets/The-Self-cultivation-of-Programmers-Linking-Loading-and-Libraries.html-36224a19.js" as="script"><link rel="prefetch" href="/assets/The-core-principles-of-reverse-engineering.html-fe274807.js" as="script"><link rel="prefetch" href="/assets/andorid-kernel.html-7d044ce7.js" as="script"><link rel="prefetch" href="/assets/android-aar-maven.html-9c4bcf54.js" as="script"><link rel="prefetch" href="/assets/android-immersive.html-565b26d0.js" as="script"><link rel="prefetch" href="/assets/android-ndk-r18b-toolchains.html-d90c3742.js" as="script"><link rel="prefetch" href="/assets/android-notification-listener-service.html-66b79e32.js" as="script"><link rel="prefetch" href="/assets/android-scrcpy.html-9c1e6687.js" as="script"><link rel="prefetch" href="/assets/binary-and-hexadecimal-conversion-rules.html-8c3a2f49.js" as="script"><link rel="prefetch" href="/assets/color-difference-calculation.html-e8de2679.js" as="script"><link rel="prefetch" href="/assets/color.html-094cca02.js" as="script"><link rel="prefetch" href="/assets/gradle-commonh-command.html-f5eb03fc.js" as="script"><link rel="prefetch" href="/assets/how-to-call-rust-function-from-harmony.html-585a93a8.js" as="script"><link rel="prefetch" href="/assets/how-to-extension-method-for-option-in-rust.html-e9a29c8b.js" as="script"><link rel="prefetch" href="/assets/how-to-fix-waiting-for-file-lock-on-package-cache.html-a2c279bc.js" as="script"><link rel="prefetch" href="/assets/how-to-get-multi-option-value.html-1e1ad627.js" as="script"><link rel="prefetch" href="/assets/how-to-ignore-warning-info-in-rust.html-67a71aca.js" as="script"><link rel="prefetch" href="/assets/how-to-mount-remote-disk-to-local.html-dffe8408.js" as="script"><link rel="prefetch" href="/assets/how-to-process-common-error.html-98711890.js" as="script"><link rel="prefetch" href="/assets/how-to-read-config-file-of-lib-project-in-rust.html-48b93fdd.js" as="script"><link rel="prefetch" href="/assets/how-to-use-result-process-option-in-rust.html-7aaf9c34.js" as="script"><link rel="prefetch" href="/assets/hypervisor.html-06d080ef.js" as="script"><link rel="prefetch" href="/assets/learn-compilers.html-251eff98.js" as="script"><link rel="prefetch" href="/assets/learn-ida.html-d810f66c.js" as="script"><link rel="prefetch" href="/assets/learn-rust.html-84e8fa8c.js" as="script"><link rel="prefetch" href="/assets/learn-stable-diffusion.html-364ef775.js" as="script"><link rel="prefetch" href="/assets/learn-ui-design-UI设计必修课-交互-架构-视觉UI设计教程.html-380d9555.js" as="script"><link rel="prefetch" href="/assets/learn-windows-linux.html-e252b841.js" as="script"><link rel="prefetch" href="/assets/lr1-detail.html-35ac5da7.js" as="script"><link rel="prefetch" href="/assets/lr1-detail2.html-aa0e893f.js" as="script"><link rel="prefetch" href="/assets/lr1-detail3.html-113cf2cf.js" as="script"><link rel="prefetch" href="/assets/lr1-detail4.html-a735ca64.js" as="script"><link rel="prefetch" href="/assets/lr1-产生式是如何定义的.html-526dc03a.js" as="script"><link rel="prefetch" href="/assets/lr1.html-364345dd.js" as="script"><link rel="prefetch" href="/assets/math-lerp.html-b1ef274c.js" as="script"><link rel="prefetch" href="/assets/mhxy-navgiate-mode.html-91c4dc9e.js" as="script"><link rel="prefetch" href="/assets/mhxy-script.html-fe7ed3b9.js" as="script"><link rel="prefetch" href="/assets/pc-platform-arch-info.html-c3574df9.js" as="script"><link rel="prefetch" href="/assets/pyhont-callable.html-39bbd9bb.js" as="script"><link rel="prefetch" href="/assets/python-async-await-threading.html-ffb680c2.js" as="script"><link rel="prefetch" href="/assets/python-async-await.html-b2b061d8.js" as="script"><link rel="prefetch" href="/assets/python-async-block-unblock.html-ab407dac.js" as="script"><link rel="prefetch" href="/assets/python-async.html-10699147.js" as="script"><link rel="prefetch" href="/assets/python-dict.html-cdb13758.js" as="script"><link rel="prefetch" href="/assets/python-singleton-decorator.html-b51f1c55.js" as="script"><link rel="prefetch" href="/assets/python-singleton.html-1f801303.js" as="script"><link rel="prefetch" href="/assets/pythopn-opencv-hist.html-d75a61ec.js" as="script"><link rel="prefetch" href="/assets/quickjs-eval-flags.html-5bde64b6.js" as="script"><link rel="prefetch" href="/assets/quickjs-eval.html-d6ab30f6.js" as="script"><link rel="prefetch" href="/assets/reverse-engineering-1.html-1d91304b.js" as="script"><link rel="prefetch" href="/assets/reverse-engineering-2.html-c8d3419c.js" as="script"><link rel="prefetch" href="/assets/reverse-engineering-3.html-5081bb0c.js" as="script"><link rel="prefetch" href="/assets/reverse-engineering-windows-1.html-acbeb70a.js" as="script"><link rel="prefetch" href="/assets/reverse-engineering-windows-2.html-cad0b6b2.js" as="script"><link rel="prefetch" href="/assets/root-magisk-xposed-lsposed.html-b42b753a.js" as="script"><link rel="prefetch" href="/assets/solution-rust-diesel-install-in-windows.html-c2a6dc5b.js" as="script"><link rel="prefetch" href="/assets/using-opencv-4-surf-algorithm-feature-detection-quoc-bao-nguyen.html-faa42c18.js" as="script"><link rel="prefetch" href="/assets/vm1.html-06885d29.js" as="script"><link rel="prefetch" href="/assets/vm2.html-ac483d1c.js" as="script"><link rel="prefetch" href="/assets/vm3.html-407db03d.js" as="script"><link rel="prefetch" href="/assets/vm4.html-b1ef248c.js" as="script"><link rel="prefetch" href="/assets/vmx.html-e90dc338.js" as="script"><link rel="prefetch" href="/assets/what-is-the-COM-in-windows.html-4aa437c6.js" as="script"><link rel="prefetch" href="/assets/what-is-the-epoll.html-b8c78cd0.js" as="script"><link rel="prefetch" href="/assets/what-is-the-file-descriptor.html-5990db6c.js" as="script"><link rel="prefetch" href="/assets/what-is-the-meaning-of-__no_mangle_.html-86d7236d.js" as="script"><link rel="prefetch" href="/assets/what-is-the-meaning-of-__repr(C)_.html-87a96084.js" as="script"><link rel="prefetch" href="/assets/what-is-the-varargs-in-python.html-57ede2d2.js" as="script"><link rel="prefetch" href="/assets/what-the-different-self-and-Self-in-Rust.html-7ce6e072.js" as="script"><link rel="prefetch" href="/assets/windows-SystemFirmwareTable.html-f334b3e4.js" as="script"><link rel="prefetch" href="/assets/windows-dev.html-3bf89842.js" as="script"><link rel="prefetch" href="/assets/index.html-7ce6bbe1.js" as="script"><link rel="prefetch" href="/assets/product-research.html-3e49a926.js" as="script"><link rel="prefetch" href="/assets/google-android-atrace.html-d605d9e3.js" as="script"><link rel="prefetch" href="/assets/google-android-graphics.html-ffd17aab.js" as="script"><link rel="prefetch" href="/assets/google-android-performance-overview.html-9206936e.js" as="script"><link rel="prefetch" href="/assets/google-android-profiler.html-65fc7a14.js" as="script"><link rel="prefetch" href="/assets/google-android-system.html-d2106ddf.js" as="script"><link rel="prefetch" href="/assets/app-launch.html-e96170d2.js" as="script"><link rel="prefetch" href="/assets/build-aosp-in-wls.html-8079a0a9.js" as="script"><link rel="prefetch" href="/assets/extend.html-8bbfb8bd.js" as="script"><link rel="prefetch" href="/assets/surfaceflinger-init.html-305c933f.js" as="script"><link rel="prefetch" href="/assets/zygote.html-8ece84c0.js" as="script"><link rel="prefetch" href="/assets/perfetto-00-outline.html-7a994722.js" as="script"><link rel="prefetch" href="/assets/perfetto-01-overview.html-e09cb048.js" as="script"><link rel="prefetch" href="/assets/perfetto-02-tracing-101.html-d131e16c.js" as="script"><link rel="prefetch" href="/assets/perfetto-03-quickstart-record-traces-on-android.html-104c3993.js" as="script"><link rel="prefetch" href="/assets/perfetto-06-quickstart-sql-analysis-and-metrics copy.html-cc34107a.js" as="script"><link rel="prefetch" href="/assets/perfetto-07-quickstart-trace-conversion copy.html-c2b6d5e1.js" as="script"><link rel="prefetch" href="/assets/perfetto-08-quickstart-heap-profiling copy.html-992c7e6b.js" as="script"><link rel="prefetch" href="/assets/perfetto-09-quickstart-callstack-sampling-on-android copy.html-dcf55c80.js" as="script"><link rel="prefetch" href="/assets/perfetto-10-faq.html-d0acc432.js" as="script"><link rel="prefetch" href="/assets/perfetto-11-case-stuides-android-boot-tracing.html-0b0c53ba.js" as="script"><link rel="prefetch" href="/assets/perfetto-12-data-sources-debugging-memory-usage.html-8d7f8fff.js" as="script"><link rel="prefetch" href="/assets/perfetto-13-data-sources-memory-counter-and-events.html-98bc5291.js" as="script"><link rel="prefetch" href="/assets/perfetto-14-data-sources-memory-heap-profiler.html-c1ea4af0.js" as="script"><link rel="prefetch" href="/assets/perfetto-15-data-sources-java-heap-dumps.html-c7dd09aa.js" as="script"><link rel="prefetch" href="/assets/perfetto-16-data-sources-cpu-scheduling-events.html-cee793b2.js" as="script"><link rel="prefetch" href="/assets/perfetto-17-data-sources-system-calls.html-ba097393.js" as="script"><link rel="prefetch" href="/assets/perfetto-18-data-sources-cpu-frequency-scaling.html-9562909b.js" as="script"><link rel="prefetch" href="/assets/perfetto-21-android-system-android-game-intervention-list.html-15c3e7b7.js" as="script"><link rel="prefetch" href="/assets/perfetto-22-data-sources-android-system-atrace-instrumentation.html-298378fc.js" as="script"><link rel="prefetch" href="/assets/perfetto-23-data-sources-android-system-android-log.html-02d49f35.js" as="script"><link rel="prefetch" href="/assets/perfetto-24-data-sources-android-system-android-jank.html-78b58d3e.js" as="script"><link rel="prefetch" href="/assets/perfetto-25-app-instrumentation-tracing-sdk.html-e174fe67.js" as="script"><link rel="prefetch" href="/assets/perfetto-28-trace-analysis-trace-processor.html-b0f0de5d.js" as="script"><link rel="prefetch" href="/assets/perfetto-41-core-concepts-trace-configuration.html-949e1731.js" as="script"><link rel="prefetch" href="/assets/perfetto-42-core-concepts-buffers-and-dataflow.html-9671fc34.js" as="script"><link rel="prefetch" href="/assets/perfetto-43-core-concepts-service-model.html-3ed70a35.js" as="script"><link rel="prefetch" href="/assets/fluency-00-outline.html-9a5396ee.js" as="script"><link rel="prefetch" href="/assets/fluency-01-overview.html-1f63a601.js" as="script"><link rel="prefetch" href="/assets/fluency-02-fps.html-4274a850.js" as="script"><link rel="prefetch" href="/assets/fluency-03-observability-technology.html-32127ae6.js" as="script"><link rel="prefetch" href="/assets/fluency-04-tracing.html-b62923ce.js" as="script"><link rel="prefetch" href="/assets/fluency-05-tools-perfetto.html-7fca108c.js" as="script"><link rel="prefetch" href="/assets/fluency-06-tools-android-profiler.html-1fc33e0a.js" as="script"><link rel="prefetch" href="/assets/fluency-07-perfetto-android-overview.html-a6d41586.js" as="script"><link rel="prefetch" href="/assets/fluency-08-perfetto-android-graphics-vsync.html-2013508f.js" as="script"><link rel="prefetch" href="/assets/index.html-262710bf.js" as="script"><link rel="prefetch" href="/assets/native-crash.html-5fff769c.js" as="script"><link rel="prefetch" href="/assets/overview.html-e2abb5ef.js" as="script"><link rel="prefetch" href="/assets/index.html-af346e67.js" as="script"><link rel="prefetch" href="/assets/6.006 Introduction To Algorithms.html-977ea701.js" as="script"><link rel="prefetch" href="/assets/6.042J Undergraduate Mathematics For Computer Science.html-68885d69.js" as="script"><link rel="prefetch" href="/assets/6.046J Design And Analysis Of Algorithms.html-92a0b7a1.js" as="script"><link rel="prefetch" href="/assets/6.828 Operating System Engineering.html-c0df9303.js" as="script"><link rel="prefetch" href="/assets/6.851 Advanced Data Structures.html-77bf2ed1.js" as="script"><link rel="prefetch" href="/assets/6.854J Advanced Alorithms.html-66f54f68.js" as="script"><link rel="prefetch" href="/assets/Lesson-01-A-private-conversation.html-79e404a8.js" as="script"><link rel="prefetch" href="/assets/Lesson-02-Breakfast-or-lunch.html-55530288.js" as="script"><link rel="prefetch" href="/assets/Lesson-03-Please-send-me-a-card.html-9bf43ce2.js" as="script"><link rel="prefetch" href="/assets/Lesson-04-An-exciting-trip.html-738dcce4.js" as="script"><link rel="prefetch" href="/assets/Lesson-05-No-Wrong-Numbers.html-261d758d.js" as="script"><link rel="prefetch" href="/assets/Lesson-06-Percy-Buttons.html-68a40839.js" as="script"><link rel="prefetch" href="/assets/Lesson-07-Too-late.html-8c4c5c4a.js" as="script"><link rel="prefetch" href="/assets/Lesson-08-The-best-and-the-worst.html-c8faa7ef.js" as="script"><link rel="prefetch" href="/assets/Lesson-09-A-cold-welcome.html-ba9d6e48.js" as="script"><link rel="prefetch" href="/assets/Lesson-10-Not-For-Jazz.html-74cacfe2.js" as="script"><link rel="prefetch" href="/assets/Lesson-11-One-good-turn-deserves-another.html-6f0d8177.js" as="script"><link rel="prefetch" href="/assets/Lesson-12-Goodbye-and-good-luck.html-8ec9412a.js" as="script"><link rel="prefetch" href="/assets/Lesson-13-The-Greenwood-Boys.html-6f80fee8.js" as="script"><link rel="prefetch" href="/assets/Lesson-14-Do-you-speak-English.html-5018e3d8.js" as="script"><link rel="prefetch" href="/assets/Lesson-15-Good-news.html-423b918a.js" as="script"><link rel="prefetch" href="/assets/Lesson-16-A-polite-request.html-56de9ad7.js" as="script"><link rel="prefetch" href="/assets/Lesson-17-Always-young.html-ec862a93.js" as="script"><link rel="prefetch" href="/assets/Lesson-18-He-often-does-this.html-39b1c890.js" as="script"><link rel="prefetch" href="/assets/Lesson-19-Sold-out.html-e487ba62.js" as="script"><link rel="prefetch" href="/assets/Lesson-20-One-man-in-a-boat.html-ecc5a2d7.js" as="script"><link rel="prefetch" href="/assets/Lesson-21-Mad-or-not.html-5c6492f4.js" as="script"><link rel="prefetch" href="/assets/Lesson-22-A-glass-envelope.html-bb0b25a8.js" as="script"><link rel="prefetch" href="/assets/Lesson-23-A-new-house.html-c01ff769.js" as="script"><link rel="prefetch" href="/assets/Lesson-24-If-could-be-worse.html-b7f7d7a2.js" as="script"><link rel="prefetch" href="/assets/Lesson-25-Do-the-English-speak-English.html-a97169ea.js" as="script"><link rel="prefetch" href="/assets/Lesson-26-The-best-art-critics.html-32a80fe9.js" as="script"><link rel="prefetch" href="/assets/Lesson-27-A-wet-night.html-3952a0dc.js" as="script"><link rel="prefetch" href="/assets/Lesson-28-No-parking.html-8c271b7d.js" as="script"><link rel="prefetch" href="/assets/Lesson-29-Taxi.html-16fb53dd.js" as="script"><link rel="prefetch" href="/assets/Lesson-30-Football-or-polo.html-ff361419.js" as="script"><link rel="prefetch" href="/assets/Lesson-31-Success-story.html-64c6defe.js" as="script"><link rel="prefetch" href="/assets/Lesson-32-Shopping-make-easy.html-08e081e0.js" as="script"><link rel="prefetch" href="/assets/Lesson-33-Out-of-the-darkness.html-1e0a2016.js" as="script"><link rel="prefetch" href="/assets/Lesson-34-Quick-work.html-a4f04c30.js" as="script"><link rel="prefetch" href="/assets/Lesson-35-Stop-thief.html-995b31b3.js" as="script"><link rel="prefetch" href="/assets/Lesson-36-Across-the-Channel.html-fc0101ee.js" as="script"><link rel="prefetch" href="/assets/Lesson-37-The-Olympic-Games.html-e5b98d0b.js" as="script"><link rel="prefetch" href="/assets/Lesson-38-Everything-except-the-weather.html-69c28223.js" as="script"><link rel="prefetch" href="/assets/Lesson-39-Am-I-all-right.html-5ef1c91a.js" as="script"><link rel="prefetch" href="/assets/Lesson-40-Food-and-talk.html-0614b48e.js" as="script"><link rel="prefetch" href="/assets/Lesson-41-Do-you-call-that-a-hat.html-73249c55.js" as="script"><link rel="prefetch" href="/assets/Lesson-42-Not-very-musical.html-88fcdc8f.js" as="script"><link rel="prefetch" href="/assets/Lesson-43-Over-the-South-Pole.html-92312dd7.js" as="script"><link rel="prefetch" href="/assets/Lesson-44-Through-the-forest.html-766f3816.js" as="script"><link rel="prefetch" href="/assets/Lesson-45-A-clear-conscience.html-55850137.js" as="script"><link rel="prefetch" href="/assets/Lesson-46-Expensive-and-uncomfortable.html-2d715693.js" as="script"><link rel="prefetch" href="/assets/Lesson-47-A-thirsty-ghost.html-67abb7d0.js" as="script"><link rel="prefetch" href="/assets/Lesson-48-Did-you-want-to-tell-me-something.html-86d37f80.js" as="script"><link rel="prefetch" href="/assets/Lesson-49-The-end-of-a-dream.html-6c782465.js" as="script"><link rel="prefetch" href="/assets/Lesson-50-Taken-for-a-ride.html-560cd4d3.js" as="script"><link rel="prefetch" href="/assets/Lesson-51-Reward-for-virtue.html-f0c4eb6d.js" as="script"><link rel="prefetch" href="/assets/Lesson-52-A-pretty-carpet.html-eed5dcf6.js" as="script"><link rel="prefetch" href="/assets/Lesson-53-Hot-snake.html-0e228ee5.js" as="script"><link rel="prefetch" href="/assets/Lesson-54-Sticky-fingers.html-bea67146.js" as="script"><link rel="prefetch" href="/assets/Lesson-55-Not-a-gold-mine.html-054c48ed.js" as="script"><link rel="prefetch" href="/assets/Lesson-56-Faster-than-sound.html-18a2daf1.js" as="script"><link rel="prefetch" href="/assets/Lesson-57-Can-I-help-you_-madam.html-e3bd9975.js" as="script"><link rel="prefetch" href="/assets/Lesson-58-A-blessing-in-disguise.html-6d457927.js" as="script"><link rel="prefetch" href="/assets/Lesson-59-In-or-out.html-ed6f20aa.js" as="script"><link rel="prefetch" href="/assets/Lesson-60-The-future.html-e75740c4.js" as="script"><link rel="prefetch" href="/assets/Lesson-61-Trouble-with-the-Hubble.html-c658cd33.js" as="script"><link rel="prefetch" href="/assets/Lesson-62-After-the-fire.html-37b335c2.js" as="script"><link rel="prefetch" href="/assets/Lesson-63-She-was-not-amused.html-f024b379.js" as="script"><link rel="prefetch" href="/assets/Lesson-64-The-Channel-Tunnel.html-ba414ab5.js" as="script"><link rel="prefetch" href="/assets/Lesson-65-Jumbo-versus-the-police.html-9856e739.js" as="script"><link rel="prefetch" href="/assets/Lesson-66-Sweet-as-honey.html-55892d9a.js" as="script"><link rel="prefetch" href="/assets/Lesson-67-Volcanoes.html-f5c5f3b0.js" as="script"><link rel="prefetch" href="/assets/Lesson-68-Persistent.html-2c003e98.js" as="script"><link rel="prefetch" href="/assets/Lesson-69-But-not-murder.html-01435c21.js" as="script"><link rel="prefetch" href="/assets/Lesson-70-Red-for-danger.html-54e463c3.js" as="script"><link rel="prefetch" href="/assets/Lesson-71-A-famous-clock.html-4036ba3d.js" as="script"><link rel="prefetch" href="/assets/Lesson-72-A-car-called-bluebird.html-1f8d77ca.js" as="script"><link rel="prefetch" href="/assets/Lesson-73-The-record-holder.html-743d08ff.js" as="script"><link rel="prefetch" href="/assets/Lesson-74-Out-of-the-limelight.html-2b63e865.js" as="script"><link rel="prefetch" href="/assets/Lesson-75-SOS.html-c899ee58.js" as="script"><link rel="prefetch" href="/assets/Lesson-76-April-Fools-Day.html-23d15298.js" as="script"><link rel="prefetch" href="/assets/Lesson-77-Successful-operation.html-d7b03b7d.js" as="script"><link rel="prefetch" href="/assets/Lesson-78-The-last-one.html-7751646e.js" as="script"><link rel="prefetch" href="/assets/Lesson-79-By-air.html-7132b415.js" as="script"><link rel="prefetch" href="/assets/Lesson-80-The-Crystal-Palace.html-9b0122a3.js" as="script"><link rel="prefetch" href="/assets/Lesson-81-Escape.html-0916100b.js" as="script"><link rel="prefetch" href="/assets/Lesson-82-Monster-or-fish.html-2e8d76ae.js" as="script"><link rel="prefetch" href="/assets/Lesson-83-After-the-elections.html-8cc5e592.js" as="script"><link rel="prefetch" href="/assets/Lesson-84-On-strike.html-c5569c72.js" as="script"><link rel="prefetch" href="/assets/Lesson-85-Never-too-old-to-learn.html-09fb2aa9.js" as="script"><link rel="prefetch" href="/assets/Lesson-86-Out-of-control.html-f2d09777.js" as="script"><link rel="prefetch" href="/assets/Lesson-87-A-perfect-alibi.html-0bdd577e.js" as="script"><link rel="prefetch" href="/assets/Lesson-88-Trapped-in-a-mine.html-04f0b504.js" as="script"><link rel="prefetch" href="/assets/Lesson-89-A-slip-of-the-tongue.html-8194d74d.js" as="script"><link rel="prefetch" href="/assets/Lesson-90-What-is-for-supper.html-b3be097a.js" as="script"><link rel="prefetch" href="/assets/Lesson-91-Three-men-in-a-basket.html-1d929167.js" as="script"><link rel="prefetch" href="/assets/Lesson-92-Asking-for-trouble.html-178ae445.js" as="script"><link rel="prefetch" href="/assets/Lesson-93-A-noble-gift.html-40cbe0c1.js" as="script"><link rel="prefetch" href="/assets/Lesson-94-Future-champions.html-cded8b28.js" as="script"><link rel="prefetch" href="/assets/Lesson-95-A-fantasy.html-1e2793d5.js" as="script"><link rel="prefetch" href="/assets/Lesson-96-The-dead-return.html-653cbfd2.js" as="script"><link rel="prefetch" href="/assets/404.html-f04ced3e.js" as="script"><link rel="prefetch" href="/assets/index.html-c2327f66.js" as="script"><link rel="prefetch" href="/assets/index.html-6156e226.js" as="script"><link rel="prefetch" href="/assets/index.html-1ac4198b.js" as="script"><link rel="prefetch" href="/assets/index.html-5395f306.js" as="script"><link rel="prefetch" href="/assets/index.html-6ac68638.js" as="script"><link rel="prefetch" href="/assets/index.html-f773b72f.js" as="script"><link rel="prefetch" href="/assets/index.html-d76751ea.js" as="script"><link rel="prefetch" href="/assets/index.html-c351a08b.js" as="script"><link rel="prefetch" href="/assets/index.html-220b13fe.js" as="script"><link rel="prefetch" href="/assets/index.html-234bc9da.js" as="script"><link rel="prefetch" href="/assets/index.html-b092c319.js" as="script"><link rel="prefetch" href="/assets/index.html-f8c1c176.js" as="script"><link rel="prefetch" href="/assets/index.html-17632ffc.js" as="script"><link rel="prefetch" href="/assets/index.html-e609b71c.js" as="script"><link rel="prefetch" href="/assets/index.html-04a11369.js" as="script"><link rel="prefetch" href="/assets/index.html-d1922e1a.js" as="script"><link rel="prefetch" href="/assets/index.html-c43655ce.js" as="script"><link rel="prefetch" href="/assets/index.html-b67245ca.js" as="script"><link rel="prefetch" href="/assets/index.html-6141f480.js" as="script"><link rel="prefetch" href="/assets/index.html-7352899a.js" as="script"><link rel="prefetch" href="/assets/index.html-2236f7a2.js" as="script"><link rel="prefetch" href="/assets/index.html-23a135a4.js" as="script"><link rel="prefetch" href="/assets/index.html-839b2da8.js" as="script"><link rel="prefetch" href="/assets/index.html-99e9b40e.js" as="script"><link rel="prefetch" href="/assets/index.html-779cad05.js" as="script"><link rel="prefetch" href="/assets/about-me.html-b2509657.js" as="script"><link rel="prefetch" href="/assets/index.html-416fff7b.js" as="script"><link rel="prefetch" href="/assets/index.html-fff833d2.js" as="script"><link rel="prefetch" href="/assets/index.html-3b6779cc.js" as="script"><link rel="prefetch" href="/assets/difficult-sentence.html-154d203f.js" as="script"><link rel="prefetch" href="/assets/Algorithms-analysis.html-fc399a46.js" as="script"><link rel="prefetch" href="/assets/Algorithms-apply.html-ae299256.js" as="script"><link rel="prefetch" href="/assets/Algorithms-math-base.html-5de2a27c.js" as="script"><link rel="prefetch" href="/assets/Algorithms-thinking.html-ddbf1079.js" as="script"><link rel="prefetch" href="/assets/Algorithms.html-afdf5c2f.js" as="script"><link rel="prefetch" href="/assets/Data-structure.html-35cb5021.js" as="script"><link rel="prefetch" href="/assets/index.html-f5f961fb.js" as="script"><link rel="prefetch" href="/assets/algorithms-graph.html-fab41a91.js" as="script"><link rel="prefetch" href="/assets/android-逆向学习.html-4d4324c7.js" as="script"><link rel="prefetch" href="/assets/滴水三期.html-d9ea5c82.js" as="script"><link rel="prefetch" href="/assets/计算机组成原理.html-2e92fc5b.js" as="script"><link rel="prefetch" href="/assets/Assembly-Language-4th-Edition-Wang-Shuang.html-13de2ff4.js" as="script"><link rel="prefetch" href="/assets/Learn-Reverse-Engineering.html-aca5c4d9.js" as="script"><link rel="prefetch" href="/assets/SELinux.html-661958b3.js" as="script"><link rel="prefetch" href="/assets/The-Self-cultivation-of-Programmers-Linking-Loading-and-Libraries.html-c66e8651.js" as="script"><link rel="prefetch" href="/assets/The-core-principles-of-reverse-engineering.html-252be4af.js" as="script"><link rel="prefetch" href="/assets/andorid-kernel.html-cc51ccff.js" as="script"><link rel="prefetch" href="/assets/android-aar-maven.html-2b7f0575.js" as="script"><link rel="prefetch" href="/assets/android-immersive.html-81324aa1.js" as="script"><link rel="prefetch" href="/assets/android-ndk-r18b-toolchains.html-31b2b001.js" as="script"><link rel="prefetch" href="/assets/android-notification-listener-service.html-969fea7a.js" as="script"><link rel="prefetch" href="/assets/android-scrcpy.html-0f54f03f.js" as="script"><link rel="prefetch" href="/assets/binary-and-hexadecimal-conversion-rules.html-b466d2b5.js" as="script"><link rel="prefetch" href="/assets/color-difference-calculation.html-0979aaf6.js" as="script"><link rel="prefetch" href="/assets/color.html-e805103a.js" as="script"><link rel="prefetch" href="/assets/gradle-commonh-command.html-e27a1f40.js" as="script"><link rel="prefetch" href="/assets/how-to-call-rust-function-from-harmony.html-e25a719e.js" as="script"><link rel="prefetch" href="/assets/how-to-extension-method-for-option-in-rust.html-ec2a1b0c.js" as="script"><link rel="prefetch" href="/assets/how-to-fix-waiting-for-file-lock-on-package-cache.html-d37bf4b4.js" as="script"><link rel="prefetch" href="/assets/how-to-get-multi-option-value.html-0316a1d4.js" as="script"><link rel="prefetch" href="/assets/how-to-ignore-warning-info-in-rust.html-6e467990.js" as="script"><link rel="prefetch" href="/assets/how-to-mount-remote-disk-to-local.html-dfbd64c6.js" as="script"><link rel="prefetch" href="/assets/how-to-process-common-error.html-c965dcde.js" as="script"><link rel="prefetch" href="/assets/how-to-read-config-file-of-lib-project-in-rust.html-df4114ba.js" as="script"><link rel="prefetch" href="/assets/how-to-use-result-process-option-in-rust.html-00e5c654.js" as="script"><link rel="prefetch" href="/assets/hypervisor.html-830b21e6.js" as="script"><link rel="prefetch" href="/assets/learn-compilers.html-8e2880db.js" as="script"><link rel="prefetch" href="/assets/learn-ida.html-a8b50139.js" as="script"><link rel="prefetch" href="/assets/learn-rust.html-31331679.js" as="script"><link rel="prefetch" href="/assets/learn-stable-diffusion.html-2a72d9f3.js" as="script"><link rel="prefetch" href="/assets/learn-ui-design-UI设计必修课-交互-架构-视觉UI设计教程.html-561c329e.js" as="script"><link rel="prefetch" href="/assets/learn-windows-linux.html-43b375e1.js" as="script"><link rel="prefetch" href="/assets/lr1-detail.html-b6b9de71.js" as="script"><link rel="prefetch" href="/assets/lr1-detail2.html-bbd723cb.js" as="script"><link rel="prefetch" href="/assets/lr1-detail3.html-d506608e.js" as="script"><link rel="prefetch" href="/assets/lr1-detail4.html-c9f6630b.js" as="script"><link rel="prefetch" href="/assets/lr1-产生式是如何定义的.html-dd7ee12d.js" as="script"><link rel="prefetch" href="/assets/lr1.html-20780627.js" as="script"><link rel="prefetch" href="/assets/math-lerp.html-a0cfb9e6.js" as="script"><link rel="prefetch" href="/assets/mhxy-navgiate-mode.html-0682a172.js" as="script"><link rel="prefetch" href="/assets/mhxy-script.html-94b8dcf3.js" as="script"><link rel="prefetch" href="/assets/pc-platform-arch-info.html-8c35a059.js" as="script"><link rel="prefetch" href="/assets/pyhont-callable.html-47430193.js" as="script"><link rel="prefetch" href="/assets/python-async-await-threading.html-3d6ed150.js" as="script"><link rel="prefetch" href="/assets/python-async-await.html-d97329ba.js" as="script"><link rel="prefetch" href="/assets/python-async-block-unblock.html-95d93485.js" as="script"><link rel="prefetch" href="/assets/python-async.html-e9f26562.js" as="script"><link rel="prefetch" href="/assets/python-dict.html-5b9ba634.js" as="script"><link rel="prefetch" href="/assets/python-singleton-decorator.html-015a2be2.js" as="script"><link rel="prefetch" href="/assets/python-singleton.html-ea2e6c27.js" as="script"><link rel="prefetch" href="/assets/pythopn-opencv-hist.html-93a08212.js" as="script"><link rel="prefetch" href="/assets/quickjs-eval-flags.html-c8359917.js" as="script"><link rel="prefetch" href="/assets/quickjs-eval.html-b7b84ae1.js" as="script"><link rel="prefetch" href="/assets/reverse-engineering-1.html-392b478f.js" as="script"><link rel="prefetch" href="/assets/reverse-engineering-2.html-b1514673.js" as="script"><link rel="prefetch" href="/assets/reverse-engineering-3.html-56418c3d.js" as="script"><link rel="prefetch" href="/assets/reverse-engineering-windows-1.html-eaeb611f.js" as="script"><link rel="prefetch" href="/assets/reverse-engineering-windows-2.html-a2a5d5b2.js" as="script"><link rel="prefetch" href="/assets/root-magisk-xposed-lsposed.html-e8a277c3.js" as="script"><link rel="prefetch" href="/assets/solution-rust-diesel-install-in-windows.html-8beaa932.js" as="script"><link rel="prefetch" href="/assets/using-opencv-4-surf-algorithm-feature-detection-quoc-bao-nguyen.html-6cc3b73f.js" as="script"><link rel="prefetch" href="/assets/vm1.html-726ea1f4.js" as="script"><link rel="prefetch" href="/assets/vm2.html-63eb2bc0.js" as="script"><link rel="prefetch" href="/assets/vm3.html-b5be2ce5.js" as="script"><link rel="prefetch" href="/assets/vm4.html-5da814d7.js" as="script"><link rel="prefetch" href="/assets/vmx.html-5624dd0d.js" as="script"><link rel="prefetch" href="/assets/what-is-the-COM-in-windows.html-c27cd365.js" as="script"><link rel="prefetch" href="/assets/what-is-the-epoll.html-401dab53.js" as="script"><link rel="prefetch" href="/assets/what-is-the-file-descriptor.html-d3f24efa.js" as="script"><link rel="prefetch" href="/assets/what-is-the-meaning-of-__no_mangle_.html-224c6499.js" as="script"><link rel="prefetch" href="/assets/what-is-the-meaning-of-__repr(C)_.html-beae7365.js" as="script"><link rel="prefetch" href="/assets/what-is-the-varargs-in-python.html-315949ad.js" as="script"><link rel="prefetch" href="/assets/what-the-different-self-and-Self-in-Rust.html-1d6c7339.js" as="script"><link rel="prefetch" href="/assets/windows-SystemFirmwareTable.html-46b5bdea.js" as="script"><link rel="prefetch" href="/assets/windows-dev.html-b4bd6cdc.js" as="script"><link rel="prefetch" href="/assets/index.html-0032b030.js" as="script"><link rel="prefetch" href="/assets/product-research.html-2a210755.js" as="script"><link rel="prefetch" href="/assets/google-android-atrace.html-21301b1b.js" as="script"><link rel="prefetch" href="/assets/google-android-graphics.html-1867f860.js" as="script"><link rel="prefetch" href="/assets/google-android-performance-overview.html-28ca92f8.js" as="script"><link rel="prefetch" href="/assets/google-android-profiler.html-25293b32.js" as="script"><link rel="prefetch" href="/assets/google-android-system.html-59b7bfdc.js" as="script"><link rel="prefetch" href="/assets/app-launch.html-3c7b606d.js" as="script"><link rel="prefetch" href="/assets/build-aosp-in-wls.html-98b84570.js" as="script"><link rel="prefetch" href="/assets/extend.html-0a654d75.js" as="script"><link rel="prefetch" href="/assets/surfaceflinger-init.html-899de574.js" as="script"><link rel="prefetch" href="/assets/zygote.html-9bbb8e62.js" as="script"><link rel="prefetch" href="/assets/perfetto-00-outline.html-bbf75ddb.js" as="script"><link rel="prefetch" href="/assets/perfetto-01-overview.html-79819234.js" as="script"><link rel="prefetch" href="/assets/perfetto-02-tracing-101.html-dc0f492b.js" as="script"><link rel="prefetch" href="/assets/perfetto-03-quickstart-record-traces-on-android.html-52594d7e.js" as="script"><link rel="prefetch" href="/assets/perfetto-06-quickstart-sql-analysis-and-metrics copy.html-b56f5d13.js" as="script"><link rel="prefetch" href="/assets/perfetto-07-quickstart-trace-conversion copy.html-75aad3d6.js" as="script"><link rel="prefetch" href="/assets/perfetto-08-quickstart-heap-profiling copy.html-54691a11.js" as="script"><link rel="prefetch" href="/assets/perfetto-09-quickstart-callstack-sampling-on-android copy.html-02623a4b.js" as="script"><link rel="prefetch" href="/assets/perfetto-10-faq.html-baa0f253.js" as="script"><link rel="prefetch" href="/assets/perfetto-11-case-stuides-android-boot-tracing.html-e50e4e3c.js" as="script"><link rel="prefetch" href="/assets/perfetto-12-data-sources-debugging-memory-usage.html-daa959e8.js" as="script"><link rel="prefetch" href="/assets/perfetto-13-data-sources-memory-counter-and-events.html-5b5bb1fe.js" as="script"><link rel="prefetch" href="/assets/perfetto-14-data-sources-memory-heap-profiler.html-40ee3b4d.js" as="script"><link rel="prefetch" href="/assets/perfetto-15-data-sources-java-heap-dumps.html-e3705eaa.js" as="script"><link rel="prefetch" href="/assets/perfetto-16-data-sources-cpu-scheduling-events.html-3bcd95f8.js" as="script"><link rel="prefetch" href="/assets/perfetto-17-data-sources-system-calls.html-5577a87d.js" as="script"><link rel="prefetch" href="/assets/perfetto-18-data-sources-cpu-frequency-scaling.html-e8fa6630.js" as="script"><link rel="prefetch" href="/assets/perfetto-21-android-system-android-game-intervention-list.html-97646560.js" as="script"><link rel="prefetch" href="/assets/perfetto-22-data-sources-android-system-atrace-instrumentation.html-488be835.js" as="script"><link rel="prefetch" href="/assets/perfetto-23-data-sources-android-system-android-log.html-ffa51730.js" as="script"><link rel="prefetch" href="/assets/perfetto-24-data-sources-android-system-android-jank.html-8c6ee1ba.js" as="script"><link rel="prefetch" href="/assets/perfetto-25-app-instrumentation-tracing-sdk.html-92489357.js" as="script"><link rel="prefetch" href="/assets/perfetto-28-trace-analysis-trace-processor.html-57d97f08.js" as="script"><link rel="prefetch" href="/assets/perfetto-41-core-concepts-trace-configuration.html-6beb054c.js" as="script"><link rel="prefetch" href="/assets/perfetto-42-core-concepts-buffers-and-dataflow.html-48f22bd4.js" as="script"><link rel="prefetch" href="/assets/perfetto-43-core-concepts-service-model.html-e3a2a664.js" as="script"><link rel="prefetch" href="/assets/fluency-00-outline.html-e0e8bb55.js" as="script"><link rel="prefetch" href="/assets/fluency-01-overview.html-490c0251.js" as="script"><link rel="prefetch" href="/assets/fluency-02-fps.html-cd04c839.js" as="script"><link rel="prefetch" href="/assets/fluency-03-observability-technology.html-375a88ee.js" as="script"><link rel="prefetch" href="/assets/fluency-04-tracing.html-51163c03.js" as="script"><link rel="prefetch" href="/assets/fluency-05-tools-perfetto.html-63a09f67.js" as="script"><link rel="prefetch" href="/assets/fluency-06-tools-android-profiler.html-fd209699.js" as="script"><link rel="prefetch" href="/assets/fluency-07-perfetto-android-overview.html-7c6f44d9.js" as="script"><link rel="prefetch" href="/assets/fluency-08-perfetto-android-graphics-vsync.html-33ca54f2.js" as="script"><link rel="prefetch" href="/assets/index.html-4c1a2191.js" as="script"><link rel="prefetch" href="/assets/native-crash.html-97d208ac.js" as="script"><link rel="prefetch" href="/assets/overview.html-20096d10.js" as="script"><link rel="prefetch" href="/assets/index.html-7f4ac153.js" as="script"><link rel="prefetch" href="/assets/6.006 Introduction To Algorithms.html-b6926431.js" as="script"><link rel="prefetch" href="/assets/6.042J Undergraduate Mathematics For Computer Science.html-4619e1f6.js" as="script"><link rel="prefetch" href="/assets/6.046J Design And Analysis Of Algorithms.html-939c22e5.js" as="script"><link rel="prefetch" href="/assets/6.828 Operating System Engineering.html-5fd979ad.js" as="script"><link rel="prefetch" href="/assets/6.851 Advanced Data Structures.html-96130fb4.js" as="script"><link rel="prefetch" href="/assets/6.854J Advanced Alorithms.html-8a7bd38b.js" as="script"><link rel="prefetch" href="/assets/Lesson-01-A-private-conversation.html-4fabde22.js" as="script"><link rel="prefetch" href="/assets/Lesson-02-Breakfast-or-lunch.html-d3985045.js" as="script"><link rel="prefetch" href="/assets/Lesson-03-Please-send-me-a-card.html-cc4932b1.js" as="script"><link rel="prefetch" href="/assets/Lesson-04-An-exciting-trip.html-6f582222.js" as="script"><link rel="prefetch" href="/assets/Lesson-05-No-Wrong-Numbers.html-29318358.js" as="script"><link rel="prefetch" href="/assets/Lesson-06-Percy-Buttons.html-6a96c684.js" as="script"><link rel="prefetch" href="/assets/Lesson-07-Too-late.html-0c5b2dcb.js" as="script"><link rel="prefetch" href="/assets/Lesson-08-The-best-and-the-worst.html-466c9feb.js" as="script"><link rel="prefetch" href="/assets/Lesson-09-A-cold-welcome.html-372ea3f1.js" as="script"><link rel="prefetch" href="/assets/Lesson-10-Not-For-Jazz.html-77e2369b.js" as="script"><link rel="prefetch" href="/assets/Lesson-11-One-good-turn-deserves-another.html-559a8d1e.js" as="script"><link rel="prefetch" href="/assets/Lesson-12-Goodbye-and-good-luck.html-bbecb5be.js" as="script"><link rel="prefetch" href="/assets/Lesson-13-The-Greenwood-Boys.html-d6b1bbf3.js" as="script"><link rel="prefetch" href="/assets/Lesson-14-Do-you-speak-English.html-8b824f0c.js" as="script"><link rel="prefetch" href="/assets/Lesson-15-Good-news.html-caf22365.js" as="script"><link rel="prefetch" href="/assets/Lesson-16-A-polite-request.html-8bb78e83.js" as="script"><link rel="prefetch" href="/assets/Lesson-17-Always-young.html-15f69b66.js" as="script"><link rel="prefetch" href="/assets/Lesson-18-He-often-does-this.html-ff028797.js" as="script"><link rel="prefetch" href="/assets/Lesson-19-Sold-out.html-348fd40c.js" as="script"><link rel="prefetch" href="/assets/Lesson-20-One-man-in-a-boat.html-db64d74f.js" as="script"><link rel="prefetch" href="/assets/Lesson-21-Mad-or-not.html-069c49d2.js" as="script"><link rel="prefetch" href="/assets/Lesson-22-A-glass-envelope.html-f8b51b7d.js" as="script"><link rel="prefetch" href="/assets/Lesson-23-A-new-house.html-e26e8fc9.js" as="script"><link rel="prefetch" href="/assets/Lesson-24-If-could-be-worse.html-8f9ee0fb.js" as="script"><link rel="prefetch" href="/assets/Lesson-25-Do-the-English-speak-English.html-b70951af.js" as="script"><link rel="prefetch" href="/assets/Lesson-26-The-best-art-critics.html-a39caf41.js" as="script"><link rel="prefetch" href="/assets/Lesson-27-A-wet-night.html-e569b6f8.js" as="script"><link rel="prefetch" href="/assets/Lesson-28-No-parking.html-6f4358b3.js" as="script"><link rel="prefetch" href="/assets/Lesson-29-Taxi.html-8596b1f2.js" as="script"><link rel="prefetch" href="/assets/Lesson-30-Football-or-polo.html-0a915f35.js" as="script"><link rel="prefetch" href="/assets/Lesson-31-Success-story.html-78361cc8.js" as="script"><link rel="prefetch" href="/assets/Lesson-32-Shopping-make-easy.html-ce3bc8ef.js" as="script"><link rel="prefetch" href="/assets/Lesson-33-Out-of-the-darkness.html-a68962f1.js" as="script"><link rel="prefetch" href="/assets/Lesson-34-Quick-work.html-028fafd5.js" as="script"><link rel="prefetch" href="/assets/Lesson-35-Stop-thief.html-3979756d.js" as="script"><link rel="prefetch" href="/assets/Lesson-36-Across-the-Channel.html-7bad183b.js" as="script"><link rel="prefetch" href="/assets/Lesson-37-The-Olympic-Games.html-e75cb258.js" as="script"><link rel="prefetch" href="/assets/Lesson-38-Everything-except-the-weather.html-6ee48d08.js" as="script"><link rel="prefetch" href="/assets/Lesson-39-Am-I-all-right.html-e0c2064d.js" as="script"><link rel="prefetch" href="/assets/Lesson-40-Food-and-talk.html-742a8822.js" as="script"><link rel="prefetch" href="/assets/Lesson-41-Do-you-call-that-a-hat.html-91ead914.js" as="script"><link rel="prefetch" href="/assets/Lesson-42-Not-very-musical.html-88d4fd25.js" as="script"><link rel="prefetch" href="/assets/Lesson-43-Over-the-South-Pole.html-b926c111.js" as="script"><link rel="prefetch" href="/assets/Lesson-44-Through-the-forest.html-52c1a0c9.js" as="script"><link rel="prefetch" href="/assets/Lesson-45-A-clear-conscience.html-0f101d0f.js" as="script"><link rel="prefetch" href="/assets/Lesson-46-Expensive-and-uncomfortable.html-c38b3d04.js" as="script"><link rel="prefetch" href="/assets/Lesson-47-A-thirsty-ghost.html-5f86e940.js" as="script"><link rel="prefetch" href="/assets/Lesson-48-Did-you-want-to-tell-me-something.html-8106d86d.js" as="script"><link rel="prefetch" href="/assets/Lesson-49-The-end-of-a-dream.html-be5f64e8.js" as="script"><link rel="prefetch" href="/assets/Lesson-50-Taken-for-a-ride.html-d83fc6b3.js" as="script"><link rel="prefetch" href="/assets/Lesson-51-Reward-for-virtue.html-a75c4110.js" as="script"><link rel="prefetch" href="/assets/Lesson-52-A-pretty-carpet.html-2a2c98bd.js" as="script"><link rel="prefetch" href="/assets/Lesson-53-Hot-snake.html-df96f98d.js" as="script"><link rel="prefetch" href="/assets/Lesson-54-Sticky-fingers.html-3b8c36ea.js" as="script"><link rel="prefetch" href="/assets/Lesson-55-Not-a-gold-mine.html-9f6a30ee.js" as="script"><link rel="prefetch" href="/assets/Lesson-56-Faster-than-sound.html-b5a1bd79.js" as="script"><link rel="prefetch" href="/assets/Lesson-57-Can-I-help-you_-madam.html-7fd93e15.js" as="script"><link rel="prefetch" href="/assets/Lesson-58-A-blessing-in-disguise.html-772a0dc7.js" as="script"><link rel="prefetch" href="/assets/Lesson-59-In-or-out.html-48f7c0c5.js" as="script"><link rel="prefetch" href="/assets/Lesson-60-The-future.html-e3986962.js" as="script"><link rel="prefetch" href="/assets/Lesson-61-Trouble-with-the-Hubble.html-821a39dc.js" as="script"><link rel="prefetch" href="/assets/Lesson-62-After-the-fire.html-48efcdb6.js" as="script"><link rel="prefetch" href="/assets/Lesson-63-She-was-not-amused.html-51f447aa.js" as="script"><link rel="prefetch" href="/assets/Lesson-64-The-Channel-Tunnel.html-e68e0696.js" as="script"><link rel="prefetch" href="/assets/Lesson-65-Jumbo-versus-the-police.html-081139cf.js" as="script"><link rel="prefetch" href="/assets/Lesson-66-Sweet-as-honey.html-9539c1c8.js" as="script"><link rel="prefetch" href="/assets/Lesson-67-Volcanoes.html-c9d058b4.js" as="script"><link rel="prefetch" href="/assets/Lesson-68-Persistent.html-faa88a38.js" as="script"><link rel="prefetch" href="/assets/Lesson-69-But-not-murder.html-14d850a2.js" as="script"><link rel="prefetch" href="/assets/Lesson-70-Red-for-danger.html-cfccadc0.js" as="script"><link rel="prefetch" href="/assets/Lesson-71-A-famous-clock.html-042dd287.js" as="script"><link rel="prefetch" href="/assets/Lesson-72-A-car-called-bluebird.html-877649b4.js" as="script"><link rel="prefetch" href="/assets/Lesson-73-The-record-holder.html-c9d59762.js" as="script"><link rel="prefetch" href="/assets/Lesson-74-Out-of-the-limelight.html-fd3c62e2.js" as="script"><link rel="prefetch" href="/assets/Lesson-75-SOS.html-8fa8bb7c.js" as="script"><link rel="prefetch" href="/assets/Lesson-76-April-Fools-Day.html-b509e3a3.js" as="script"><link rel="prefetch" href="/assets/Lesson-77-Successful-operation.html-390459c2.js" as="script"><link rel="prefetch" href="/assets/Lesson-78-The-last-one.html-25637688.js" as="script"><link rel="prefetch" href="/assets/Lesson-79-By-air.html-8f22dd45.js" as="script"><link rel="prefetch" href="/assets/Lesson-80-The-Crystal-Palace.html-6c1fa144.js" as="script"><link rel="prefetch" href="/assets/Lesson-81-Escape.html-82075314.js" as="script"><link rel="prefetch" href="/assets/Lesson-82-Monster-or-fish.html-22cf6f94.js" as="script"><link rel="prefetch" href="/assets/Lesson-83-After-the-elections.html-23e823f5.js" as="script"><link rel="prefetch" href="/assets/Lesson-84-On-strike.html-774654ba.js" as="script"><link rel="prefetch" href="/assets/Lesson-85-Never-too-old-to-learn.html-2c92ff10.js" as="script"><link rel="prefetch" href="/assets/Lesson-86-Out-of-control.html-9886df03.js" as="script"><link rel="prefetch" href="/assets/Lesson-87-A-perfect-alibi.html-9115e967.js" as="script"><link rel="prefetch" href="/assets/Lesson-88-Trapped-in-a-mine.html-a6b454c5.js" as="script"><link rel="prefetch" href="/assets/Lesson-89-A-slip-of-the-tongue.html-ad14b7a1.js" as="script"><link rel="prefetch" href="/assets/Lesson-90-What-is-for-supper.html-1e41b5af.js" as="script"><link rel="prefetch" href="/assets/Lesson-91-Three-men-in-a-basket.html-81ab150b.js" as="script"><link rel="prefetch" href="/assets/Lesson-92-Asking-for-trouble.html-e465ca81.js" as="script"><link rel="prefetch" href="/assets/Lesson-93-A-noble-gift.html-7214ba32.js" as="script"><link rel="prefetch" href="/assets/Lesson-94-Future-champions.html-31de55cd.js" as="script"><link rel="prefetch" href="/assets/Lesson-95-A-fantasy.html-e788c659.js" as="script"><link rel="prefetch" href="/assets/Lesson-96-The-dead-return.html-e10b1a7d.js" as="script"><link rel="prefetch" href="/assets/404.html-fcd8d78c.js" as="script"><link rel="prefetch" href="/assets/index.html-64357d2d.js" as="script"><link rel="prefetch" href="/assets/index.html-13a88a83.js" as="script"><link rel="prefetch" href="/assets/index.html-24a580b0.js" as="script"><link rel="prefetch" href="/assets/index.html-f7f858d7.js" as="script"><link rel="prefetch" href="/assets/index.html-160ed3bd.js" as="script"><link rel="prefetch" href="/assets/index.html-77bf936d.js" as="script"><link rel="prefetch" href="/assets/index.html-1969dbf6.js" as="script"><link rel="prefetch" href="/assets/index.html-1b890be5.js" as="script"><link rel="prefetch" href="/assets/index.html-d7de265f.js" as="script"><link rel="prefetch" href="/assets/index.html-466a3f1e.js" as="script"><link rel="prefetch" href="/assets/index.html-249bedd3.js" as="script"><link rel="prefetch" href="/assets/index.html-1fcd1520.js" as="script"><link rel="prefetch" href="/assets/index.html-d318f831.js" as="script"><link rel="prefetch" href="/assets/index.html-3f044536.js" as="script"><link rel="prefetch" href="/assets/index.html-1328e642.js" as="script"><link rel="prefetch" href="/assets/index.html-8d91fbf8.js" as="script"><link rel="prefetch" href="/assets/index.html-0cf489c2.js" as="script"><link rel="prefetch" href="/assets/index.html-33736a30.js" as="script"><link rel="prefetch" href="/assets/index.html-58203542.js" as="script"><link rel="prefetch" href="/assets/index.html-4e8444cd.js" as="script"><link rel="prefetch" href="/assets/index.html-d968eee7.js" as="script"><link rel="prefetch" href="/assets/index.html-cf4d74db.js" as="script"><link rel="prefetch" href="/assets/index.html-013e8049.js" as="script"><link rel="prefetch" href="/assets/index.html-edb2ef5f.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-381f4bbc.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container no-sidebar has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/images/favicon-32x32.png" alt="biezhihua的日常"><!----><span class="site-name hide-in-pad">biezhihua的日常</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="LeetCode"><span class="title"><!---->LeetCode</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/learn-leetcode/" class="nav-link" aria-label="学习大纲"><!---->学习大纲<!----></a></li><li class="dropdown-item"><a href="/learn-leetcode/Algorithms-analysis.html" class="nav-link" aria-label="算法分析"><!---->算法分析<!----></a></li><li class="dropdown-item"><a href="/learn-leetcode/Algorithms-thinking.html" class="nav-link" aria-label="算法思想"><!---->算法思想<!----></a></li><li class="dropdown-item"><a href="/learn-leetcode/Algorithms.html" class="nav-link" aria-label="算法"><!---->算法<!----></a></li><li class="dropdown-item"><a href="/learn-leetcode/Data-structure.html" class="nav-link" aria-label="数据结构"><!---->数据结构<!----></a></li><li class="dropdown-item"><a href="/learn-leetcode/Algorithms-math-base.html" class="nav-link" aria-label="数学基础"><!---->数学基础<!----></a></li><li class="dropdown-item"><a href="/learn-leetcode/Algorithms-apply.html" class="nav-link" aria-label="算法应用"><!---->算法应用<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="English"><span class="title"><!---->English</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/learn-english/" class="nav-link" aria-label="学习大纲"><!---->学习大纲<!----></a></li><li class="dropdown-item"><a href="/learn-english/NCE/" class="nav-link" aria-label="新概念"><!---->新概念<!----></a></li><li class="dropdown-item"><a href="/learn-english/difficult-sentence.html" class="nav-link" aria-label="疑难句分析"><!---->疑难句分析<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/about-me.html" class="nav-link" aria-label="AboutMe"><!---->AboutMe<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><!----><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Android | AOSP | SurfaceFlinger模块-VSYNC研究 | 转载&amp;加工</h1><div class="page-info"><!----><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-05-14T15:05:06.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 55 分钟</span><meta property="timeRequired" content="PT55M"></span><!----><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><span class="page-tag-item tag3 clickable" role="navigation">android</span><span class="page-tag-item tag2 clickable" role="navigation">aosp</span><meta property="keywords" content="android,aosp"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#前言1" class="router-link-active router-link-exact-active toc-link level2">前言1</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#前言2" class="router-link-active router-link-exact-active toc-link level2">前言2</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#导读" class="router-link-active router-link-exact-active toc-link level2">导读</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#vsync-信号" class="router-link-active router-link-exact-active toc-link level2">VSYNC 信号</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#硬件-vsync-和软件-vsync" class="router-link-active router-link-exact-active toc-link level3">硬件 VSYNC 和软件 VSYNC</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#与vsync相关的线程" class="router-link-active router-link-exact-active toc-link level3">与VSYNC相关的线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#vsync-信号从哪里开始初始化的" class="router-link-active router-link-exact-active toc-link level3">VSYNC 信号从哪里开始初始化的？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#vsync-sf-与-vsync-app-的申请与投递" class="router-link-active router-link-exact-active toc-link level2">VSYNC-sf 与 VSYNC-app 的申请与投递</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#vsyncdispatch-初始化" class="router-link-active router-link-exact-active toc-link level3">VsyncDispatch 初始化</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#sf-向-vsyncdispatch-注册与回调的过程" class="router-link-active router-link-exact-active toc-link level3">SF 向 VsyncDispatch 注册与回调的过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#dispsyncsource-是-vsyncdispatch-与-eventthread-之间的桥梁" class="router-link-active router-link-exact-active toc-link level3">DispSyncSource 是 VsyncDispatch 与 EventThread 之间的桥梁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#app-向-eventthread-注册-connection" class="router-link-active router-link-exact-active toc-link level3">App 向 EventThread 注册 Connection</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#vsync-sf-的申请" class="router-link-active router-link-exact-active toc-link level2">VSYNC-sf 的申请</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#scheduleframe" class="router-link-active router-link-exact-active toc-link level3">scheduleFrame</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#schedule" class="router-link-active router-link-exact-active toc-link level3">schedule</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#vsync-sf-产生和发射" class="router-link-active router-link-exact-active toc-link level2">VSYNC-sf 产生和发射</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#vsync-app-的申请和发射" class="router-link-active router-link-exact-active toc-link level2">VSYNC-app 的申请和发射</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#应用向-surfaceflinger-注册-connection" class="router-link-active router-link-exact-active toc-link level3">应用向 Surfaceflinger 注册 connection</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#vsync-app-的申请" class="router-link-active router-link-exact-active toc-link level3">VSYNC-app 的申请</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#vsync-app-的发射" class="router-link-active router-link-exact-active toc-link level3">VSYNC-app 的发射</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#sw-vsync-模型和校准" class="router-link-active router-link-exact-active toc-link level2">SW VSYNC 模型和校准</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#resynctohardwarevsync" class="router-link-active router-link-exact-active toc-link level3">resyncToHardwareVsync</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#sw-vsync模型更新与校准" class="router-link-active router-link-exact-active toc-link level3">SW VSYNC模型更新与校准</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#dumpsys-surfaceflinger" class="router-link-active router-link-exact-active toc-link level2">dumpsys SurfaceFlinger</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/learn-android/aosp/surfaceflinger-vsync.html#reference" class="router-link-active router-link-exact-active toc-link level2">Reference</a></li><!----><!--]--></ul></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h1 id="android-aosp-surfaceflinger模块-vsync研究-转载-加工" tabindex="-1"><a class="header-anchor" href="#android-aosp-surfaceflinger模块-vsync研究-转载-加工" aria-hidden="true">#</a> Android | AOSP | SurfaceFlinger模块-VSYNC研究 | 转载&amp;加工</h1><h2 id="前言1" tabindex="-1"><a class="header-anchor" href="#前言1" aria-hidden="true">#</a> 前言1</h2><p>转载自：<a href="https://www.jianshu.com/p/5e9c558d1543" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/5e9c558d1543<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> ，并结合Perfetto更新了部分内容。</p><h2 id="前言2" tabindex="-1"><a class="header-anchor" href="#前言2" aria-hidden="true">#</a> 前言2</h2><p>源码版本：android-13.0.0_r41</p><h2 id="导读" tabindex="-1"><a class="header-anchor" href="#导读" aria-hidden="true">#</a> 导读</h2><p>Vsync 信号是 SurfaceFlinger 进程中核心的一块逻辑，我们主要从以下几个方面着手讲解。</p><ul><li>软件Vsync是怎么实现的，它是如何保持有效性的？</li><li>Perfetto 中看到的 VSYNC 信号如何解读，这些脉冲信号是在哪里打印的？</li><li>为什么 VSYNC-sf / VSYNC-app 时断时续？</li><li>SF 请求 VSYNC-SF 信号进行合成的流程是怎样的？</li><li>“dumpsys SurfaceFlinger --dispsync&quot;命令输出如何解读？</li></ul><p><img src="/learn-android/aosp/surfaceflinger-vsync-6.png" alt=""></p><h2 id="vsync-信号" tabindex="-1"><a class="header-anchor" href="#vsync-信号" aria-hidden="true">#</a> VSYNC 信号</h2><p>当前手机屏幕显示屏大部分都是60Hz（也有一部分是90Hz/120Hz/165Hz），意味着显示屏每隔16.66毫秒刷新一次，如果在显示屏刷新时刻去更新显示的内容，就会导致屏幕撕裂（其中还有掉帧问题，就是连续的两个刷新周期，显示屏只能显示同一帧图像，具体请查询Android黄油计划），为了避免这种情况，我们在显示屏幕两次刷新之间的空档期去更新显示内容，当可以安全的更新内容时，系统会收到显示屏发来的信号，处于历史原因，我们称之为VSYNC信号。</p><h3 id="硬件-vsync-和软件-vsync" tabindex="-1"><a class="header-anchor" href="#硬件-vsync-和软件-vsync" aria-hidden="true">#</a> 硬件 VSYNC 和软件 VSYNC</h3><p>通过 Perfetto 来认识VSYNC</p><p><img src="/learn-android/aosp/surfaceflinger-vsync-1.png" alt=""></p><ul><li><p>因为我们只有一个显示屏，所以只有一个硬件 VSYNC，即 HW_VSYNC。HW_VSYNC_{displayid} 脉冲的宽度是16ms，因此显示屏的帧率是60Hz。</p></li><li><p>HW_VSYNC_ON_{displayid} 表示硬件 VSYNC 是否打开。可见硬件VSYNC大部分时间是关闭的，只有在特殊场景下才会打开（比如更新 SW VSYNC 模型的时候），displayId 是在 sf 中标识这个显示屏的唯一字符串。</p></li><li><p>App 的绘制以及 SF 的合成分别由对应的软件 VSYNC 来驱动的：VSYNC-app 驱动 App 进行绘制；VSYNC-sf 驱动 SF 对相关的 Layer 进行合成。</p></li><li><p>VSYNC-app 与 VSYNC-sf 是 <strong>“按需发射”</strong> 的，如果 App 要更新界面，它得“申请” VSYNC-app ，如果没有 App 申请 VSYNC-app ，那么 VSYNC-app 将不再发射。同样，当 App 更新了界面，它会把对应的 Graphic Buffer 放到 Buffer Queue 中。Buffer Queue 通知 SF 进行合成，此时 SF 会申请 VSYNC-sf 。如果 SF 不再申请 VSYNC-sf ，VSYNC-sf 将不再发射。注意，默认情况下这些申请都是一次性的，意味着，如果 App 要持续不断的更新，它就得不断去申请 VSYNC-app ；而对 SF 来说，只要有合成任务，它就得再去申请 VSYNC-sf。</p></li><li><p>VSYNC-app 与 VSYNC-sf 是相互独立的。VSYNC-app 触发 App 的绘制，Vsync-sf 触发 SF 合成。App 绘制与 SF 合成都会加大 CPU 的负载，为了避免绘制与合成打架造成的性能问题，VSYNC-app 可以与 VSYNC-sf 稍微错开一下，像下图一样：</p></li></ul><p><img src="/learn-android/aosp/surfaceflinger-vsync-2.png" alt=""></p><ul><li>从我们抓的 Perfetto 中也可看到这种偏移，但是要注意： Perfetto 中 VSYNC 脉冲，上升沿与下降沿各是一次 VSYNC 信号。这里的高、低电平只是一种示意，如果要查看 VSYNC-app 与 VSYNC-sf 的偏移，不能错误的以为“同是上升沿或者同是下降沿进行比对”。忘记上升沿或者下降沿吧，只需拿两个人相邻的 VSYNC 信号进行比对。如下图所示，VSYNC-app 领先 VSYNC-sf 有85微秒。不过要注意，这个85微秒只是软件误差，算不得数，在我们的系统中，VSYNC-app 与 VSYNC-sf 并没有错开。有必要再补充下：SF 进行合成的是 App 的上一帧，而 App 当前正在绘制的那一帧，要等到下一个 VSYNC-sf 来临时再进行合成。</li></ul><h3 id="与vsync相关的线程" tabindex="-1"><a class="header-anchor" href="#与vsync相关的线程" aria-hidden="true">#</a> 与VSYNC相关的线程</h3><ul><li><p>TimerDispatch 线程：TimerDispatch 充当软件 VSYNC 的信号泵，这个线程包装成 VsyncDispatchTimeQueue 这个类，里面有一个 Callback Map 变量，存放的是那些关心 VSYNC 信号的人（appEventThread, appSfEventThread, sf的MessageQueue），TimerDispatch 就是根据模型计算的唤醒时间对着它们发送 SW VSYNC。</p></li><li><p>appEventThread 线程：它是 EventThread 类型的实例，它是 VSYNC-app 寄宿的线程。很明显，它就是 VSYNC-app 的掌门人。一方面，它接收 App 对 VSYNC-app 的请求，如果没有 App 请求 VSYNC-app，它就进入休眠；另一方面，它接收 TimerDispatch 发射过来 VSYNC-app，控制 App 的绘制。</p></li><li><p>appSfEventThread 线程：它是 EventThread 类型的实例，它是 VSYNC-appSf 寄宿的线程，和 appEventThread 线程功能是类似的，用于调试代码，暂时忽略。</p></li><li><p>MessageQueue（表示主线程）： 它是 VSYNC-sf 寄宿的线程，很明显，它就是 VSYNC-sf 的掌门人，不过它专给 SF 一个人服务。一方面，如果 SF 有合成需求，会向它提出申请；另一方面，它接收 TimerDispatch 发射过来的 VSYNC-sf，控制 SF 的合成。</p></li></ul><p>HW VSYNC/SW VSYNC/VSYNC/VSYNC-app与VSYNC-SF的关联可以用一个PLL图来表示：</p><p><img src="/learn-android/aosp/surfaceflinger-vsync-3.png" alt=""></p><h3 id="vsync-信号从哪里开始初始化的" tabindex="-1"><a class="header-anchor" href="#vsync-信号从哪里开始初始化的" aria-hidden="true">#</a> VSYNC 信号从哪里开始初始化的？</h3><p>因为 Android 大版本每次更新，SurfaceFlinger 模块都要进行代码重构，所以我们就从 Android 13 代码的源头开始讲起。</p><p>我们在讲解 SurfaceFlinger::init 方法的时候，init 会去初始化 HWComposer 并注册回调函数，如下：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/surfaceflinger.rc

service surfaceflinger /system/bin/surfaceflinger
    class core animation
    user system
    group graphics drmrpc readproc
    capabilities SYS_NICE
    onrestart restart --only-if-running zygote
    task_profiles HighPerformance
    socket pdx/system/vr/display/client     stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0
    socket pdx/system/vr/display/manager    stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0
    socket pdx/system/vr/display/vsync      stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp
int main(int, char**) {
    signal(SIGPIPE, SIG_IGN);
    
    ...
    
    // instantiate surfaceflinger
    sp&lt;SurfaceFlinger&gt; flinger = surfaceflinger::createSurfaceFlinger();

    ...

    // initialize before clients can connect
    flinger-&gt;init();

    // publish surface flinger
    sp&lt;IServiceManager&gt; sm(defaultServiceManager());
    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, false,
                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);

    // publish gui::ISurfaceComposer, the new AIDL interface
    sp&lt;SurfaceComposerAIDL&gt; composerAIDL = new SurfaceComposerAIDL(flinger);
    sm-&gt;addService(String16(&quot;SurfaceFlingerAIDL&quot;), composerAIDL, false,
                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);

    startDisplayService(); // dependency on SF getting registered above

    ...

    // run surface flinger in this thread
    flinger-&gt;run();

    return 0;
}

frameworks/native/services/surfaceflinger/SurfaceFlingerFactory.cpp
sp&lt;SurfaceFlinger&gt; createSurfaceFlinger() {
    static DefaultFactory factory;

    return new SurfaceFlinger(factory);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在讲解 SurfaceFlinger::init 方法的时候，init 会去初始化 HWComposer 并注册回调函数，如下：</p><div class="language-C++ line-numbers-mode" data-ext="C++"><pre class="language-C++"><code>frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
// Do not call property_set on main thread which will be blocked by init
// Use StartPropertySetThread instead.
void SurfaceFlinger::init() {
    ...

    mCompositionEngine-&gt;setTimeStats(mTimeStats);
    mCompositionEngine-&gt;setHwComposer(getFactory().createHWComposer(mHwcServiceName));
    mCompositionEngine-&gt;getHwComposer().setCallback(*this);

    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>创建一个 HWComposer 对象并传入一个 name 属性，再把该对象设置到m CompositionEngine 中。</li><li>这里的 this 就是 SurfaceFlinger 本身，它实现了 HWC2::ComposerCallback 回调方法。</li></ul><p>定义 ComposerCallback 回调方法:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.h
struct ComposerCallback {
    virtual void onComposerHalHotplug(hal::HWDisplayId, hal::Connection) = 0;
    virtual void onComposerHalRefresh(hal::HWDisplayId) = 0;
    virtual void onComposerHalVsync(hal::HWDisplayId, int64_t timestamp,
                                    std::optional&lt;hal::VsyncPeriodNanos&gt;) = 0;
    virtual void onComposerHalVsyncPeriodTimingChanged(hal::HWDisplayId,
                                                       const hal::VsyncPeriodChangeTimeline&amp;) = 0;
    virtual void onComposerHalSeamlessPossible(hal::HWDisplayId) = 0;
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据 HWC2::ComposerCallback 的设计逻辑，SurfaceFlinger::init 方法中设置完 HWC 的回调之后，会立刻收到一个 Hotplug 事件，并在 SurfaceFlinger::onComposerHalHotplug 中去处理，所以流程就走到了：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
void SurfaceFlinger::onComposerHalHotplug(hal::HWDisplayId hwcDisplayId, hal::Connection connection) {
  ...
    if (std::this_thread::get_id() == mMainThreadId) {
        // Process all pending hot plug events immediately if we are on the main thread.
        processDisplayHotplugEventsLocked();
    }
  ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>继续分析 processDisplayHotplugEventsLocked 的方法</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
void SurfaceFlinger::processDisplayHotplugEventsLocked() {
    for (const auto&amp; event : mPendingHotplugEvents) {

        ...

        processDisplayChangesLocked();
    }

    mPendingHotplugEvents.clear();
}


void SurfaceFlinger::processDisplayChangesLocked() {
    ...

    if (!curr.isIdenticalTo(draw)) {
        mVisibleRegionsDirty = true;

        ....

        // find displays that were added
        // (ie: in current state but not in drawing state)
        for (size_t i = 0; i &lt; curr.size(); i++) {
            const wp&lt;IBinder&gt;&amp; displayToken = curr.keyAt(i);
            if (draw.indexOfKey(displayToken) &lt; 0) {
                processDisplayAdded(displayToken, curr[i]);
            }
        }
    }

   ...
}

oid SurfaceFlinger::processDisplayAdded(const wp&lt;IBinder&gt;&amp; displayToken,
                                         const DisplayDeviceState&amp; state) {
    ...

    auto display = setupNewDisplayDeviceInternal(displayToken, std::move(compositionDisplay), state,
                                                 displaySurface, producer);
    if (display-&gt;isPrimary()) {
        initScheduler(display);
    }

    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>就会走到了 initScheduler 方法，这个方法就是初始化VSYNC信号的函数。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp

void SurfaceFlinger::initScheduler(const sp&lt;DisplayDevice&gt;&amp; display) {
    if (mScheduler) {
        // If the scheduler is already initialized, this means that we received
        // a hotplug(connected) on the primary display. In that case we should
        // update the scheduler with the most recent display information.
        ALOGW(&quot;Scheduler already initialized, updating instead&quot;);
        mScheduler-&gt;setRefreshRateConfigs(display-&gt;holdRefreshRateConfigs());
        return;
    }
    const auto currRefreshRate = display-&gt;getActiveMode()-&gt;getFps();
    mRefreshRateStats = std::make_unique&lt;scheduler::RefreshRateStats&gt;(*mTimeStats, currRefreshRate,
                                                                      hal::PowerMode::OFF);

    mVsyncConfiguration = getFactory().createVsyncConfiguration(currRefreshRate);
    mVsyncModulator = sp&lt;VsyncModulator&gt;::make(mVsyncConfiguration-&gt;getCurrentConfigs());

    using Feature = scheduler::Feature;
    scheduler::FeatureFlags features;

    if (sysprop::use_content_detection_for_refresh_rate(false)) {
        features |= Feature::kContentDetection;
    }
    if (base::GetBoolProperty(&quot;debug.sf.show_predicted_vsync&quot;s, false)) {
        features |= Feature::kTracePredictedVsync;
    }
    if (!base::GetBoolProperty(&quot;debug.sf.vsync_reactor_ignore_present_fences&quot;s, false) &amp;&amp;
        !getHwComposer().hasCapability(Capability::PRESENT_FENCE_IS_NOT_RELIABLE)) {
        features |= Feature::kPresentFences;
    }

    mScheduler = std::make_unique&lt;scheduler::Scheduler&gt;(static_cast&lt;ICompositor&amp;&gt;(*this),
                                                        static_cast&lt;ISchedulerCallback&amp;&gt;(*this),
                                                        features);
    {
        auto configs = display-&gt;holdRefreshRateConfigs();
        if (configs-&gt;kernelIdleTimerController().has_value()) {
            features |= Feature::kKernelIdleTimer;
        }

        mScheduler-&gt;createVsyncSchedule(features);
        mScheduler-&gt;setRefreshRateConfigs(std::move(configs));
    }
    setVsyncEnabled(false);
    mScheduler-&gt;startTimers();

    const auto configs = mVsyncConfiguration-&gt;getCurrentConfigs();
    const nsecs_t vsyncPeriod = currRefreshRate.getPeriodNsecs();
    mAppConnectionHandle =
            mScheduler-&gt;createConnection(&quot;app&quot;, mFrameTimeline-&gt;getTokenManager(),
                                         /*workDuration=*/configs.late.appWorkDuration,
                                         /*readyDuration=*/configs.late.sfWorkDuration,
                                         impl::EventThread::InterceptVSyncsCallback());
    mSfConnectionHandle =
            mScheduler-&gt;createConnection(&quot;appSf&quot;, mFrameTimeline-&gt;getTokenManager(),
                                         /*workDuration=*/std::chrono::nanoseconds(vsyncPeriod),
                                         /*readyDuration=*/configs.late.sfWorkDuration,
                                         [this](nsecs_t timestamp) {
                                             mInterceptor-&gt;saveVSyncEvent(timestamp);
                                         });

    mScheduler-&gt;initVsync(mScheduler-&gt;getVsyncDispatch(), *mFrameTimeline-&gt;getTokenManager(),
                          configs.late.sfWorkDuration);

    mRegionSamplingThread =
            new RegionSamplingThread(*this, RegionSamplingThread::EnvironmentTimingTunables());
    mFpsReporter = new FpsReporter(*mFrameTimeline, *this);
    // Dispatch a mode change request for the primary display on scheduler
    // initialization, so that the EventThreads always contain a reference to a
    // prior configuration.
    //
    // This is a bit hacky, but this avoids a back-pointer into the main SF
    // classes from EventThread, and there should be no run-time binder cost
    // anyway since there are no connected apps at this point.
    mScheduler-&gt;onPrimaryDisplayModeChanged(mAppConnectionHandle, display-&gt;getActiveMode());
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>先判断 mScheduler 是否为空，避免重复初始化。</p></li><li><p>初始化 mRefreshRateConfigs 对象，这个对象包含了刷新率的配置信息，包含当前屏幕的刷新率，刷新周期等信息。</p></li><li><p>currRefreshRate 是一个 Fps 对象，其中存储了刷新率fps和刷新周期period。</p></li></ul><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/include/scheduler/Fps.h
// Frames per second, stored as floating-point frequency. Provides conversion from/to period in
// nanoseconds, and relational operators with precision threshold.
//
//     const Fps fps = 60_Hz;
//
//     using namespace fps_approx_ops;
//     assert(fps == Fps::fromPeriodNsecs(16&#39;666&#39;667));
//
class Fps {
    ...
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>初始化 mVsyncConfiguration 对象，这个类封装了不同刷新率下的 Vsync 配置信息，vsyncPhaseOffsetNs 就是 VSYNC-app 的偏移量，sfVSyncPhaseOffsetNs 是 VSYNC-sf 的偏移量。这个类会再创建 appEventThread 或者 sf 的回调函数中把偏移量传递进去，主要是为了计 算SW VSYNC 唤醒 VSYNC-app 或者 VSYNC-sf 的时间，这个类可以通过属性进行配置，代码实现中也固定了部分参数。</li></ul><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/SurfaceFlingerDefaultFactory.cpp
std::unique_ptr&lt;scheduler::VsyncConfiguration&gt; DefaultFactory::createVsyncConfiguration(
        Fps currentRefreshRate) {
    if (property_get_bool(&quot;debug.sf.use_phase_offsets_as_durations&quot;, false)) {
        return std::make_unique&lt;scheduler::impl::WorkDuration&gt;(currentRefreshRate);
    } else {
        return std::make_unique&lt;scheduler::impl::PhaseOffsets&gt;(currentRefreshRate);
    }
}

frameworks/native/services/surfaceflinger/Scheduler/VsyncConfiguration.cpp
PhaseOffsets::PhaseOffsets(Fps currentRefreshRate)
      : PhaseOffsets(currentRefreshRate, sysprop::vsync_event_phase_offset_ns(1000000),
                     sysprop::vsync_sf_event_phase_offset_ns(1000000),
                     ...) {}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>初始化 Scheduler 对象 mScheduler，这个类的构造函数中，初始化了 VsyncSchedule 这个结构体，该结构体里面的三个对象都非常重要，dispatch 就是 TimerDispatcher 的线程，也就是 VSYNC 信号的节拍器（心跳），其他两个对象是为 dispatch 服务的。</li></ul><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
class Scheduler : impl::MessageQueue {
    using Impl = impl::MessageQueue;

    std::optional&lt;VsyncSchedule&gt; mVsyncSchedule;
}

frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
void Scheduler::createVsyncSchedule(FeatureFlags features) {
    mVsyncSchedule.emplace(features);
}

frameworks/native/services/surfaceflinger/Scheduler/VsyncSchedule.h
// Schedule that synchronizes to hardware VSYNC of a physical display.
class VsyncSchedule {
    TrackerPtr mTracker;
    DispatchPtr mDispatch;
    ControllerPtr mController;
    TracerPtr mTracer;
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>创建 appEventThread 和 appSfEventThread ， appEventThread/appSfEventThread 就是上面说的这个线程，同步绑定回调函数到 VsyncDispatch 上面，名字是 &quot;app&quot;,&quot;appSf&quot;,&quot;sf&quot;。</li></ul><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void SurfaceFlinger::initScheduler(const sp&lt;DisplayDevice&gt;&amp; display) {
    ...

    mAppConnectionHandle =
            mScheduler-&gt;createConnection(&quot;app&quot;, mFrameTimeline-&gt;getTokenManager(),
                                         /*workDuration=*/configs.late.appWorkDuration,
                                         /*readyDuration=*/configs.late.sfWorkDuration,
                                         impl::EventThread::InterceptVSyncsCallback());
    mSfConnectionHandle =
            mScheduler-&gt;createConnection(&quot;appSf&quot;, mFrameTimeline-&gt;getTokenManager(),
                                         /*workDuration=*/std::chrono::nanoseconds(vsyncPeriod),
                                         /*readyDuration=*/configs.late.sfWorkDuration,
                                         [this](nsecs_t timestamp) {
                                             mInterceptor-&gt;saveVSyncEvent(timestamp);
                                         });

    mScheduler-&gt;initVsync(mScheduler-&gt;getVsyncDispatch(), *mFrameTimeline-&gt;getTokenManager(),
                          configs.late.sfWorkDuration);

    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>mEventQueue 的 initVsync 方法主要是绑定一个回调函数到VsyncDispatch 上面，回调名字是 &quot;sf&quot;。</li></ul><p>那么从上面的代码逻辑中，我们可以知道节拍器线程（心跳）一共绑定了3个 Callback，分别是 &quot;app&quot; , &quot;appSf&quot; , &quot;sf&quot;。</p><h2 id="vsync-sf-与-vsync-app-的申请与投递" tabindex="-1"><a class="header-anchor" href="#vsync-sf-与-vsync-app-的申请与投递" aria-hidden="true">#</a> VSYNC-sf 与 VSYNC-app 的申请与投递</h2><p>先看看通道的建立过程，也是从源代码开始看起。</p><h3 id="vsyncdispatch-初始化" tabindex="-1"><a class="header-anchor" href="#vsyncdispatch-初始化" aria-hidden="true">#</a> VsyncDispatch 初始化</h3><p>我们知道 VsyncDispatch 是节拍器（心跳），也就是 TimerDispatch 的线程所在，所以我们需要了解下 VsyncDispatch 是在什么时候初始化的？在前面 Vsync 信号初始化的逻辑中，我们了解到 Scheduler 类再构造方法中会创建 VsyncDispatch 对象，而这个对象也就是 SurfaceFlinger 系统中唯一的，相关代码如下：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
void SurfaceFlinger::initScheduler(const sp&lt;DisplayDevice&gt;&amp; display) {
    i...

    mScheduler = std::make_unique&lt;scheduler::Scheduler&gt;(static_cast&lt;ICompositor&amp;&gt;(*this),
                                                        static_cast&lt;ISchedulerCallback&amp;&gt;(*this),
                                                        features);
    {
        ...

        mScheduler-&gt;createVsyncSchedule(features);

        ...
    }
    s...
}

frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
void Scheduler::createVsyncSchedule(FeatureFlags features) {
    //  https://en.cppreference.com/w/cpp/utility/optional/emplace
    mVsyncSchedule.emplace(features);
}

frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
// Schedule that synchronizes to hardware VSYNC of a physical display.
class VsyncSchedule {
    ...
};

frameworks/native/services/surfaceflinger/Scheduler/VsyncSchedule.cpp
VsyncSchedule::VsyncSchedule(FeatureFlags features)
      : mTracker(createTracker()),
        mDispatch(createDispatch(*mTracker)),
        mController(createController(*mTracker, features)) {
    ...
}

frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
VsyncSchedule::TrackerPtr VsyncSchedule::createTracker() {
    // TODO(b/144707443): Tune constants.
    constexpr nsecs_t kInitialPeriod = (60_Hz).getPeriodNsecs();
    constexpr size_t kHistorySize = 20;
    constexpr size_t kMinSamplesForPrediction = 6;
    constexpr uint32_t kDiscardOutlierPercent = 20;

    return std::make_unique&lt;VSyncPredictor&gt;(kInitialPeriod, kHistorySize, kMinSamplesForPrediction,
                                            kDiscardOutlierPercent);
}

frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
VsyncSchedule::DispatchPtr VsyncSchedule::createDispatch(VsyncTracker&amp; tracker) {
    using namespace std::chrono_literals;

    // TODO(b/144707443): Tune constants.
    constexpr std::chrono::nanoseconds kGroupDispatchWithin = 500us;
    constexpr std::chrono::nanoseconds kSnapToSameVsyncWithin = 3ms;

    return std::make_unique&lt;VSyncDispatchTimerQueue&gt;(std::make_unique&lt;Timer&gt;(), tracker,
                                                     kGroupDispatchWithin.count(),
                                                     kSnapToSameVsyncWithin.count());
}

frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
VsyncSchedule::ControllerPtr VsyncSchedule::createController(VsyncTracker&amp; tracker,
                                                             FeatureFlags features) {
    // TODO(b/144707443): Tune constants.
    constexpr size_t kMaxPendingFences = 20;
    const bool hasKernelIdleTimer = features.test(Feature::kKernelIdleTimer);

    auto reactor = std::make_unique&lt;VSyncReactor&gt;(std::make_unique&lt;SystemClock&gt;(), tracker,
                                                  kMaxPendingFences, hasKernelIdleTimer);

    reactor-&gt;setIgnorePresentFences(!features.test(Feature::kPresentFences));
    return reactor;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从该方法可以看出，Scheduler 对象初始化的时候，会间接的构造出 VsyncDispatchTimerQueue 对象，这个时候有小伙伴就疑问怎么不是 VsyncDispatch 对象呢？</p><p>这边我们把这几个类图的关系画出来，如下：</p><p><img src="/learn-android/aosp/surfaceflinger-vsync-4.png" alt=""></p><p>VsyncDispatchTimerQueue 是继承 VsyncDispatch，而节拍器（心跳）线程也就是该对象中的 mTimeKeeper，这个 Timer.cpp 中会创建 TimerDispatch 这个名字的线程。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>
frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.h
/*
 * VSyncDispatchTimerQueue is a class that will dispatch callbacks as per VSyncDispatch interface
 * using a single timer queue.
 */
class VSyncDispatchTimerQueue : public VSyncDispatch {
    ...
};


frameworks/native/services/surfaceflinger/Scheduler/include/scheduler/Timer.h
class Timer : public TimeKeeper {
public:
    Timer();
    ~Timer();

    nsecs_t now() const final;

    void alarmAt(std::function&lt;void()&gt;, nsecs_t time) final;
    void alarmCancel() final;

private:
    void threadMain();
    bool dispatch();
    void endDispatch();
};

frameworks/native/services/surfaceflinger/Scheduler/include/scheduler/Timer.cpp
Timer::Timer() {
    reset();
    mDispatchThread = std::thread([this]() { threadMain(); });
}

void Timer::reset() {
    std::function&lt;void()&gt; cb;
    {
        std::lock_guard lock(mMutex);
        if (mExpectingCallback &amp;&amp; mCallback) {
            cb = mCallback;
        }

        cleanup();
        mTimerFd = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC | TFD_NONBLOCK);
        mEpollFd = epoll_create1(EPOLL_CLOEXEC);
       ...
    }
    ...
}

void Timer::threadMain() {
    while (dispatch()) {
        reset();
    }
}

void Timer::alarmAt(std::function&lt;void()&gt; callback, nsecs_t time) {
    std::lock_guard lock(mMutex);
    using namespace std::literals;
    static constexpr int ns_per_s =
            std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(1s).count();

    mCallback = std::move(callback);
    mExpectingCallback = true;

    struct itimerspec old_timer;
    struct itimerspec new_timer {
        .it_interval = {.tv_sec = 0, .tv_nsec = 0},
        .it_value = {.tv_sec = static_cast&lt;long&gt;(time / ns_per_s),
                     .tv_nsec = static_cast&lt;long&gt;(time % ns_per_s)},
    };

    if (timerfd_settime(mTimerFd, TFD_TIMER_ABSTIME, &amp;new_timer, &amp;old_timer)) {
        ALOGW(&quot;Failed to set timerfd %s (%i)&quot;, strerror(errno), errno);
    }
}


bool Timer::dispatch() {
    ...
    if (pthread_setschedparam(pthread_self(), SCHED_FIFO, &amp;param) != 0) {
        ALOGW(&quot;Failed to set SCHED_FIFO on dispatch thread&quot;);
    }

    if (pthread_setname_np(pthread_self(), &quot;TimerDispatch&quot;)) { //线程命名
        ALOGW(&quot;Failed to set thread name on dispatch thread&quot;);
    }
    ...
     
    while (true) {
         ...
        int nfds = epoll_wait(mEpollFd, events, DispatchType::MAX_DISPATCH_TYPE, -1);
        ...  
        for (auto i = 0; i &lt; nfds; i++) {
            if (events[i].data.u32 == DispatchType::TIMER) {
                ...
                if (cb) {
                    setDebugState(DebugState::InCallback);
                    cb();//回调操作
                    setDebugState(DebugState::Running);
                }
            }
        ...
        }
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>Timer 类在构造方法会创建的一个线程 mDispatchThread。</p></li><li><p>在这里用到了 timerfd，timerfd 是 Linux 为用户程序提供一个定时器接口，这个接口基于文件描述符，通过文件描述符的可读事件进行超时通知，因此可以配合epoll等使用，timerfd_create() 函数创建一个定时器对象，同时返回一个与之关联的文件描述符。</p><ul><li><p>clockid: CLOCK_REALTIME:系统实时时间，随着系统实时时间改变而改变，即从UTC1970-1-1 0:0:0开始计时，CLOCK_MONOTONIC:从系统启动这一刻开始计时，不受系统时间被用户改变的影响。</p></li><li><p>flags: TFD_NONBLOCK(非堵塞模式)/TFD_CLOEXEC(表示程序执行exec函数时本fd将被系统自动关闭，表示不传递)</p></li><li><p>timerfd_settime（）这个函数用于设置新的超时时间，并开始计时，能够启动和停止定时器。</p></li><li><p>fd: 参数fd是timerfd_create函数返回的文件句柄。</p></li><li><p>flags: 参数flags为1设置是绝对时间，0代表是相对时间。</p></li><li><p>new_value: 参数new_value指定的定时器的超时时间以及超时间隔时间。</p></li><li><p>old_value: 参数old_value如果不为NULL, old_vlaue返回之前定时器设置的超时时间，具体参考timerfd_gettimer()函数。</p></li></ul></li><li><p>timerfd 配合 epoll 函数使用，如果定时器时间到了，就会执行上图中 alarmAt 函数传入的函数指针，这个函数指针是 VsyncDispatchTimerQueue.cpp 类的 timerCallback() 函数，而这个函数中，就是对注册的 callback 执行回调。</p></li></ul><h3 id="sf-向-vsyncdispatch-注册与回调的过程" tabindex="-1"><a class="header-anchor" href="#sf-向-vsyncdispatch-注册与回调的过程" aria-hidden="true">#</a> SF 向 VsyncDispatch 注册与回调的过程</h3><h4 id="注册过程" tabindex="-1"><a class="header-anchor" href="#注册过程" aria-hidden="true">#</a> 注册过程</h4><p>跟踪下SF是如何注册自己的回调函数。</p><p>我们知道，App有个主线程（ActivityThread）专门进行UI处理，该主线程是由一个消息队列（Looper/handler）驱动，主线程不断的从消息队列中取出消息，处理消息，如此往复。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//@ActivityThread.java</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//准备UI主线程的消息循环</span>
    <span class="token class-name">Looper</span><span class="token punctuation">.</span><span class="token function">prepareMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//创建ActivityThread，并调用attach方法</span>
    <span class="token class-name">ActivityThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActivityThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>sMainThreadHandler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sMainThreadHandler <span class="token operator">=</span> thread<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//进入主线程消息循环</span>
    <span class="token class-name">Looper</span><span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SF 也类似，有个主线程负责处理合成相关的事物，同时有一个消息队列来驱动，从第一章中 SurfaceFlinger 模块的主流程模块中讲解了 MessageQueue 的初始化过程，当初始化完毕之后，SF 主线程就进入了消息循环，等待有申请合入相关的事物，然后去做相应的处理。</p><p>MessageQueue 中有个方法 initVsync()，在前面讲解的 VSYNC 信号的初始化过程中，其中调用了 MessageQueue 的 initVsync 函数。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp

void SurfaceFlinger::initScheduler(const sp&lt;DisplayDevice&gt;&amp; display) {
    ...

    mScheduler-&gt;initVsync(mScheduler-&gt;getVsyncDispatch(), *mFrameTimeline-&gt;getTokenManager(),
                          configs.late.sfWorkDuration);

    ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 initVsync 函数中初始化 mVsync.registation 对象，这个对象是 VSyncDispatch.h 文件中定义的类 VSyncCallbackRegistration ，这个类的作用是操作已经注册回调的帮助类，在该类的构造函数中间接调用 dispatch.registerCallback() 。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp
void MessageQueue::initVsync(scheduler::VSyncDispatch&amp; dispatch,
                             frametimeline::TokenManager&amp; tokenManager,
                             std::chrono::nanoseconds workDuration) {
    setDuration(workDuration);
    mVsync.tokenManager = &amp;tokenManager;
    mVsync.registration = std::make_unique&lt;
            scheduler::VSyncCallbackRegistration&gt;(dispatch,
                                                  std::bind(&amp;MessageQueue::vsyncCallback, this,
                                                            std::placeholders::_1,
                                                            std::placeholders::_2,
                                                            std::placeholders::_3),
                                                  &quot;sf&quot;);
frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp
VSyncCallbackRegistration::VSyncCallbackRegistration(VSyncDispatch&amp; dispatch,
                                                     VSyncDispatch::Callback callback,
                                                     std::string callbackName)
      : mDispatch(dispatch),
        mToken(dispatch.registerCallback(std::move(callback), std::move(callbackName))),
        mValidToken(true) {}
}

frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp
VSyncDispatchTimerQueue::CallbackToken VSyncDispatchTimerQueue::registerCallback(
        Callback callback, std::string callbackName) {
    std::lock_guard lock(mMutex);
    return CallbackToken{
            mCallbacks
                    .emplace(++mCallbackToken,
                             std::make_shared&lt;VSyncDispatchTimerQueueEntry&gt;(std::move(callbackName),
                                                                            std::move(callback),
                                                                            mMinVsyncDistance))
                    .first-&gt;first};
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>VsyncDispatch 的注册函数就会往 mCallbacks 注册封装了callbackFn 的 VsyncDispatchTimerQueueEntry 对象。从上面的几个步骤来看就完成了 SF 向 VsyncDispatch 注册的全部流程。</p><h4 id="回调过程" tabindex="-1"><a class="header-anchor" href="#回调过程" aria-hidden="true">#</a> 回调过程</h4><p>回调过程如下：</p><ul><li>当 VsyncDispatch 发送 VSYNC-sf 的信号时，会走到MessageQueue类 注册的回调函数。</li></ul><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>
ScheduleResult VSyncDispatchTimerQueue::schedule(CallbackToken token,
                                                 ScheduleTiming scheduleTiming) {
    ScheduleResult result;
    {
        ...

        if (callback-&gt;wakeupTime() &lt; mIntendedWakeupTime - mTimerSlack) {
            rearmTimerSkippingUpdateFor(now, it);
        }
    }

    return result;
}

frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp
void VSyncDispatchTimerQueue::setTimer(nsecs_t targetTime, nsecs_t /*now*/) {
    mIntendedWakeupTime = targetTime;
    mTimeKeeper-&gt;alarmAt(std::bind(&amp;VSyncDispatchTimerQueue::timerCallback, this),
                         mIntendedWakeupTime);
    mLastTimerSchedule = mTimeKeeper-&gt;now();
}

frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp
void VSyncDispatchTimerQueue::timerCallback() {
    struct Invocation {
        std::shared_ptr&lt;VSyncDispatchTimerQueueEntry&gt; callback;
        nsecs_t vsyncTimestamp;
        nsecs_t wakeupTimestamp;
        nsecs_t deadlineTimestamp;
    };
    std::vector&lt;Invocation&gt; invocations;

    ...

    for (auto const&amp; invocation : invocations) {
        invocation.callback-&gt;callback(invocation.vsyncTimestamp, invocation.wakeupTimestamp,
                                      invocation.deadlineTimestamp);
    }
}

frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp
void MessageQueue::vsyncCallback(nsecs_t vsyncTime, nsecs_t targetWakeupTime, nsecs_t readyTime) {
    ...

    mHandler-&gt;dispatchFrame(vsyncId, vsyncTime);
}

frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp
void MessageQueue::Handler::dispatchFrame(int64_t vsyncId, nsecs_t expectedVsyncTime) {
    if (!mFramePending.exchange(true)) {
        mVsyncId = vsyncId;
        mExpectedVsyncTime = expectedVsyncTime;
        mQueue.mLooper-&gt;sendMessage(this, Message());
    }
}

frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp
void MessageQueue::Handler::handleMessage(const Message&amp;) {
    mFramePending.store(false);

    const nsecs_t frameTime = systemTime();
    auto&amp; compositor = mQueue.mCompositor;

    if (!compositor.commit(frameTime, mVsyncId, mExpectedVsyncTime)) {
        return;
    }

    compositor.composite(frameTime, mVsyncId);
    compositor.sample();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>handleMessage的函数调用栈：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>thread #1, name = &#39;surfaceflinger&#39;, stop reason = step over
frame #0: 0x0000566eac668d7d surfaceflinger`android::impl::MessageQueue::Handler::handleMessage(this=0x00007a3974b6aac0, (null)=&lt;unavailable&gt;) at MessageQueue.cpp:48:31
frame #1: 0x00007a3bcbff84b0 libutils.so`android::Looper::pollInner(this=0x00007a39e4b59b10, timeoutMillis=&lt;unavailable&gt;) at Looper.cpp:333:26
frame #2: 0x00007a3bcbff828f libutils.so`android::Looper::pollOnce(this=0x00007a39e4b59b10, timeoutMillis=-1, outFd=0x0000000000000000, outEvents=0x0000000000000000, outData=0x0000000000000000) at Looper.cpp:213:18
frame #3: 0x0000566eac669442 surfaceflinger`android::impl::MessageQueue::waitMessage() [inlined] android::Looper::pollOnce(this=&lt;unavailable&gt;, timeoutMillis=-1) at Looper.h:270:16
frame #4: 0x0000566eac669431 surfaceflinger`android::impl::MessageQueue::waitMessage(this=0x00007a3a44b593c0) at MessageQueue.cpp:145:32
frame #5: 0x0000566eac672709 surfaceflinger`android::scheduler::Scheduler::run(this=0x00007a3a44b593c0) at Scheduler.cpp:131:9
frame #6: 0x0000566eac6d6b2b surfaceflinger`main [inlined] android::SurfaceFlinger::run(this=&lt;unavailable&gt;) at SurfaceFlinger.cpp:483:17
frame #7: 0x0000566eac6d6b1f surfaceflinger`main((null)=1, (null)=&lt;unavailable&gt;) at main_surfaceflinger.cpp:167:14
frame #8: 0x00007a3bc9670cca libc.so`::__libc_init(raw_args=&lt;unavailable&gt;, onexit=&lt;unavailable&gt;, slingshot=(surfaceflinger`main at main_surfaceflinger.cpp:79), structors=&lt;unavailable&gt;)(), int (*)(int, char **, char **), const structors_array_t *const) at libc_init_dynamic.cpp:157:8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>在这个回调函数中，通过 Handler 将 VSYNC 事件转换成内部的 msg，投递到消息队列中。</p></li><li><p>SF 主线程从消息队列中取出消息，回调到 SF-&gt;handleMessage()</p></li></ul><p>可见，MessageQueue 是接收 VSYNC-SF 信号的，将 VsyncDispatch 发送的 VSYNC-SF 信号通过自身转到 SF，驱动 SF 执行合成操作。</p><h3 id="dispsyncsource-是-vsyncdispatch-与-eventthread-之间的桥梁" tabindex="-1"><a class="header-anchor" href="#dispsyncsource-是-vsyncdispatch-与-eventthread-之间的桥梁" aria-hidden="true">#</a> DispSyncSource 是 VsyncDispatch 与 EventThread 之间的桥梁</h3><p>DispSyncSource 是对标准 SW VSYNC 的细分，产生 VSYNC-app ，它可以认为是信号源，仍然需要触发下游组件来接受信号，对 DisplaySyncSource 来说，它的下游组件就是 EventThread。所以说 DispSyncSource 是 VsyncDispatch 与 EventThread 之间通讯的纽带。</p><p>在 DispSyncSource 类中，下游组件用 mCallback 来表示， mCallback 是 VSyncSource::Callback 类型，而 EventThread 也继承自 VsyncSource::Callback。</p><p>相关代码如下：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>/home/biezhihua/projects/aosp/frameworks/native/services/surfaceflinger/Scheduler/DispSyncSource.h
class DispSyncSource final : public VSyncSource {
    ...

    std::unique_ptr&lt;CallbackRepeater&gt; mCallbackRepeater;

    VSyncSource::Callback* mCallback GUARDED_BY(mCallbackMutex) = nullptr;

    ...
};

/home/biezhihua/projects/aosp/frameworks/native/services/surfaceflinger/Scheduler/EventThread.h
class VSyncSource {
public:
    class VSyncData {
        ...
    };

    class Callback {
        ...

        virtual void onVSyncEvent(nsecs_t when, VSyncData vsyncData) = 0;
    };

    ...
};

/home/biezhihua/projects/aosp/frameworks/native/services/surfaceflinger/Scheduler/EventThread.h
class EventThread : public android::EventThread, private VSyncSource::Callback {
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="dispsyncsource-是怎么和-vsyncdispatch-建立联系" tabindex="-1"><a class="header-anchor" href="#dispsyncsource-是怎么和-vsyncdispatch-建立联系" aria-hidden="true">#</a> DispSyncSource 是怎么和 VsyncDispatch 建立联系？</h4><p>这个和 SF 向 VsyncDispatch 注册很类似，DispSyncSource 有个 mCallbackRepeater 对象，该对象在初始化的时候，会传入DispSyncSource 的回调接口 DispSyncsource::onVsyncCallback。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
void SurfaceFlinger::initScheduler(const sp&lt;DisplayDevice&gt;&amp; display) {
    ...

    mAppConnectionHandle =
            mScheduler-&gt;createConnection(&quot;app&quot;, mFrameTimeline-&gt;getTokenManager(),
                                         /*workDuration=*/configs.late.appWorkDuration,
                                         /*readyDuration=*/configs.late.sfWorkDuration,
                                         impl::EventThread::InterceptVSyncsCallback());
    mSfConnectionHandle =
            mScheduler-&gt;createConnection(&quot;appSf&quot;, mFrameTimeline-&gt;getTokenManager(),
                                         /*workDuration=*/std::chrono::nanoseconds(vsyncPeriod),
                                         /*readyDuration=*/configs.late.sfWorkDuration,
                                         [this](nsecs_t timestamp) {
                                             mInterceptor-&gt;saveVSyncEvent(timestamp);
                                         });

    ...
}


frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
ConnectionHandle Scheduler::createConnection(
        const char* connectionName, frametimeline::TokenManager* tokenManager,
        std::chrono::nanoseconds workDuration, std::chrono::nanoseconds readyDuration,
        impl::EventThread::InterceptVSyncsCallback interceptCallback) {

    auto vsyncSource = makePrimaryDispSyncSource(connectionName, workDuration, readyDuration);

    auto throttleVsync = makeThrottleVsyncCallback();

    auto getVsyncPeriod = makeGetVsyncPeriodFunction();

    auto eventThread = std::make_unique&lt;impl::EventThread&gt;(std::move(vsyncSource), tokenManager,
                                                           std::move(interceptCallback),
                                                           std::move(throttleVsync),
                                                           std::move(getVsyncPeriod));
    return createConnection(std::move(eventThread));
}


frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
std::unique_ptr&lt;VSyncSource&gt; Scheduler::makePrimaryDispSyncSource(
        const char* name, std::chrono::nanoseconds workDuration,
        std::chrono::nanoseconds readyDuration, bool traceVsync) {
    return std::make_unique&lt;scheduler::DispSyncSource&gt;(mVsyncSchedule-&gt;getDispatch(),
                                                       mVsyncSchedule-&gt;getTracker(), workDuration,
                                                       readyDuration, traceVsync, name);
}

frameworks/native/services/surfaceflinger/Scheduler/DispSyncSource.cpp
DispSyncSource::DispSyncSource(VSyncDispatch&amp; vSyncDispatch, VSyncTracker&amp; vSyncTracker,
                               std::chrono::nanoseconds workDuration,
                               std::chrono::nanoseconds readyDuration, bool traceVsync,
                               const char* name)
      : mName(name),
        mValue(base::StringPrintf(&quot;VSYNC-%s&quot;, name), 0),
        mTraceVsync(traceVsync),
        mVsyncOnLabel(base::StringPrintf(&quot;VsyncOn-%s&quot;, name)),
        mVSyncTracker(vSyncTracker),
        mWorkDuration(base::StringPrintf(&quot;VsyncWorkDuration-%s&quot;, name), workDuration),
        mReadyDuration(readyDuration) {
    mCallbackRepeater =
            std::make_unique&lt;CallbackRepeater&gt;(vSyncDispatch,
                                               std::bind(&amp;DispSyncSource::onVsyncCallback, this,
                                                         std::placeholders::_1,
                                                         std::placeholders::_2,
                                                         std::placeholders::_3),
                                               name, workDuration, readyDuration,
                                               std::chrono::steady_clock::now().time_since_epoch());
}

frameworks/native/services/surfaceflinger/Scheduler/DispSyncSource.cpp
CallbackRepeater(VSyncDispatch&amp; dispatch, VSyncDispatch::Callback cb, const char* name,
                    std::chrono::nanoseconds workDuration, std::chrono::nanoseconds readyDuration,
                    std::chrono::nanoseconds notBefore)
        : mName(name),
        mCallback(cb),
        mRegistration(dispatch,
                        std::bind(&amp;CallbackRepeater::callback, this, std::placeholders::_1,
                                std::placeholders::_2, std::placeholders::_3),
                        mName),
        mStarted(false),
        mWorkDuration(workDuration),
        mReadyDuration(readyDuration),
        mLastCallTime(notBefore) {}

frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp
EventThread::EventThread(std::unique_ptr&lt;VSyncSource&gt; vsyncSource,
                         android::frametimeline::TokenManager* tokenManager,
                         InterceptVSyncsCallback interceptVSyncsCallback,
                         ThrottleVsyncCallback throttleVsyncCallback,
                         GetVsyncPeriodFunction getVsyncPeriodFunction)
      : mVSyncSource(std::move(vsyncSource)),
        mTokenManager(tokenManager),
        mInterceptVSyncsCallback(std::move(interceptVSyncsCallback)),
        mThrottleVsyncCallback(std::move(throttleVsyncCallback)),
        mGetVsyncPeriodFunction(std::move(getVsyncPeriodFunction)),
        mThreadName(mVSyncSource-&gt;getName()) {

    ...

    mVSyncSource-&gt;setCallback(this);

    mThread = std::thread([this]() NO_THREAD_SAFETY_ANALYSIS {
        std::unique_lock&lt;std::mutex&gt; lock(mMutex);
        threadMain(lock);
    });

    ...
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在初始化 DispSyncSource 的时候，会创建 mCallbackRepeater 对象，这个对象 mCallbackRepeater 需要传入 VsyncDispatch 和 DispSyncSource 回调函数。</p><p>在CallbackRepeater 的构造方法中，会创建 VsyncCallbackRegistration 这个对象，这个对象在创建的时候，会给 VsyncDispatch 注册回调函数。</p><p>当 VsyncDispatch 发送信号的时候，先传递给 CallbackRepeater ，再传递到 DispSyncsource 中。</p><p>当 DispSyncSource 收到信息会把信号发送到 EventThread 中。</p><p>回调函数调用栈：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>thread #8, name = &#39;TimerDispatch&#39;, stop reason = breakpoint 1.1
frame #0: 0x00005ea86f2f9dd8 surfaceflinger`android::impl::EventThread::onVSyncEvent(this=0x000076d980a215d0, timestamp=104396993542, vsyncData=(expectedPresentationTime = 104429326874, deadlineTimestamp = 104413660208)) at EventThread.cpp:394:38
frame #1: 0x00005ea86f2f79d3 surfaceflinger`android::scheduler::CallbackRepeater::callback(long, long, long) [inlined] std::__1::__function::__value_func&lt;void (long, long, long)&gt;::operator(this=0x000076d940a24830, __args=0x000076d8ac0fca70, __args=0x000076d8ac0fca68, __args=0x000076d8ac0fca60)(long&amp;&amp;, long&amp;&amp;, long&amp;&amp;) const at functional:1799:16
frame #2: 0x00005ea86f2f79b1 surfaceflinger`android::scheduler::CallbackRepeater::callback(long, long, long) [inlined] std::__1::function&lt;void (long, long, long)&gt;::operator(this= Function = android::scheduler::DispSyncSource::onVsyncCallback(long, long, long) , __arg=104429326874, __arg=104396993542, __arg=104413660208)(long, long, long) const at functional:2347:12
frame #3: 0x00005ea86f2f79b1 surfaceflinger`android::scheduler::CallbackRepeater::callback(this=0x000076d940a24810, vsyncTime=104429326874, wakeupTime=104396993542, readyTime=104413660208) at DispSyncSource.cpp:92:9
frame #4: 0x00005ea86f3110db surfaceflinger`android::scheduler::VSyncDispatchTimerQueue::timerCallback() [inlined] std::__1::__function::__value_func&lt;void (long, long, long)&gt;::operator(this=0x000076d970a222b0, __args=0x000076d8ac0fcb18, __args=0x000076d8ac0fcb10, __args=0x000076d8ac0fcb08)(long&amp;&amp;, long&amp;&amp;, long&amp;&amp;) const at functional:1799:16
frame #5: 0x00005ea86f3110b9 surfaceflinger`android::scheduler::VSyncDispatchTimerQueue::timerCallback() [inlined] std::__1::function&lt;void (long, long, long)&gt;::operator(this= Function = android::scheduler::CallbackRepeater::callback(long, long, long) , __arg=104429326874, __arg=104396993542, __arg=104413660208)(long, long, long) const at functional:2347:12
frame #6: 0x00005ea86f3110b9 surfaceflinger`android::scheduler::VSyncDispatchTimerQueue::timerCallback() [inlined] android::scheduler::VSyncDispatchTimerQueueEntry::callback(this=0x000076d970a22290, vsyncTimestamp=&lt;unavailable&gt;, wakeupTimestamp=104396993542, deadlineTimestamp=104413660208) at VSyncDispatchTimerQueue.cpp:163:5
frame #7: 0x00005ea86f311087 surfaceflinger`android::scheduler::VSyncDispatchTimerQueue::timerCallback(this=&lt;unavailable&gt;) at VSyncDispatchTimerQueue.cpp:300:30
frame #8: 0x00005ea86f7a92d2 surfaceflinger`void* std::__1::__thread_proxy&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt; &gt;, android::scheduler::Timer::Timer()::$_0&gt; &gt;(void*) [inlined] std::__1::__function::__value_func&lt;void ()&gt;::operator(this=0x000076d8ac0fcc20)() const at functional:1799:16
frame #9: 0x00005ea86f7a92bb surfaceflinger`void* std::__1::__thread_proxy&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt; &gt;, android::scheduler::Timer::Timer()::$_0&gt; &gt;(void*) [inlined] std::__1::function&lt;void ()&gt;::operator(this= Function = android::scheduler::VSyncDispatchTimerQueue::timerCallback() )() const at functional:2347:12
frame #10: 0x00005ea86f7a92bb surfaceflinger`void* std::__1::__thread_proxy&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt; &gt;, android::scheduler::Timer::Timer()::$_0&gt; &gt;(void*) at Timer.cpp:216:21
frame #11: 0x00005ea86f7a8ff2 surfaceflinger`void* std::__1::__thread_proxy&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt; &gt;, android::scheduler::Timer::Timer()::$_0&gt; &gt;(void*) [inlined] android::scheduler::Timer::threadMain(this=0x000076d930a16f30) at Timer.cpp:148:12
frame #12: 0x00005ea86f7a8ff2 surfaceflinger`void* std::__1::__thread_proxy&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt; &gt;, android::scheduler::Timer::Timer()::$_0&gt; &gt;(void*) [inlined] android::scheduler::Timer::Timer(this=0x000076d8c0a1f638)::$_0::operator()() const at Timer.cpp:44:46
frame #13: 0x00005ea86f7a8ff2 surfaceflinger`void* std::__1::__thread_proxy&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt; &gt;, android::scheduler::Timer::Timer()::$_0&gt; &gt;(void*) [inlined] decltype(__f=0x000076d8c0a1f638)::$_0&gt;(fp)()) std::__1::__invoke&lt;android::scheduler::Timer::Timer()::$_0&gt;(android::scheduler::Timer::Timer()::$_0&amp;&amp;) at type_traits:4353:1
frame #14: 0x00005ea86f7a8ff2 surfaceflinger`void* std::__1::__thread_proxy&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt; &gt;, android::scheduler::Timer::Timer()::$_0&gt; &gt;(void*) [inlined] void std::__1::__thread_execute&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt; &gt;, android::scheduler::Timer::Timer()::$_0&gt;(__t=size=2, (null)=&lt;unavailable&gt;)::$_0&gt;&amp;, std::__1::__tuple_indices&lt;&gt;) at thread:342:5
frame #15: 0x00005ea86f7a8ff2 surfaceflinger`void* std::__1::__thread_proxy&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt; &gt;, android::scheduler::Timer::Timer()::$_0&gt; &gt;(__vp=0x000076d8c0a1f630) at thread:352:5
frame #16: 0x000076db4154dd9b libc.so`__pthread_start(arg=0x000076d8ac0fccf0) at pthread_create.cpp:364:18
frame #17: 0x000076db414e1d48 libc.so`::__start_thread(fn=(libc.so`__pthread_start(void*) at pthread_create.cpp:339), arg=0x000076d8ac0fccf0)(void *), void *) at clone.cpp:53:16
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp
void VSyncDispatchTimerQueue::timerCallback() {
    ...

    for (auto const&amp; invocation : invocations) {
        invocation.callback-&gt;callback(invocation.vsyncTimestamp, invocation.wakeupTimestamp,
                                      invocation.deadlineTimestamp);
    }
}


frameworks/native/services/surfaceflinger/Scheduler/DispSyncSource.cpp
void CallbackRepeater::callback(nsecs_t vsyncTime, nsecs_t wakeupTime, nsecs_t readyTime) {
    {
        std::lock_guard lock(mMutex);
        mLastCallTime = std::chrono::nanoseconds(vsyncTime);
    }

    mCallback(vsyncTime, wakeupTime, readyTime);

    {
        std::lock_guard lock(mMutex);
        if (!mStarted) {
            return;
        }
        auto const scheduleResult =
                mRegistration.schedule({.workDuration = mWorkDuration.count(),
                                        .readyDuration = mReadyDuration.count(),
                                        .earliestVsync = vsyncTime});
        LOG_ALWAYS_FATAL_IF(!scheduleResult.has_value(), &quot;Error rescheduling callback&quot;);
    }
}

frameworks/native/services/surfaceflinger/Scheduler/DispSyncSource.cpp
void DispSyncSource::onVsyncCallback(nsecs_t vsyncTime, nsecs_t targetWakeupTime,
                                     nsecs_t readyTime) {
    VSyncSource::Callback* callback;
    {
        std::lock_guard lock(mCallbackMutex);
        callback = mCallback;
    }

    if (mTraceVsync) {
        mValue = (mValue + 1) % 2;
    }

    if (callback != nullptr) {
        callback-&gt;onVSyncEvent(targetWakeupTime, {vsyncTime, readyTime});
    }
}

frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp
void EventThread::onVSyncEvent(nsecs_t timestamp, VSyncSource::VSyncData vsyncData) {
    std::lock_guard&lt;std::mutex&gt; lock(mMutex);

    LOG_FATAL_IF(!mVSyncState);
    mPendingEvents.push_back(makeVSync(mVSyncState-&gt;displayId, timestamp, ++mVSyncState-&gt;count,
                                       vsyncData.expectedPresentationTime,
                                       vsyncData.deadlineTimestamp));
    mCondition.notify_all();
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="app-向-eventthread-注册-connection" tabindex="-1"><a class="header-anchor" href="#app-向-eventthread-注册-connection" aria-hidden="true">#</a> App 向 EventThread 注册 Connection</h3><p>如果有 App 关心 VSYN-APP，则需要向 appEventThread 注册 Connection，可能有多个 App 同时关注 VSYNC-app 信号，所以在 EventThread 的内部有一个 mDisplayEventConnections 来保存着 Connection，Connection 是一个 Bn 对象，因为要与 APP 进行 binder 通讯。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code> /frameworks/native/services/surfaceflinger/Scheduler/EventThread.h
class EventThread : public android::EventThread, private VSyncSource::Callback {
    ...


    ....
};

status_t EventThread::registerDisplayEventConnection(const sp&lt;EventThreadConnection&gt;&amp; connection) {
    std::lock_guard&lt;std::mutex&gt; lock(mMutex);

    // this should never happen
    auto it = std::find(mDisplayEventConnections.cbegin(),
            mDisplayEventConnections.cend(), connection);
    if (it != mDisplayEventConnections.cend()) {
        ALOGW(&quot;DisplayEventConnection %p already exists&quot;, connection.get());
        mCondition.notify_all();
        return ALREADY_EXISTS;
    }

    mDisplayEventConnections.push_back(connection);
    mCondition.notify_all();
    return NO_ERROR;
}

void EventThread::removeDisplayEventConnectionLocked(const wp&lt;EventThreadConnection&gt;&amp; connection) {
    auto it = std::find(mDisplayEventConnections.cbegin(),
            mDisplayEventConnections.cend(), connection);
    if (it != mDisplayEventConnections.cend()) {
        mDisplayEventConnections.erase(it);
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上贴的三段代码，分别是定义Connection的集合对象，往appEventThread注册Connection和删除Connection。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void SurfaceFlinger::initScheduler(const sp&lt;DisplayDevice&gt;&amp; display) {
    ...

    mAppConnectionHandle =
            mScheduler-&gt;createConnection(&quot;app&quot;, mFrameTimeline-&gt;getTokenManager(),
                                         /*workDuration=*/configs.late.appWorkDuration,
                                         /*readyDuration=*/configs.late.sfWorkDuration,
                                         impl::EventThread::InterceptVSyncsCallback());
    ...
}

/home/biezhihua/projects/aosp/frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
ConnectionHandle Scheduler::createConnection(
        const char* connectionName, frametimeline::TokenManager* tokenManager,
        std::chrono::nanoseconds workDuration, std::chrono::nanoseconds readyDuration,
        impl::EventThread::InterceptVSyncsCallback interceptCallback) {
    ...
    return createConnection(std::move(eventThread));
}

/home/biezhihua/projects/aosp/frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
ConnectionHandle Scheduler::createConnection(std::unique_ptr&lt;EventThread&gt; eventThread) {
    const ConnectionHandle handle = ConnectionHandle{mNextConnectionHandleId++};
    ALOGV(&quot;Creating a connection handle with ID %&quot; PRIuPTR, handle.id);

    auto connection = createConnectionInternal(eventThread.get());

    std::lock_guard&lt;std::mutex&gt; lock(mConnectionsLock);
    mConnections.emplace(handle, Connection{connection, std::move(eventThread)});
    return handle;
}

/home/biezhihua/projects/aosp/frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
sp&lt;EventThreadConnection&gt; Scheduler::createConnectionInternal(
        EventThread* eventThread, ISurfaceComposer::EventRegistrationFlags eventRegistration) {
    return eventThread-&gt;createEventConnection([&amp;] { resync(); }, eventRegistration);
}

/home/biezhihua/projects/aosp/frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp
sp&lt;EventThreadConnection&gt; EventThread::createEventConnection(
        ResyncCallback resyncCallback,
        ISurfaceComposer::EventRegistrationFlags eventRegistration) const {
    return new EventThreadConnection(const_cast&lt;EventThread*&gt;(this),
                                     IPCThreadState::self()-&gt;getCallingUid(),
                                     std::move(resyncCallback), eventRegistration);
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="vsync-sf-的申请" tabindex="-1"><a class="header-anchor" href="#vsync-sf-的申请" aria-hidden="true">#</a> VSYNC-sf 的申请</h2><h3 id="scheduleframe" tabindex="-1"><a class="header-anchor" href="#scheduleframe" aria-hidden="true">#</a> scheduleFrame</h3><p>当应用上帧的时候，也就是当 BufferQueue 有新的 Graphic Buffer 到达时，应用会通过 binder 通讯，调用到 SurfaceFlinger 的 setTransactionState 方法，再去调用 setTransactionFlags 方法，通知 SF 有新的 Graphic Buffer 到达：</p><p>SF的 scheduleCommit 方法中调用 MessageQueue 的 scheduleFrame 方法。</p><p>scheduleFrame 方法就是SF去申请一次性的 VSYNC。</p><p>应用上帧的调用栈：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>thread #17, name = &#39;binder:458_5&#39;, stop reason = breakpoint 1.3
frame #0: 0x000058e7b49e4022 surfaceflinger`android::SurfaceFlinger::setTransactionFlags(unsigned int, android::scheduler::TransactionSchedule, android::sp&lt;android::IBinder&gt; const&amp;, android::SurfaceFlinger::FrameHint) [inlined] android::SurfaceFlinger::scheduleCommit(this=0x00006ffc7adad8c0, hint=kActive) at SurfaceFlinger.cpp:1827:14
frame #1: 0x000058e7b49e4022 surfaceflinger`android::SurfaceFlinger::setTransactionFlags(this=0x00006ffc7adad8c0, mask=16, schedule=&lt;unavailable&gt;, applyToken=&lt;unavailable&gt;, frameHint=kActive) at SurfaceFlinger.cpp:3705:9
frame #2: 0x000058e7b49fd042 surfaceflinger`android::SurfaceFlinger::setTransactionState(android::FrameTimelineInfo const&amp;, android::Vector&lt;android::ComposerState&gt; const&amp;, android::Vector&lt;android::DisplayState&gt; const&amp;, unsigned int, android::sp&lt;android::IBinder&gt; const&amp;, android::InputWindowCommands const&amp;, long, bool, android::client_cache_t const&amp;, bool, std::__1::vector&lt;android::ListenerCallbacks, std::__1::allocator&lt;android::ListenerCallbacks&gt; &gt; const&amp;, unsigned long) [inlined] android::SurfaceFlinger::queueTransaction(this=0x00006ffc7adad8c0, state=0x00006ffae5e532a0) at SurfaceFlinger.cpp:4112:5
frame #3: 0x000058e7b49fce58 surfaceflinger`android::SurfaceFlinger::setTransactionState(this=&lt;unavailable&gt;, frameTimelineInfo=0x00006ffae5e53560, states=0x00006ffae5e53530, displays=0x00006ffae5e53500, flags=&lt;unavailable&gt;, applyToken=0x00006ffae5e534f0, inputWindowCommands=0x00006ffae5e53580, desiredPresentTime=0, isAutoTimestamp=&lt;unavailable&gt;, uncacheBuffer=0x00006ffae5e534c0, hasListenerCallbacks=&lt;unavailable&gt;, listenerCallbacks=size=0, transactionId=2508260901263) at SurfaceFlinger.cpp:4187:5
frame #4: 0x00006ffd830e74da libgui.so`android::BnSurfaceComposer::onTransact(this=0x00006ffc7adad8c0, code=&lt;unavailable&gt;, data=0x00006ffae5e53b00, reply=&lt;unavailable&gt;, flags=&lt;unavailable&gt;) at ISurfaceComposer.cpp:1100:20
frame #5: 0x000058e7b4a04351 surfaceflinger`android::SurfaceFlinger::onTransact(this=0x00006ffc7adad8c0, code=8, data=0x00006ffae5e53b00, reply=0x00006ffae5e53a80, flags=16) at SurfaceFlinger.cpp:5719:39
frame #6: 0x00006ffd860b46f1 libbinder.so`android::BBinder::transact(this=0x00006ffc7adad8c0, code=8, data=0x00006ffae5e53b00, reply=0x00006ffae5e53a80, flags=16) at Binder.cpp:297:19
frame #7: 0x00006ffd860bf834 libbinder.so`android::IPCThreadState::executeCommand(this=0x00006ffbcadac310, cmd=&lt;unavailable&gt;) at IPCThreadState.cpp:1293:68
frame #8: 0x00006ffd860bf2be libbinder.so`android::IPCThreadState::getAndExecuteCommand(this=0x00006ffbcadac310) at IPCThreadState.cpp:563:18
frame #9: 0x00006ffd860bfc90 libbinder.so`android::IPCThreadState::joinThreadPool(this=0x00006ffbcadac310, isMain=&lt;unavailable&gt;) at IPCThreadState.cpp:649:18
frame #10: 0x00006ffd860ef9e8 libbinder.so`android::PoolThread::threadLoop(this=0x00006ffb6adb6a30) at ProcessState.cpp:72:33
frame #11: 0x00006ffd8145be56 libutils.so`android::Thread::_threadLoop(user=0x00006ffb6adb6a30) at Mutex.h:0:12
frame #12: 0x00006ffd7ae66d9b libc.so`__pthread_start(arg=0x00006ffae5e53cf0) at pthread_create.cpp:364:18
frame #13: 0x00006ffd7adfad48 libc.so`::__start_thread(fn=(libc.so`__pthread_start(void*) at pthread_create.cpp:339), arg=0x00006ffae5e53cf0)(void *), void *) at clone.cpp:53:16
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>
status_t SurfaceFlinger::setTransactionState(
        const FrameTimelineInfo&amp; frameTimelineInfo, const Vector&lt;ComposerState&gt;&amp; states,
        const Vector&lt;DisplayState&gt;&amp; displays, uint32_t flags, const sp&lt;IBinder&gt;&amp; applyToken,
        const InputWindowCommands&amp; inputWindowCommands, int64_t desiredPresentTime,
        bool isAutoTimestamp, const client_cache_t&amp; uncacheBuffer, bool hasListenerCallbacks,
        const std::vector&lt;ListenerCallbacks&gt;&amp; listenerCallbacks, uint64_t transactionId) {
    ...

    queueTransaction(state);

    ...

    return NO_ERROR;
}

void SurfaceFlinger::queueTransaction(TransactionState&amp; state) {
    ...

    setTransactionFlags(eTransactionFlushNeeded, schedule, state.applyToken, frameHint);
}

void SurfaceFlinger::setTransactionFlags(uint32_t mask, TransactionSchedule schedule,
                                         const sp&lt;IBinder&gt;&amp; applyToken, FrameHint frameHint) {
    modulateVsync(&amp;VsyncModulator::setTransactionSchedule, schedule, applyToken);

    if (const bool scheduled = mTransactionFlags.fetch_or(mask) &amp; mask; !scheduled) {
        scheduleCommit(frameHint);
    }
}

void SurfaceFlinger::scheduleCommit(FrameHint hint) {
    if (hint == FrameHint::kActive) {
        mScheduler-&gt;resetIdleTimer();
    }
    mPowerAdvisor-&gt;notifyDisplayUpdateImminent();
    mScheduler-&gt;scheduleFrame();
}


void MessageQueue::scheduleFrame() {
    ATRACE_CALL();

    {
        std::lock_guard lock(mInjector.mutex);
        if (CC_UNLIKELY(mInjector.connection)) {
            ALOGD(&quot;%s while injecting VSYNC&quot;, __FUNCTION__);
            mInjector.connection-&gt;requestNextVsync();
            return;
        }
    }

    std::lock_guard lock(mVsync.mutex);
    mVsync.scheduledFrameTime =
            mVsync.registration-&gt;schedule({.workDuration = mVsync.workDuration.get().count(),
                                           .readyDuration = 0,
                                           .earliestVsync = mVsync.lastCallbackTime.count()});
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="schedule" tabindex="-1"><a class="header-anchor" href="#schedule" aria-hidden="true">#</a> schedule</h3><p>上面的代码是通过 Vsync 结构体的 registration 对象调用 schedule 方法。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.h
struct Vsync {
    frametimeline::TokenManager* tokenManager = nullptr;
    std::unique_ptr&lt;scheduler::VSyncCallbackRegistration&gt; registration;

    mutable std::mutex mutex;
    TracedOrdinal&lt;std::chrono::nanoseconds&gt; workDuration
            GUARDED_BY(mutex) = {&quot;VsyncWorkDuration-sf&quot;, std::chrono::nanoseconds(0)};
    std::chrono::nanoseconds lastCallbackTime GUARDED_BY(mutex) = std::chrono::nanoseconds{0};
    std::optional&lt;nsecs_t&gt; scheduledFrameTime GUARDED_BY(mutex);
    TracedOrdinal&lt;int&gt; value = {&quot;VSYNC-sf&quot;, 0};
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>间接的调用到 VsynDispatch 的 schedule 方法。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp
ScheduleResult VSyncCallbackRegistration::schedule(VSyncDispatch::ScheduleTiming scheduleTiming) {
    if (!mValidToken) {
        return std::nullopt;
    }
    return mDispatch.get().schedule(mToken, scheduleTiming);
}

frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp
ScheduleResult VSyncDispatchTimerQueue::schedule(CallbackToken token,
                                                 ScheduleTiming scheduleTiming) {
    ScheduleResult result;
    {
        ...

        result = callback-&gt;schedule(scheduleTiming, mTracker, now);
        if (!result.has_value()) {
            return result;
        }

        if (callback-&gt;wakeupTime() &lt; mIntendedWakeupTime - mTimerSlack) {
            rearmTimerSkippingUpdateFor(now, it);
        }
    }

    return result;
}

void VSyncDispatchTimerQueue::rearmTimerSkippingUpdateFor(
        nsecs_t now, CallbackMap::iterator const&amp; skipUpdateIt) {
    ...

    if (min &amp;&amp; min &lt; mIntendedWakeupTime) {
        ...
        setTimer(*min, now);
    } else {
        ...
    }
}


void VSyncDispatchTimerQueue::setTimer(nsecs_t targetTime, nsecs_t /*now*/) {
    mIntendedWakeupTime = targetTime;
    mTimeKeeper-&gt;alarmAt(std::bind(&amp;VSyncDispatchTimerQueue::timerCallback, this),
                         mIntendedWakeupTime);
    mLastTimerSchedule = mTimeKeeper-&gt;now();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中的 mToken 是当初 SF 注册的到 VsyncDispatch 的索引，通过 mToken 可以找到注册到 VsyncDispatch 中的 VsyncDispatchTimerQueueEntry 对象，这个对象记录了很多信息，包括回调到 SF 的函数地址，下一次发送VSYNC信号的时间等等。</p><h2 id="vsync-sf-产生和发射" tabindex="-1"><a class="header-anchor" href="#vsync-sf-产生和发射" aria-hidden="true">#</a> VSYNC-sf 产生和发射</h2><p>从前面的代码可以看到，当应用上帧的时候，SurfaceFlinger 就会去申请 VSYNC-sf 的信号，那申请的 VSYNC-sf 的信号，什么时候会发给 SurfaceFlinger，去做合成的动作。从前面的代码，已经可以看到申请信息的时候，已经调用到 VsyncDispatch 的 schedule 的方法。</p><p>要了解 VSYNC-sf 的发射路径，需要仔细阅读 VsyncDispatch 的子类的实现逻辑，查看 VSyncDispatchTimerQueue.cpp 的代码如下：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp
ScheduleResult VSyncDispatchTimerQueue::schedule(CallbackToken token,
                                                 ScheduleTiming scheduleTiming) {
    ScheduleResult result;
    {
        std::lock_guard lock(mMutex);

        auto it = mCallbacks.find(token);
        if (it == mCallbacks.end()) {
            return result;
        }
        auto&amp; callback = it-&gt;second;
        auto const now = mTimeKeeper-&gt;now();

        /* If the timer thread will run soon, we&#39;ll apply this work update via the callback
         * timer recalculation to avoid cancelling a callback that is about to fire. */
        auto const rearmImminent = now &gt; mIntendedWakeupTime;
        if (CC_UNLIKELY(rearmImminent)) {
            callback-&gt;addPendingWorkloadUpdate(scheduleTiming);
            return getExpectedCallbackTime(mTracker, now, scheduleTiming);
        }

        result = callback-&gt;schedule(scheduleTiming, mTracker, now);
        if (!result.has_value()) {
            return result;
        }

        if (callback-&gt;wakeupTime() &lt; mIntendedWakeupTime - mTimerSlack) {
            rearmTimerSkippingUpdateFor(now, it);
        }
    }

    return result;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的代码，token 是编号，就是代表 sf，app 或者 appSF 注册到 VsyncDispatch 的索引值，VsyncDispatch 中有一个集合记录这三个的回调信息，也就是 mCallbacks ，这个里面存储了一个对象 VsyncDispatchtimerQueueEntry ，这个类很关键，它保存了回调的函数指针，回调的名字和两个信号直接的误差值等等。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>/frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatch.h
struct ScheduleTiming {
    nsecs_t workDuration = 0;
    nsecs_t readyDuration = 0;
    nsecs_t earliestVsync = 0;

     bool operator==(const ScheduleTiming&amp; other) const {
         return workDuration == other.workDuration &amp;&amp; readyDuration == other.readyDuration &amp;&amp;
                 earliestVsync == other.earliestVsync;
     }

     bool operator!=(const ScheduleTiming&amp; other) const { return !(*this == other); }
 };
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个类保存了几个关键信息，有一个ArmingInfo是参与计算Vsync唤醒的时间信息。当 SurfaceFlinger 申请Vsync-sf的信号，从上面的 schedule方法传入一个 ScheduleTiming 结构体。</p><p>这个结构体会记录三个值，workDuration，readyDuration。这两个值是固定的，而且这两个值在不同的刷新率下都是不一样的，都是参与计算Vsync信号发射的时间，我们这边只重点关注 earliestVsync，这个是上一个 Vsync 发射的时间。 这个值是很关键的，根据这个值，再通过一个软件模型校准的值，获得下一次 Vsync 发射的时间值。</p><p>前面的 schedule 方法中，假如是 sf 的 token 来申请 Vsync 信息，会调用 callback-&gt;schedule 这个方法，这个方法很重要，主要是根据上一次的 vysnc 发射时间计算下一次的 Vsync 发射时间。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp
ScheduleResult VSyncDispatchTimerQueueEntry::schedule(VSyncDispatch::ScheduleTiming timing,
                                                      VSyncTracker&amp; tracker, nsecs_t now) {
    auto nextVsyncTime = tracker.nextAnticipatedVSyncTimeFrom(
            std::max(timing.earliestVsync, now + timing.workDuration + timing.readyDuration));
    auto nextWakeupTime = nextVsyncTime - timing.workDuration - timing.readyDuration;

    bool const wouldSkipAVsyncTarget =
            mArmedInfo &amp;&amp; (nextVsyncTime &gt; (mArmedInfo-&gt;mActualVsyncTime + mMinVsyncDistance));
    bool const wouldSkipAWakeup =
            mArmedInfo &amp;&amp; ((nextWakeupTime &gt; (mArmedInfo-&gt;mActualWakeupTime + mMinVsyncDistance)));
    if (wouldSkipAVsyncTarget &amp;&amp; wouldSkipAWakeup) {
        return getExpectedCallbackTime(nextVsyncTime, timing);
    }

    bool const alreadyDispatchedForVsync = mLastDispatchTime &amp;&amp;
            ((*mLastDispatchTime + mMinVsyncDistance) &gt;= nextVsyncTime &amp;&amp;
             (*mLastDispatchTime - mMinVsyncDistance) &lt;= nextVsyncTime);
    if (alreadyDispatchedForVsync) {
        nextVsyncTime =
                tracker.nextAnticipatedVSyncTimeFrom(*mLastDispatchTime + mMinVsyncDistance);
        nextWakeupTime = nextVsyncTime - timing.workDuration - timing.readyDuration;
    }

    auto const nextReadyTime = nextVsyncTime - timing.readyDuration;
    mScheduleTiming = timing;
    mArmedInfo = {nextWakeupTime, nextVsyncTime, nextReadyTime};
    return getExpectedCallbackTime(nextVsyncTime, timing);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码是一个名为 <code>VSyncDispatchTimerQueueEntry::schedule</code> 的成员函数，它在 Android 开源项目（AOSP）中可能用于计算和设置垂直同步（VSync）的调度时间。具体来说，这个函数接收一个 <code>ScheduleTiming</code> 结构体、一个 VSync 跟踪器，以及当前时间作为参数，并返回一个 <code>ScheduleResult</code> 结构体。这个函数的主要功能是计算下一个 VSync 时间、下一个唤醒时间，并设置调度时间。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token comment">// 成员函数 schedule，接收一个 ScheduleTiming 结构体、一个 VSync 跟踪器，以及当前时间作为参数</span>
ScheduleResult <span class="token class-name">VSyncDispatchTimerQueueEntry</span><span class="token double-colon punctuation">::</span><span class="token function">schedule</span><span class="token punctuation">(</span>VSyncDispatch<span class="token double-colon punctuation">::</span>ScheduleTiming timing<span class="token punctuation">,</span>
                                                      VSyncTracker<span class="token operator">&amp;</span> tracker<span class="token punctuation">,</span> nsecs_t now<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 计算下一个 VSync 时间，这个时间是从 timing.earliestVsync 和 now + timing.workDuration + timing.readyDuration 中的较大值开始的</span>
    <span class="token keyword">auto</span> nextVsyncTime <span class="token operator">=</span> tracker<span class="token punctuation">.</span><span class="token function">nextAnticipatedVSyncTimeFrom</span><span class="token punctuation">(</span>
            std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>timing<span class="token punctuation">.</span>earliestVsync<span class="token punctuation">,</span> now <span class="token operator">+</span> timing<span class="token punctuation">.</span>workDuration <span class="token operator">+</span> timing<span class="token punctuation">.</span>readyDuration<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 计算下一个唤醒时间，这个时间是下一个 VSync 时间减去工作时长和准备时长</span>
    <span class="token keyword">auto</span> nextWakeupTime <span class="token operator">=</span> nextVsyncTime <span class="token operator">-</span> timing<span class="token punctuation">.</span>workDuration <span class="token operator">-</span> timing<span class="token punctuation">.</span>readyDuration<span class="token punctuation">;</span>

    <span class="token comment">// 检查是否会跳过一个 VSync 目标，如果会的话，返回预期的回调时间</span>
    <span class="token keyword">bool</span> <span class="token keyword">const</span> wouldSkipAVsyncTarget <span class="token operator">=</span>
            mArmedInfo <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>nextVsyncTime <span class="token operator">&gt;</span> <span class="token punctuation">(</span>mArmedInfo<span class="token operator">-&gt;</span>mActualVsyncTime <span class="token operator">+</span> mMinVsyncDistance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 检查是否会跳过一个唤醒，如果会的话，返回预期的回调时间</span>
    <span class="token keyword">bool</span> <span class="token keyword">const</span> wouldSkipAWakeup <span class="token operator">=</span>
            mArmedInfo <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nextWakeupTime <span class="token operator">&gt;</span> <span class="token punctuation">(</span>mArmedInfo<span class="token operator">-&gt;</span>mActualWakeupTime <span class="token operator">+</span> mMinVsyncDistance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>wouldSkipAVsyncTarget <span class="token operator">&amp;&amp;</span> wouldSkipAWakeup<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">getExpectedCallbackTime</span><span class="token punctuation">(</span>nextVsyncTime<span class="token punctuation">,</span> timing<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 检查是否已经为 VSync 调度了回调，如果是的话，重新计算下一个 VSync 时间和下一个唤醒时间</span>
    <span class="token keyword">bool</span> <span class="token keyword">const</span> alreadyDispatchedForVsync <span class="token operator">=</span> mLastDispatchTime <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>mLastDispatchTime <span class="token operator">+</span> mMinVsyncDistance<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> nextVsyncTime <span class="token operator">&amp;&amp;</span>
             <span class="token punctuation">(</span><span class="token operator">*</span>mLastDispatchTime <span class="token operator">-</span> mMinVsyncDistance<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> nextVsyncTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>alreadyDispatchedForVsync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nextVsyncTime <span class="token operator">=</span>
                tracker<span class="token punctuation">.</span><span class="token function">nextAnticipatedVSyncTimeFrom</span><span class="token punctuation">(</span><span class="token operator">*</span>mLastDispatchTime <span class="token operator">+</span> mMinVsyncDistance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextWakeupTime <span class="token operator">=</span> nextVsyncTime <span class="token operator">-</span> timing<span class="token punctuation">.</span>workDuration <span class="token operator">-</span> timing<span class="token punctuation">.</span>readyDuration<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 计算下一个准备时间，这个时间是下一个 VSync 时间减去准备时长</span>
    <span class="token keyword">auto</span> <span class="token keyword">const</span> nextReadyTime <span class="token operator">=</span> nextVsyncTime <span class="token operator">-</span> timing<span class="token punctuation">.</span>readyDuration<span class="token punctuation">;</span>
    <span class="token comment">// 更新 mScheduleTiming 和 mArmedInfo 的值</span>
    mScheduleTiming <span class="token operator">=</span> timing<span class="token punctuation">;</span>
    mArmedInfo <span class="token operator">=</span> <span class="token punctuation">{</span>nextWakeupTime<span class="token punctuation">,</span> nextVsyncTime<span class="token punctuation">,</span> nextReadyTime<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回预期的回调时间</span>
    <span class="token keyword">return</span> getExpectedCallback
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个是最核心的逻辑，从上面代码可以看到下面几个点的逻辑顺序。</p><ul><li><p>先传入之前的Vsync发射的时间，timeing这个对象，就是sf上一次发射信息的时间信息，这边有三个值，workDuration和readyDuration的值在不同刷新率下是不一样的，而且sf和app的配置也是不一样的，这两个值在参与计算值感觉只是一个阈值，并没有什么实际作用。 我们先举例这两个值都是0，在解释下上面的代码，我们先判断当前时间和上一次Vsync-sf发射的时间的最大值。</p></li><li><p>把最大值传递个VsyncTracker中的nextAnticipatedVsyncTimeFrom方法中，从传入的参数根据这个方法名字，可以获得下一次Vsync发射的时间，如果获取的发射时间大于mArmedInfo中记录的上一次发射的时间，需要把这次的申请的发射时间跳过不处理，还是用之前的发射时间。</p></li><li><p>如果还记录着最后一次vsync发射的时间，这个时间和下一次vsync发射的时间在一定的误差之中，重新校正下一次发发射时间，拿上一次最后发射的时间传到VsyncTracker中，获取下一次Vsync发射时间。 然后把发射时间，减去固定的值，保存到mArmedInfo中，用于后面的设置定时器。</p></li></ul><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>/frameworks/native/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp
if (callback-&gt;wakeupTime() &lt; mIntendedWakeupTime - mTimerSlack) {
    rearmTimerSkippingUpdateFor(now, it);//发射Vsync信号
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法执行完毕之后，会判断下一次发射的时间，和上一次设置的发射的时间做比较，如果小于这个值，需要把最近的发射时间重新设置到定时器中，这个 mIntendedWakeupTiem 变量在每次正常发射之后，这个值通常会设置为默认值，是int 8个字节的最大值 9223372036854775807，所以通常就会走到 rearmTimerSkippingUpdateFor 的函数中。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void VSyncDispatchTimerQueue::rearmTimerSkippingUpdateFor(
        nsecs_t now, CallbackMap::iterator const&amp; skipUpdateIt) {
    std::optional&lt;nsecs_t&gt; min;
    std::optional&lt;nsecs_t&gt; targetVsync;
    std::optional&lt;std::string_view&gt; nextWakeupName;
    for (auto it = mCallbacks.begin(); it != mCallbacks.end(); it++) {
        auto&amp; callback = it-&gt;second;
        if (!callback-&gt;wakeupTime() &amp;&amp; !callback-&gt;hasPendingWorkloadUpdate()) {
            continue;
        }

        if (it != skipUpdateIt) {
            callback-&gt;update(mTracker, now);
        }
        auto const wakeupTime = *callback-&gt;wakeupTime();
        if (!min || *min &gt; wakeupTime) {
            nextWakeupName = callback-&gt;name();
            min = wakeupTime;
            targetVsync = callback-&gt;targetVsync();
        }
    }

    if (min &amp;&amp; min &lt; mIntendedWakeupTime) {
        if (ATRACE_ENABLED() &amp;&amp; nextWakeupName &amp;&amp; targetVsync) {
            ftl::Concat trace(ftl::truncated&lt;5&gt;(*nextWakeupName), &quot; alarm in &quot;, ns2us(*min - now),
                              &quot;us; VSYNC in &quot;, ns2us(*targetVsync - now), &quot;us&quot;);
            ATRACE_NAME(trace.c_str());
        }
        setTimer(*min, now);
    } else {
        ATRACE_NAME(&quot;cancel timer&quot;);
        cancelTimer();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的函数中，可以很明显的看出来，SurfaceFlinger 申请的 Vsync-sf 发射时间，把下一次唤醒的时间传入这个函数中，首先在mCallbacks 中查找有没有发现发射更早的时间，假如app申请的发射时间在处理中，如果传过来的是Vsync-sf的发射时间，会把app或者appSf的发射时间更新下，然后从中找一个最近的，最快的发射时间设置到定时器中。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void VSyncDispatchTimerQueue::setTimer(nsecs_t targetTime, nsecs_t /*now*/) {
    mIntendedWakeupTime = targetTime;
    mTimeKeeper-&gt;alarmAt(std::bind(&amp;VSyncDispatchTimerQueue::timerCallback, this),
                         mIntendedWakeupTime);
    mLastTimerSchedule = mTimeKeeper-&gt;now();
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定时器就是前面介绍的 mTimer，我们把下次发射的时间设置到定时器中，会在对应的时间内回调到 VsynDispatchTimerQueue 的 timerCallback 方法中。然后把最近的一次发射时间设置给 mIntendedWakerupTime 这个变量。</p><p>假如 Vsync-sf 的定时器设置给 Timer 之后，接下来就是 Vsync-sf 的发射过程，假如Timer的定时器到时间之后，会调用到 VsynDispatchTimerQueue 的 timerCallback 中，这个 timerCallback 方法很重要。是分发 SW-VSYNC 的地方。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void VSyncDispatchTimerQueue::timerCallback() {
    struct Invocation {
        std::shared_ptr&lt;VSyncDispatchTimerQueueEntry&gt; callback;
        nsecs_t vsyncTimestamp;
        nsecs_t wakeupTimestamp;
        nsecs_t deadlineTimestamp;
    };
    std::vector&lt;Invocation&gt; invocations;
    {
        std::lock_guard lock(mMutex);
        auto const now = mTimeKeeper-&gt;now();
        mLastTimerCallback = now;
        for (auto it = mCallbacks.begin(); it != mCallbacks.end(); it++) {
            auto&amp; callback = it-&gt;second;
            auto const wakeupTime = callback-&gt;wakeupTime();
            if (!wakeupTime) {
                continue;
            }

            auto const readyTime = callback-&gt;readyTime();

            auto const lagAllowance = std::max(now - mIntendedWakeupTime, static_cast&lt;nsecs_t&gt;(0));
            if (*wakeupTime &lt; mIntendedWakeupTime + mTimerSlack + lagAllowance) {
                callback-&gt;executing();
                invocations.emplace_back(Invocation{callback, *callback-&gt;lastExecutedVsyncTarget(),
                                                    *wakeupTime, *readyTime});
            }
        }

        mIntendedWakeupTime = kInvalidTime;
        rearmTimer(mTimeKeeper-&gt;now());
    }

    for (auto const&amp; invocation : invocations) {
        invocation.callback-&gt;callback(invocation.vsyncTimestamp, invocation.wakeupTimestamp,
                                      invocation.deadlineTimestamp);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的代码流程中，可以看到当发射的时间回调这个方法中，会在mCallbacks的集合中查找符合这次发射的时间的匹配者， 先判断该对象中的发射时间是否有效，如果有效的话，获取当前的时间信息和发射时间的差值。因为设置给定时器的唤醒时间，和当前时间按理是一致的，但是因为软件实现肯定是有偏差值的，所以拿发射的时间值，和真正的发射的时间值有个校验。如果符合发射的时间，则把需要发射的对象放到invocation的集合中。然后遍历这个集合挨个把Vsync信号发射给对应的代码。</p><h2 id="vsync-app-的申请和发射" tabindex="-1"><a class="header-anchor" href="#vsync-app-的申请和发射" aria-hidden="true">#</a> VSYNC-app 的申请和发射</h2><h3 id="应用向-surfaceflinger-注册-connection" tabindex="-1"><a class="header-anchor" href="#应用向-surfaceflinger-注册-connection" aria-hidden="true">#</a> 应用向 Surfaceflinger 注册 connection</h3><p>前面讲了 Vsync-sf 的发射，为什么这两块要分开说，因为再 Android S 版本之前的版本，Vsync-app 和 Vsync-sf 都是EventThread 的形式，在12版本上 Vsync-sf 的逻辑去掉 EventThread 的形式，谷歌做了重构，所以就剩下 Vsync-app 还是采用 EventThread 的形式。</p><p>接下来我们讲下应用怎么去申请 Vsync-app 的信号，本章节主要讲解 SurfaceFlinger 里面的逻辑，针对应用怎么申请 Vsync-app 信息，简单的说下，就是通过 Choreographer 这个对象去申请 Vsync-app 的信号，然后通过其内部类 FrameDisplayEventReceiver 来接受 vsync 信号，也就是 Vsync-app 的发射最后到这个对象里面，来触发 app 刷新，核心就是 FrameDisplayEventReceiver 类，这个类的初始化在是 Choreographer的构造函数中。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>frameworks<span class="token operator">/</span>base<span class="token operator">/</span>core<span class="token operator">/</span>java<span class="token operator">/</span>android<span class="token operator">/</span>view<span class="token operator">/</span><span class="token class-name">Choreographer</span><span class="token punctuation">.</span>java
<span class="token keyword">private</span> <span class="token class-name">Choreographer</span><span class="token punctuation">(</span><span class="token class-name">Looper</span> looper<span class="token punctuation">,</span> <span class="token keyword">int</span> vsyncSource<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mLooper <span class="token operator">=</span> looper<span class="token punctuation">;</span>
    mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FrameHandler</span><span class="token punctuation">(</span>looper<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mDisplayEventReceiver <span class="token operator">=</span> <span class="token constant">USE_VSYNC</span>
            <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FrameDisplayEventReceiver</span><span class="token punctuation">(</span>looper<span class="token punctuation">,</span> vsyncSource<span class="token punctuation">)</span>
            <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    mLastFrameTimeNanos <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span>

    mFrameIntervalNanos <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1000000000</span> <span class="token operator">/</span> <span class="token function">getRefreshRate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    mCallbackQueues <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CallbackQueue</span><span class="token punctuation">[</span><span class="token constant">CALLBACK_LAST</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token constant">CALLBACK_LAST</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mCallbackQueues<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CallbackQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// b/68769804: For low FPS experiments.</span>
    <span class="token function">setFPSDivisor</span><span class="token punctuation">(</span><span class="token class-name">SystemProperties</span><span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token class-name">ThreadedRenderer</span><span class="token punctuation">.</span><span class="token constant">DEBUG_FPS_DIVISOR</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>FrameDisplayEventReceiver继承DisplayEventReceiver，在DisplayEventReceiver的构造方法中，调用nativeInit方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FrameDisplayEventReceiver</span> <span class="token keyword">extends</span> <span class="token class-name">DisplayEventReceiver</span>
        <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * Creates a display event receiver.
 */</span>
<span class="token keyword">public</span> <span class="token class-name">DisplayEventReceiver</span><span class="token punctuation">(</span><span class="token class-name">Looper</span> looper<span class="token punctuation">,</span> <span class="token keyword">int</span> vsyncSource<span class="token punctuation">,</span> <span class="token keyword">int</span> eventRegistration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mMessageQueue <span class="token operator">=</span> looper<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mReceiverPtr <span class="token operator">=</span> <span class="token function">nativeInit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DisplayEventReceiver</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mMessageQueue<span class="token punctuation">,</span>
            vsyncSource<span class="token punctuation">,</span> eventRegistration<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法会在初始化 NativeDisplayEventReceiver 对象， NativeDisplayEventReceiver 对象继承 DisplayEventDispatcher 对象，这个对象在初始化的时候，会初始化 mReceiver 对象，初始化这个 mReceiver 对象的时候会创建 DisplayEventReceiver 对象。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>/home/biezhihua/projects/aosp/frameworks/native/include/gui/DisplayEventReceiver.h
class DisplayEventReceiver {
public:

    ...

    /*
     * requestNextVsync() schedules the next Event::VSync. It has no effect
     * if the vsync rate is &gt; 0.
     */
    status_t requestNextVsync();


};

frameworks/native/libs/gui/DisplayEventReceiver.cpp
DisplayEventReceiver::DisplayEventReceiver(
        ISurfaceComposer::VsyncSource vsyncSource,
        ISurfaceComposer::EventRegistrationFlags eventRegistration) {
    sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService());
    if (sf != nullptr) {
        mEventConnection = sf-&gt;createDisplayEventConnection(vsyncSource, eventRegistration);
        if (mEventConnection != nullptr) {
            mDataChannel = std::make_unique&lt;gui::BitTube&gt;();
            const auto status = mEventConnection-&gt;stealReceiveChannel(mDataChannel.get());
            if (!status.isOk()) {
                ALOGE(&quot;stealReceiveChannel failed: %s&quot;, status.toString8().c_str());
                mInitError = std::make_optional&lt;status_t&gt;(status.transactionError());
                mDataChannel.reset();
                mEventConnection.clear();
            }
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>/frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp

EventThreadConnection::EventThreadConnection(
        EventThread* eventThread, uid_t callingUid, ResyncCallback resyncCallback,
        ISurfaceComposer::EventRegistrationFlags eventRegistration)
      : resyncCallback(std::move(resyncCallback)),
        mOwnerUid(callingUid),
        mEventRegistration(eventRegistration),
        mEventThread(eventThread),
        mChannel(gui::BitTube::DefaultSize) {}

binder::Status EventThreadConnection::stealReceiveChannel(gui::BitTube* outChannel) {
    std::scoped_lock lock(mLock);
    if (mChannel.initCheck() != NO_ERROR) {
        return binder::Status::fromStatusT(NAME_NOT_FOUND);
    }

    outChannel-&gt;setReceiveFd(mChannel.moveReceiveFd());
    outChannel-&gt;setSendFd(base::unique_fd(dup(mChannel.getSendFd())));
    return binder::Status::ok();
}

void EventThreadConnection::onFirstRef() {
    // NOTE: mEventThread doesn&#39;t hold a strong reference on us
    mEventThread-&gt;registerDisplayEventConnection(this);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个构造方法中有很重要的步骤，具体如下：</p><ul><li><p>获取 SurfaceFlinger 的 binder 代理对象 BpSurfaceComposer ，就可以调用 SurfaceFlinger binder 服务端的接口</p></li><li><p>调用 SurfaceFlinger 的binder接口创建一个connection，这个 connection 就是注册到 EventThread 中，用来判断是不是要接受Vsync-app信号。</p><ul><li>在 SurfaceFlinger 创建这个这个 connection 是会走到 EventThread 的 createEventConnection ，在 EventThreadConnection 的构造方法中会创建一个 socket 对象。这个 mEventConnection 也是一个 binder 对象， IDisplayEventConnection ， SurfaceFlinger 进程返回 BpDisplayEventConnection 赋值给 mEventConection。而服务端就是 EventThreadConnection。</li></ul></li><li><p>在DisplayEventReceiver 构造方法中也会创建一个空的 gui::BitTubet 对象，并且调用 connection 的 binder 接口，把 socket 对象设置到 EventThreadConnection 对象中，这个操作就是把两边关联起来，从代码实现可以看出是讲 SurfaceFlinge r进程中服务端创建的 gui::BitTube 对象赋值给应用端空的 gui::BitTube 对象。</p></li><li><p>然后 EventThreadConnection 初始化好之后，在第一次引用调用的时候，会把自己注册到 EventThread 的集合中 mDisplayEventConnections。</p></li></ul><h3 id="vsync-app-的申请" tabindex="-1"><a class="header-anchor" href="#vsync-app-的申请" aria-hidden="true">#</a> VSYNC-app 的申请</h3><p>接下来我们主要讲解app怎么向SurfaceFlinger申请Vsync-app的，然后Vsync-app的信号怎么发射到应用的。</p><p>正常应用要申请Vsync信号，都是通过Choregrapher对象调用postFrameCallback方法，而应用在绘制的时候也会调用这个方法，就是ViewRootImpl中的scheduleTraversals方法，其实在函数实现中也是调用了Choregrapher的postFrameCallback方法。</p><p>而postFrameCallback方法其实是调用Choreographer的scheduleFameLocked方法，调用到scheduleVsyncLocked方法，在调用到NativeDisplayEventReceiver的scheduleVsync方法中。因为继承关系查看DisplayEventDispather的scheduleVsync方法，可以看到是通过DisplayEventReceiver去请求下一个Vsync信号。</p><p>我们看下DisplayEventReceiver的requestNextVsync方法</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>status_t DisplayEventReceiver::requestNextVsync() {
    if (mEventConnection != nullptr) {
        mEventConnection-&gt;requestNextVsync();
        return NO_ERROR;
    }
    return mInitError.has_value() ? mInitError.value() : NO_INIT;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会调用到mEeventConnection的requestNextVsync接口，mEventConnection是binder的代理，最终会调用到SurfaceFlinger进程的binder服务端EventThreadConnection的requestNextVsync，接下来就是申请Vsyn-app信号，SurfaceFlinger模块的代码逻辑了。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void EventThread::requestNextVsync(const sp&lt;EventThreadConnection&gt;&amp; connection) {
    if (connection-&gt;resyncCallback) {
        connection-&gt;resyncCallback();
    }

    std::lock_guard&lt;std::mutex&gt; lock(mMutex);

    if (connection-&gt;vsyncRequest == VSyncRequest::None) {
        connection-&gt;vsyncRequest = VSyncRequest::Single;
        mCondition.notify_all();
    } else if (connection-&gt;vsyncRequest == VSyncRequest::SingleSuppressCallback) {
        connection-&gt;vsyncRequest = VSyncRequest::Single;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用栈：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>thread #17, name = &#39;binder:453_5&#39;, stop reason = step over
frame #0: 0x00005d3dc1ab6b1e surfaceflinger`android::impl::EventThread::requestNextVsync(this=0x00007b0c11c8a250, connection=0x00007b0b38d058a0) at EventThread.cpp:338:9
frame #1: 0x00005d3dc1ab5c8c surfaceflinger`android::EventThreadConnection::requestNextVsync(this=&lt;unavailable&gt;) at EventThread.cpp:197:19
frame #2: 0x00005d3dc1b77a12 surfaceflinger`android::gui::BnDisplayEventConnection::onTransact(this=0x00007b0be1c8f8f0, _aidl_code=&lt;unavailable&gt;, _aidl_data=0x00007b0b38d05b00, _aidl_reply=0x00007b0b38d05a80, _aidl_flags=&lt;unavailable&gt;) at IDisplayEventConnection.cpp:214:44
frame #3: 0x00007b0dd756d6f1 libbinder.so`android::BBinder::transact(this=0x00007b0be1c8f8f0, code=3, data=0x00007b0b38d05b00, reply=0x00007b0b38d05a80, flags=17) at Binder.cpp:297:19
frame #4: 0x00007b0dd7578834 libbinder.so`android::IPCThreadState::executeCommand(this=0x00007b0c21c9dd40, cmd=&lt;unavailable&gt;) at IPCThreadState.cpp:1293:68
frame #5: 0x00007b0dd75782be libbinder.so`android::IPCThreadState::getAndExecuteCommand(this=0x00007b0c21c9dd40) at IPCThreadState.cpp:563:18
frame #6: 0x00007b0dd7578c90 libbinder.so`android::IPCThreadState::joinThreadPool(this=0x00007b0c21c9dd40, isMain=&lt;unavailable&gt;) at IPCThreadState.cpp:649:18
frame #7: 0x00007b0dd75a89e8 libbinder.so`android::PoolThread::threadLoop(this=0x00007b0bc1c93140) at ProcessState.cpp:72:33
frame #8: 0x00007b0dddfe4e56 libutils.so`android::Thread::_threadLoop(user=0x00007b0bc1c93140) at Mutex.h:0:12
frame #9: 0x00007b0dd1d4ed9b libc.so`__pthread_start(arg=0x00007b0b38d05cf0) at pthread_create.cpp:364:18
frame #10: 0x00007b0dd1ce2d48 libc.so`::__start_thread(fn=(libc.so`__pthread_start(void*) at pthread_create.cpp:339), arg=0x00007b0b38d05cf0)(void *), void *) at clone.cpp:53:16
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从代码中可以看出来，会把当前的申请Vsync-app的Connection的vsyncRequest赋值为 VsyncRequest::Single。我们可以理解一个应用就代表一个Connection。</p><p>如果某个应用的申请了Vsync-app信号，就会把对应的EventThreadConnection对象中的vsyncRequest变量进行重新赋值。</p><p>接下来看看EventThread如何处理，我们要从EventThread的线程函数看起：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>
void EventThread::threadMain(std::unique_lock&lt;std::mutex&gt;&amp; lock) {
    DisplayEventConsumers consumers;

    while (mState != State::Quit) {
        std::optional&lt;DisplayEventReceiver::Event&gt; event;

        // Determine next event to dispatch.
        if (!mPendingEvents.empty()) {
            event = mPendingEvents.front();
            mPendingEvents.pop_front();

            switch (event-&gt;header.type) {
                case DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:
                    if (event-&gt;hotplug.connected &amp;&amp; !mVSyncState) {
                        mVSyncState.emplace(event-&gt;header.displayId);
                    } else if (!event-&gt;hotplug.connected &amp;&amp; mVSyncState &amp;&amp;
                               mVSyncState-&gt;displayId == event-&gt;header.displayId) {
                        mVSyncState.reset();
                    }
                    break;

                case DisplayEventReceiver::DISPLAY_EVENT_VSYNC:
                    if (mInterceptVSyncsCallback) {
                        mInterceptVSyncsCallback(event-&gt;header.timestamp);
                    }
                    break;
            }
        }

        bool vsyncRequested = false;

        // Find connections that should consume this event.
        auto it = mDisplayEventConnections.begin();
        while (it != mDisplayEventConnections.end()) {
            if (const auto connection = it-&gt;promote()) {
                vsyncRequested |= connection-&gt;vsyncRequest != VSyncRequest::None;

                if (event &amp;&amp; shouldConsumeEvent(*event, connection)) {
                    consumers.push_back(connection);
                }

                ++it;
            } else {
                it = mDisplayEventConnections.erase(it);
            }
        }

        if (!consumers.empty()) {
            dispatchEvent(*event, consumers);
            consumers.clear();
        }

        State nextState;
        if (mVSyncState &amp;&amp; vsyncRequested) {
            nextState = mVSyncState-&gt;synthetic ? State::SyntheticVSync : State::VSync;
        } else {
            ALOGW_IF(!mVSyncState, &quot;Ignoring VSYNC request while display is disconnected&quot;);
            nextState = State::Idle;
        }

        if (mState != nextState) {
            if (mState == State::VSync) {
                mVSyncSource-&gt;setVSyncEnabled(false);
            } else if (nextState == State::VSync) {
                mVSyncSource-&gt;setVSyncEnabled(true);
            }

            mState = nextState;
        }

        if (event) {
            continue;
        }

        // Wait for event or client registration/request.
        if (mState == State::Idle) {
            mCondition.wait(lock);
        } else {
            // Generate a fake VSYNC after a long timeout in case the driver stalls. When the
            // display is off, keep feeding clients at 60 Hz.
            const std::chrono::nanoseconds timeout =
                    mState == State::SyntheticVSync ? 16ms : 1000ms;
            if (mCondition.wait_for(lock, timeout) == std::cv_status::timeout) {
                if (mState == State::VSync) {
                    ALOGW(&quot;Faking VSYNC due to driver stall for thread %s&quot;, mThreadName);
                    std::string debugInfo = &quot;VsyncSource debug info:\n&quot;;
                    mVSyncSource-&gt;dump(debugInfo);
                    // Log the debug info line-by-line to avoid logcat overflow
                    auto pos = debugInfo.find(&#39;\n&#39;);
                    while (pos != std::string::npos) {
                        ALOGW(&quot;%s&quot;, debugInfo.substr(0, pos).c_str());
                        debugInfo = debugInfo.substr(pos + 1);
                        pos = debugInfo.find(&#39;\n&#39;);
                    }
                }

                LOG_FATAL_IF(!mVSyncState);
                const auto now = systemTime(SYSTEM_TIME_MONOTONIC);
                const auto deadlineTimestamp = now + timeout.count();
                const auto expectedVSyncTime = deadlineTimestamp + timeout.count();
                mPendingEvents.push_back(makeVSync(mVSyncState-&gt;displayId, now,
                                                   ++mVSyncState-&gt;count, expectedVSyncTime,
                                                   deadlineTimestamp));
            }
        }
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>EventThread的线程函数循环调用，一方面检测是否有Vsync信号发送过来了mPendingEvent，一方面检查是否有app请求了Vsync信号，如果有Vsync信号，而且有app请求了Vsync，则通过Connection把Vsync事件发送到对端。</p><p>从代码的的细节可以看出几个点：</p><ul><li><p>检查是否有VsyncDispatch是否发送Vsync过来，所以要要遍历mPendingEvent</p></li><li><p>检查是否有app对Vsync感兴趣，所以要遍历EventThread的mDisplayEventConnections。</p></li><li><p>如果有Vsyn事件过来，但是没人对它感兴趣，说们本次Vsync就可以关闭了，见上面的mVsyncSource-&gt;setVsyncEnabled(false)方法。</p></li><li><p>如果有app申请了Vsync，但是没有接受到Vsync事件，可能是把之前的Vsync关了，所以要从新打开，并坐等下次Vsync的到来，但是为了保证安全，不能死等，所以设置一个timeout的时间。</p></li></ul><h3 id="vsync-app-的发射" tabindex="-1"><a class="header-anchor" href="#vsync-app-的发射" aria-hidden="true">#</a> VSYNC-app 的发射</h3><p>这个方法是开关Vsync-app信号的函数，从这个函数的实现，是间接调用mCallbackRepeater的start和stop方法。而CallbackRepeater是在创建DispSyncSource对象构造方法中创建的。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/DispSyncSource.cpp
DispSyncSource::DispSyncSource(VSyncDispatch&amp; vSyncDispatch, VSyncTracker&amp; vSyncTracker,
                               std::chrono::nanoseconds workDuration,
                               std::chrono::nanoseconds readyDuration, bool traceVsync,
                               const char* name)
      : mName(name),
        mValue(base::StringPrintf(&quot;VSYNC-%s&quot;, name), 0),
        mTraceVsync(traceVsync),
        mVsyncOnLabel(base::StringPrintf(&quot;VsyncOn-%s&quot;, name)),
        mVSyncTracker(vSyncTracker),
        mWorkDuration(base::StringPrintf(&quot;VsyncWorkDuration-%s&quot;, name), workDuration),
        mReadyDuration(readyDuration) {
    mCallbackRepeater =
            std::make_unique&lt;CallbackRepeater&gt;(vSyncDispatch,
                                               std::bind(&amp;DispSyncSource::onVsyncCallback, this,
                                                         std::placeholders::_1,
                                                         std::placeholders::_2,
                                                         std::placeholders::_3),
                                               name, workDuration, readyDuration,
                                               std::chrono::steady_clock::now().time_since_epoch());
}

void DispSyncSource::setVSyncEnabled(bool enable) {
    std::lock_guard lock(mVsyncMutex);
    if (enable) {
        mCallbackRepeater-&gt;start(mWorkDuration, mReadyDuration);
        // ATRACE_INT(mVsyncOnLabel.c_str(), 1);
    } else {
        mCallbackRepeater-&gt;stop();
        // ATRACE_INT(mVsyncOnLabel.c_str(), 0);
    }
    mEnabled = enable;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出CallbackRepeater对象传入了几个参数，一个是VsyncDispatch对象，一个回调的函数，是为了接受Vsync-app发射的信号。而在CallbackRepeater对象中的构造方法会把CallbackRepeater的回调函数，初始化VsyncCallbackRegistration，这个是一个辅助类，在构造方法中会在VsyncDispatch注册回调函数和回调的名字等信息。可以这样理解，DispSyncSource是EventThread和VsyncDispatch的纽带。</p><p>DispsyncSource中，VsyncCallbackRegistration是一个辅助类主要是帮助VsyncDispatch注册回调函数而且。</p><p>所以app申请Vsycn-app信号，调用DispVsynSource的setVsyncEnabled的函数，是间接调用CallbackRepeater的start的函数，就是这个类封装了VsyncDispatch的操作，也就是调用VsyncDispatch的schedule函数。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void start(std::chrono::nanoseconds workDuration, std::chrono::nanoseconds readyDuration) {
    std::lock_guard lock(mMutex);
    mStarted = true;
    mWorkDuration = workDuration;
    mReadyDuration = readyDuration;

    auto const scheduleResult =
            mRegistration.schedule({.workDuration = mWorkDuration.count(),
                                    .readyDuration = mReadyDuration.count(),
                                    .earliestVsync = mLastCallTime.count()});
    LOG_ALWAYS_FATAL_IF((!scheduleResult.has_value()), &quot;Error scheduling callback&quot;);
}
void stop() {
    std::lock_guard lock(mMutex);
    LOG_ALWAYS_FATAL_IF(!mStarted, &quot;DispSyncInterface misuse: callback already stopped&quot;);
    mStarted = false;
    mRegistration.cancel();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从前面讲解Vsync-sf的申请和发射，我们知道了这个schedule函数是请求Vsync-app信号的函数，这块代码和Vsync-sf的申请是一样的，就是计算下一次Vsync-app唤醒的时间，通过timer机制，把这个Vsync-app信号回调到注册到VsyncDiaptch的函数。</p><p>从Vsync-app的申请来看，最后会回调到CallbackRepeater的callback函数中，在这个函数中会调用mCallback函数，而这个函数的回调方法是DispSyncSource中的onVysncCallback函数中。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void DispSyncSource::onVsyncCallback(nsecs_t vsyncTime, nsecs_t targetWakeupTime,
                                     nsecs_t readyTime) {
    VSyncSource::Callback* callback;
    {
        std::lock_guard lock(mCallbackMutex);
        callback = mCallback;
    }

    if (mTraceVsync) {
        mValue = (mValue + 1) % 2;
    }

    if (callback != nullptr) {
        callback-&gt;onVSyncEvent(targetWakeupTime, {vsyncTime, readyTime});
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个函数中，首先会在Vsync-app的trace上标记信息，也即是开头那张图片的信息，所以为什么是断断续续的，是因为Vsync-app申请本来就是随机的。</p><p>然后调用callback的onVysncEvent函数，而callback就是EventThread对象，最终调用到EventThread的onVsyncEvent中。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp
void EventThread::onVSyncEvent(nsecs_t timestamp, VSyncSource::VSyncData vsyncData) {
    std::lock_guard&lt;std::mutex&gt; lock(mMutex);

    LOG_FATAL_IF(!mVSyncState);
    mPendingEvents.push_back(makeVSync(mVSyncState-&gt;displayId, timestamp, ++mVSyncState-&gt;count,
                                       vsyncData.expectedPresentationTime,
                                       vsyncData.deadlineTimestamp));
    mCondition.notify_all();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从代码中可以看到，Vsync-app的信号加入到mPendingEvents中，然后唤醒theadMain的线程循环，然后找到对应的申请的应用，然后调用dispatchEvent函数</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void EventThread::dispatchEvent(const DisplayEventReceiver::Event&amp; event,
                                const DisplayEventConsumers&amp; consumers) {
    for (const auto&amp; consumer : consumers) {
        DisplayEventReceiver::Event copy = event;
        if (event.header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) {
            const int64_t frameInterval = mGetVsyncPeriodFunction(consumer-&gt;mOwnerUid);
            copy.vsync.vsyncData.frameInterval = frameInterval;
            generateFrameTimeline(copy.vsync.vsyncData, frameInterval, copy.header.timestamp,
                                  event.vsync.vsyncData.preferredExpectedPresentationTime(),
                                  event.vsync.vsyncData.preferredDeadlineTimestamp());
        }
        switch (consumer-&gt;postEvent(copy)) {
            case NO_ERROR:
                break;

            case -EAGAIN:
                // TODO: Try again if pipe is full.
                ALOGW(&quot;Failed dispatching %s for %s&quot;, toString(event).c_str(),
                      toString(*consumer).c_str());
                break;

            default:
                // Treat EPIPE and other errors as fatal.
                removeDisplayEventConnectionLocked(consumer);
        }
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>遍历DisplayEventConsumers的对象，挨个调用postEvent方法。</p><p>这个DisplayEventConsumers就是connection的vector集合对象，然后通过connection对象把Vsync事件发送出去。后面应用怎么接受到这个Vsync-app的信号，本章节就不分析，大家有兴趣的话可以自己下来了解下。</p><h2 id="sw-vsync-模型和校准" tabindex="-1"><a class="header-anchor" href="#sw-vsync-模型和校准" aria-hidden="true">#</a> SW VSYNC 模型和校准</h2><p>在Android S之前的版本，开关硬件VSync开关是有一个线程都做的，在12版本上面都已经做了重构。</p><h3 id="resynctohardwarevsync" tabindex="-1"><a class="header-anchor" href="#resynctohardwarevsync" aria-hidden="true">#</a> resyncToHardwareVsync</h3><p>在前面的根据上一次的发射时间获取下一次的发射时间，调用VsyncTracker的nextAnticipatedVsyncTimeFrom方法中。在这个模型中，我们要关注几个核心参数：</p><ul><li><p>period: VSYNC周期</p></li><li><p>mTimestamps: 硬件的时间戳样本集合</p></li></ul><p>在开机的时候，SurfaceFlinger在初始化Display之后，会调用resyncToHardwareVsync方法与硬件VSYNC进行同步，调用链如下：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>SurfaceFlinger::init()
 └--&gt;initializeDisplays()
      └--&gt;onInitializeDisplays()
           └--&gt;setPowerModeInternal()
                 └--&gt;resyncToHardwareVsync()
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>resyncToHardwareVsync的代码如下：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
void Scheduler::resyncToHardwareVsync(bool makeAvailable, Fps refreshRate) {
    {
        std::lock_guard&lt;std::mutex&gt; lock(mHWVsyncLock);
        if (makeAvailable) {
            mHWVsyncAvailable = makeAvailable;
        } else if (!mHWVsyncAvailable) {
            // Hardware vsync is not currently available, so abort the resync
            // attempt for now
            return;
        }
    }

    setVsyncPeriod(refreshRate.getPeriodNsecs());
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>makeAvailable默认传入true，period传入的是当前屏幕刷新率的周期值，这个在SurfaceFlinger初始化的时候，把硬件支持的帧率和周期都一对一保存起来，例如fps是60，period是16.666666。fps是90，period是11.111111。再调用到setVsyncPeriod，从这个方法名字可以看到，当屏幕的刷新率发生变化，软件模型肯定要重新同步硬件的时间戳信息，重新计算当前屏幕刷新率对应的period值。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
void Scheduler::setVsyncPeriod(nsecs_t period) {
    if (period &lt;= 0) return;

    std::lock_guard&lt;std::mutex&gt; lock(mHWVsyncLock);
    mVsyncSchedule-&gt;getController().startPeriodTransition(period);

    if (!mPrimaryHWVsyncEnabled) {
        mVsyncSchedule-&gt;getTracker().resetModel();
        mSchedulerCallback.setVsyncEnabled(true);
        mPrimaryHWVsyncEnabled = true;
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>mPrimaryHWVsyncEnabled这个变量默认为false，就会走到下面的逻辑中，resetModel方法会清空软件模型的记录的硬件时间戳集合，setVsyncEnabled方法把硬件回调给SurfaceFlinger的开关打开，这个回调方法打开之后，硬件的Vsync信息会通过回调接口通知给SurfaceFlinger，在这个回调接口中，会把硬件的Vsync信息保存到VsyncTracker中。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
void SurfaceFlinger::onComposerHalVsync(hal::HWDisplayId hwcDisplayId, int64_t timestamp,
                                        std::optional&lt;hal::VsyncPeriodNanos&gt; vsyncPeriod) {
    const std::string tracePeriod = [vsyncPeriod]() {
        if (ATRACE_ENABLED() &amp;&amp; vsyncPeriod) {
            std::stringstream ss;
            ss &lt;&lt; &quot;(&quot; &lt;&lt; *vsyncPeriod &lt;&lt; &quot;)&quot;;
            return ss.str();
        }
        return std::string();
    }();
    ATRACE_FORMAT(&quot;onComposerHalVsync%s&quot;, tracePeriod.c_str());

    Mutex::Autolock lock(mStateLock);
    const auto displayId = getHwComposer().toPhysicalDisplayId(hwcDisplayId);
    if (displayId) {
        const auto token = getPhysicalDisplayTokenLocked(*displayId);
        const auto display = getDisplayDeviceLocked(token);
        display-&gt;onVsync(timestamp);
    }

    if (!getHwComposer().onVsync(hwcDisplayId, timestamp)) {
        return;
    }

    const bool isActiveDisplay =
            displayId &amp;&amp; getPhysicalDisplayTokenLocked(*displayId) == mActiveDisplayToken;
    if (!isActiveDisplay) {
        // For now, we don&#39;t do anything with non active display vsyncs.
        return;
    }

    bool periodFlushed = false;
    mScheduler-&gt;addResyncSample(timestamp, vsyncPeriod, &amp;periodFlushed);
    if (periodFlushed) {
        modulateVsync(&amp;VsyncModulator::onRefreshRateChangeCompleted);
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如代码所示，mScheduler-&gt;addResyncSample方法把硬件的时间戳信息timestamp保存起来。</p><p>等于上面的代码干了三件事情：</p><ul><li><p>首先从HWC获取到硬件VSYNC的周期period，设置给VsyncController中。</p></li><li><p>VsyncTracker先清理之前记录的采样信息，准备开始硬件VSYNC采样</p></li><li><p>通过mSchedulerCallback的setVsyncEnabled方法打开硬件VSYNC事件上报</p></li></ul><p>相关代码如下： resetModel方法</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/VSyncPredictor.cpp

void VSyncPredictor::resetModel() {
    std::lock_guard lock(mMutex);
    mRateMap[mIdealPeriod] = {mIdealPeriod, 0};
    clearTimestamps();
}

void VSyncPredictor::clearTimestamps() {
    if (!mTimestamps.empty()) {
        auto const maxRb = *std::max_element(mTimestamps.begin(), mTimestamps.end());
        if (mKnownTimestamp) {
            mKnownTimestamp = std::max(*mKnownTimestamp, maxRb);
        } else {
            mKnownTimestamp = maxRb;
        }

        mTimestamps.clear();
        mLastTimestampIndex = 0;
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会清空mRateMap对应period的value对象，这个是一个结构体Model，会记录软件模型计算出来的Vsync周期。</p><h3 id="sw-vsync模型更新与校准" tabindex="-1"><a class="header-anchor" href="#sw-vsync模型更新与校准" aria-hidden="true">#</a> SW VSYNC模型更新与校准</h3><p>前面已经把硬件的VSYNC回调打开了，那么每次HW VSYNC事件上报时，会调用Schedule的 addResyncSample方法，也就是会调用VsyncController中的addHwVsynctimestamp，从方法的名字可以看出，把硬件VSYNC的时间戳信息添加这个对象中。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>bool VSyncReactor::addHwVsyncTimestamp(nsecs_t timestamp, std::optional&lt;nsecs_t&gt; hwcVsyncPeriod,
                                       bool* periodFlushed) {
    assert(periodFlushed);

    std::lock_guard lock(mMutex);
    if (periodConfirmed(timestamp, hwcVsyncPeriod)) {
        ATRACE_NAME(&quot;VSR: period confirmed&quot;);
        if (mPeriodTransitioningTo) {
            mTracker.setPeriod(*mPeriodTransitioningTo);
            *periodFlushed = true;
        }

        if (mLastHwVsync) {
            mTracker.addVsyncTimestamp(*mLastHwVsync);
        }
        mTracker.addVsyncTimestamp(timestamp);

        endPeriodTransition();
        mMoreSamplesNeeded = mTracker.needsMoreSamples();
    } else if (mPeriodConfirmationInProgress) {
        ATRACE_NAME(&quot;VSR: still confirming period&quot;);
        mLastHwVsync = timestamp;
        mMoreSamplesNeeded = true;
        *periodFlushed = false;
    } else {
        ATRACE_NAME(&quot;VSR: adding sample&quot;);
        *periodFlushed = false;
        mTracker.addVsyncTimestamp(timestamp);
        mMoreSamplesNeeded = mTracker.needsMoreSamples();
    }

    if (!mMoreSamplesNeeded) {
        setIgnorePresentFencesInternal(false);
    }
    return mMoreSamplesNeeded;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数有三个操作，首先会把当前的硬件上报的时间戳信息和当前的屏幕刷新率对于的固定period传入periodConfirmed方法中。这个periodConfirmed，就是确认是否有新的period设置进来，就是有没有发生屏幕刷新率切换。如果没有发生切换，这个函数默认返回false，如果没有发生刷新率切换，就是在保持同一个刷新率的情况下，最后走到else的逻辑中。也就是把timestamp这个变量添加到VsyncTracker对象中，然后调用该对象的needsMoreSamples方法判断要不要更多的样本，这边默认是6个样本，所以如果样本个数还没有达到，是需要一直增加样本到6个。就不需要样本了，就会把HW SYNC的硬件上报开关关闭掉。</p><p>可以说做2件事情：</p><ul><li><p>mTracker.addVsyncTimestamp方法，把样本加入到VsycnTracker的子类VsyncPredictor对象中。</p></li><li><p>通过needsMoreSamples方法，判断要不要获取更多的样本，如果样本足够，调用schedule的disableHardwareVsync函数，关闭硬件校准上报开关。</p></li></ul><h4 id="addvsynctimestamp" tabindex="-1"><a class="header-anchor" href="#addvsynctimestamp" aria-hidden="true">#</a> addVsyncTimestamp</h4><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/VSyncPredictor.cpp
bool VSyncPredictor::addVsyncTimestamp(nsecs_t timestamp) {
    std::lock_guard lock(mMutex);

    if (!validate(timestamp)) {
        // VSR could elect to ignore the incongruent timestamp or resetModel(). If ts is ignored,
        // don&#39;t insert this ts into mTimestamps ringbuffer. If we are still
        // in the learning phase we should just clear all timestamps and start
        // over.
        if (mTimestamps.size() &lt; kMinimumSamplesForPrediction) {
            // Add the timestamp to mTimestamps before clearing it so we could
            // update mKnownTimestamp based on the new timestamp.
            mTimestamps.push_back(timestamp);
            clearTimestamps();
        } else if (!mTimestamps.empty()) {
            mKnownTimestamp =
                    std::max(timestamp, *std::max_element(mTimestamps.begin(), mTimestamps.end()));
        } else {
            mKnownTimestamp = timestamp;
        }
        return false;
    }

    if (mTimestamps.size() != kHistorySize) {
        mTimestamps.push_back(timestamp);
        mLastTimestampIndex = next(mLastTimestampIndex);
    } else {
        mLastTimestampIndex = next(mLastTimestampIndex);
        mTimestamps[mLastTimestampIndex] = timestamp;
    }

    const size_t numSamples = mTimestamps.size();
    if (numSamples &lt; kMinimumSamplesForPrediction) {
        mRateMap[mIdealPeriod] = {mIdealPeriod, 0};
        return true;
    }

    // This is a &#39;simple linear regression&#39; calculation of Y over X, with Y being the
    // vsync timestamps, and X being the ordinal of vsync count.
    // The calculated slope is the vsync period.
    // Formula for reference:
    // Sigma_i: means sum over all timestamps.
    // mean(variable): statistical mean of variable.
    // X: snapped ordinal of the timestamp
    // Y: vsync timestamp
    //
    //         Sigma_i( (X_i - mean(X)) * (Y_i - mean(Y) )
    // slope = -------------------------------------------
    //         Sigma_i ( X_i - mean(X) ) ^ 2
    //
    // intercept = mean(Y) - slope * mean(X)
    //
    std::vector&lt;nsecs_t&gt; vsyncTS(numSamples);
    std::vector&lt;nsecs_t&gt; ordinals(numSamples);

    // Normalizing to the oldest timestamp cuts down on error in calculating the intercept.
    const auto oldestTS = *std::min_element(mTimestamps.begin(), mTimestamps.end());
    auto it = mRateMap.find(mIdealPeriod);
    auto const currentPeriod = it-&gt;second.slope;

    // The mean of the ordinals must be precise for the intercept calculation, so scale them up for
    // fixed-point arithmetic.
    constexpr int64_t kScalingFactor = 1000;

    nsecs_t meanTS = 0;
    nsecs_t meanOrdinal = 0;

    for (size_t i = 0; i &lt; numSamples; i++) {
        traceInt64If(&quot;VSP-ts&quot;, mTimestamps[i]);

        const auto timestamp = mTimestamps[i] - oldestTS;
        vsyncTS[i] = timestamp;
        meanTS += timestamp;

        const auto ordinal = (vsyncTS[i] + currentPeriod / 2) / currentPeriod * kScalingFactor;
        ordinals[i] = ordinal;
        meanOrdinal += ordinal;
    }

    meanTS /= numSamples;
    meanOrdinal /= numSamples;

    for (size_t i = 0; i &lt; numSamples; i++) {
        vsyncTS[i] -= meanTS;
        ordinals[i] -= meanOrdinal;
    }

    nsecs_t top = 0;
    nsecs_t bottom = 0;
    for (size_t i = 0; i &lt; numSamples; i++) {
        top += vsyncTS[i] * ordinals[i];
        bottom += ordinals[i] * ordinals[i];
    }

    if (CC_UNLIKELY(bottom == 0)) {
        it-&gt;second = {mIdealPeriod, 0};
        clearTimestamps();
        return false;
    }

    nsecs_t const anticipatedPeriod = top * kScalingFactor / bottom;
    nsecs_t const intercept = meanTS - (anticipatedPeriod * meanOrdinal / kScalingFactor);

    auto const percent = std::abs(anticipatedPeriod - mIdealPeriod) * kMaxPercent / mIdealPeriod;
    if (percent &gt;= kOutlierTolerancePercent) {
        it-&gt;second = {mIdealPeriod, 0};
        clearTimestamps();
        return false;
    }

    traceInt64If(&quot;VSP-period&quot;, anticipatedPeriod);
    traceInt64If(&quot;VSP-intercept&quot;, intercept);

    it-&gt;second = {anticipatedPeriod, intercept};

    ALOGV(&quot;model update ts: %&quot; PRId64 &quot; slope: %&quot; PRId64 &quot; intercept: %&quot; PRId64, timestamp,
          anticipatedPeriod, intercept);
    return true;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这块代码是SW 模型更新的核心，是最关键的部分，是通过硬件VSYNC的样本计算出当前屏幕刷新率对于的Vsync周期，在这个方法中，谷歌采用了简单一元线性回归分析预测法，回归分析是一种预测性的建模技术，它研究的是因变量和自变量之间的关系。它能够表明自多个自变量对一个因变量的影响强度。这种技术通常用于预测分析、时间序列模型以及发现变量之间的因果关系。回归分析是一种通过建立模型来研究变量之间相互关系的密切程度、结构状态及进行模型预测的有效工具，是建模和分析数据的重要工具。</p><p>由于很多现象需要多个因素做全面分析，只有当众多因素中确实存在一个对因变量影响作用明显高于其他因素的变量，才能将它作为自变量，应用一元相关的回归分析进行预测，而谷歌采用的是回归算法中的最小二乘法。</p><p><img src="/learn-android/aosp/surfaceflinger-vsync-5.png" alt=""></p><p>在这个方程式中，b就是回归系数，a就是截距。</p><p>如果提供了一组x因变量的一组数据，再提供一组y自变量的一组数据，就可以通过上面的方程式推导出回归系数b和截距a。</p><p>回到代码，按照默认的流程分析这个函数，首先有一个集合mTimestamps会存储硬件的VSYNC样本，刚开始的时候这个样本集合会清空，最多采6个样本就可以进行计算，简单描述上述代码的流程如下：</p><ul><li><p>清空mTimestamps的样本集合，打开硬件VSYNC开关，开始采集样本。</p></li><li><p>传入的时间戳会做一些校验工作，validate这个函数会对数据做一些处理，例如重复的数据等等。</p></li><li><p>如果传入的数据没有问题，则会一直添加到mTimestamps集合中，直到采6个样本信息就关闭VSYNC开关。</p></li><li><p>通过着6个样本，计算出x的因变量集合 ordinals，和y的自变量集合vsyncTS。通过6个样本把这两个集合的数据都计算出来，然后通过上面的方程式把回归系数和截距都计算出来，这块的回归系数就是Vsync的时间周期，前面我加过日志，我把这两个集合的内容可以贴出来看下，以下是90fps的vsync信息。</p></li></ul><p>x的集合内容 {0，1000，2000，3000，4000，5000} ，从集合的内容是vsync的个数信息。</p><p>y的集合内容{0，11027000，22053000，33080000，44106000，55132000}，从代码中了解是硬件vsync时间戳的递增值，因为两个硬件vsync的时间戳的差值可以理解是一个vsync周期。</p><ul><li>从这两个集合数据计算出回归系数b，和截距a，保存到当前的屏幕刷新率作为key的mRateMap的value中，这个value是一个结构体，保存两个值，当前屏幕刷新率对于的回归系数和截距。</li></ul><h4 id="nextanticipatedvsynctimefromlocked" tabindex="-1"><a class="header-anchor" href="#nextanticipatedvsynctimefromlocked" aria-hidden="true">#</a> nextAnticipatedVsyncTimeFromLocked</h4><p>有了这个回归系数和截距，就可以传入上一次app或者sf发射的时间，计算出下一次发射的时间 ，在前面讲解Vsync-sf的发射流程，有一个很重要的点就是要计算下一次发射的时间，就是调用VsyncTracker的nextAnticipatedVsyncTimeFromLocked方法。</p><p>代码如下：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/VSyncPredictor.cpp
nsecs_t VSyncPredictor::nextAnticipatedVSyncTimeFromLocked(nsecs_t timePoint) const {
    auto const [slope, intercept] = getVSyncPredictionModelLocked();

    if (mTimestamps.empty()) {
        traceInt64If(&quot;VSP-mode&quot;, 1);
        auto const knownTimestamp = mKnownTimestamp ? *mKnownTimestamp : timePoint;
        auto const numPeriodsOut = ((timePoint - knownTimestamp) / mIdealPeriod) + 1;
        return knownTimestamp + numPeriodsOut * mIdealPeriod;
    }

    auto const oldest = *std::min_element(mTimestamps.begin(), mTimestamps.end());

    // See b/145667109, the ordinal calculation must take into account the intercept.
    auto const zeroPoint = oldest + intercept;
    auto const ordinalRequest = (timePoint - zeroPoint + slope) / slope;
    auto const prediction = (ordinalRequest * slope) + intercept + oldest;

    traceInt64If(&quot;VSP-mode&quot;, 0);
    traceInt64If(&quot;VSP-timePoint&quot;, timePoint);
    traceInt64If(&quot;VSP-prediction&quot;, prediction);

    auto const printer = [&amp;, slope = slope, intercept = intercept] {
        std::stringstream str;
        str &lt;&lt; &quot;prediction made from: &quot; &lt;&lt; timePoint &lt;&lt; &quot;prediction: &quot; &lt;&lt; prediction &lt;&lt; &quot; (+&quot;
            &lt;&lt; prediction - timePoint &lt;&lt; &quot;) slope: &quot; &lt;&lt; slope &lt;&lt; &quot; intercept: &quot; &lt;&lt; intercept
            &lt;&lt; &quot;oldestTS: &quot; &lt;&lt; oldest &lt;&lt; &quot; ordinal: &quot; &lt;&lt; ordinalRequest;
        return str.str();
    };

    ALOGV(&quot;%s&quot;, printer().c_str());
    LOG_ALWAYS_FATAL_IF(prediction &lt; timePoint, &quot;VSyncPredictor: model miscalculation: %s&quot;,
                        printer().c_str());

    return prediction;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的代码可以看到这个流程。</p><ul><li><p>先判断mTimestamps的集合是否为空，如果为空，则拿默认值，90的帧率就是11.11111us去参与计算，mKnownTimestamp是之前样本的最大值，和传入上一次发射的时间做差值除Vsync的周期时间，我们理解样本的时间是比上一次的发射时间大，因为surfaceflinger在做合成的时候会把之前的fence时间的时间戳也存到这个集合中，这边会固定计算出下一个vsync发射的时间。</p></li><li><p>如果mTimestamps的集合不为空，通过这个集合的数据和传入的发射时间，算出一次线程回归方式的因变量x值，然后根据回归系数和截距，用方程式计算出自变量y值，而y值，也就是代码中的prediction，作为下一次vsync发射的时间。</p></li></ul><p>以上的两个函数是最核心的逻辑，然后有同学会问，什么时候会打硬件Vsync开关，什么时候会关闭。除了刚开机的时候，会打开硬件Vsync开关，如果模型校准完成之后，再关闭。还有切换刷新率的时候也会打开Vsycn开关。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void EventThread::requestNextVsync(const sp&lt;EventThreadConnection&gt;&amp; connection) {
    if (connection-&gt;resyncCallback) {
        connection-&gt;resyncCallback();
    }

    std::lock_guard&lt;std::mutex&gt; lock(mMutex);

    if (connection-&gt;vsyncRequest == VSyncRequest::None) {
        connection-&gt;vsyncRequest = VSyncRequest::Single;
        mCondition.notify_all();
    } else if (connection-&gt;vsyncRequest == VSyncRequest::SingleSuppressCallback) {
        connection-&gt;vsyncRequest = VSyncRequest::Single;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它会先调用connection的resyncCallback的方法。这个方法是创建这个Connection的时候，传入的回调函数。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
sp&lt;EventThreadConnection&gt; Scheduler::createConnectionInternal(
        EventThread* eventThread, ISurfaceComposer::EventRegistrationFlags eventRegistration) {
    return eventThread-&gt;createEventConnection([&amp;] { resync(); }, eventRegistration);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>等于每次app要申请的时候，会走到resyncAndRefresh中，这个函数就会强制进行一次硬件的VSYNC校准。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp
void Scheduler::resync() {
    static constexpr nsecs_t kIgnoreDelay = ms2ns(750);

    const nsecs_t now = systemTime();
    const nsecs_t last = mLastResyncTime.exchange(now);

    if (now - last &gt; kIgnoreDelay) {
        const auto refreshRate = [&amp;] {
            std::scoped_lock lock(mRefreshRateConfigsLock);
            return mRefreshRateConfigs-&gt;getActiveMode()-&gt;getFps();
        }();
        resyncToHardwareVsync(false, refreshRate);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>} 这个红色框框的部分，就是通知VsyncControler告诉VsyncTracker把时间戳清空掉，然后开始添加新的VSYNC时间戳信息，然后再进行校准。</p><p>除了上面的这种情况，还有一种情况，就是SurfaceFlinger再进行合成的时候，会把上一帧的完成合成的fence的时间也会同时添加到VsyncTracker的的时间戳集合。这个集合再情况的情况下，除了会增加6个硬件采样之外，这个集合也会添加fence的时间信息。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp

if (display &amp;&amp; display-&gt;isInternal() &amp;&amp; display-&gt;getPowerMode() == hal::PowerMode::ON &amp;&amp;
    mPreviousPresentFences[0].fenceTime-&gt;isValid()) {
    mScheduler-&gt;addPresentFence(mPreviousPresentFences[0].fenceTime);
}

void Scheduler::addPresentFence(const std::shared_ptr&lt;FenceTime&gt;&amp; fenceTime) {
    if (mVsyncSchedule.controller-&gt;addPresentFence(fenceTime)) {
        enableHardwareVsync();
    } else {
        disableHardwareVsync(false);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上图的代码所示，我们通过给VsyncController中添加fence的时间信息，也会判断当前要不要打开Vsync进行校准，但是默认都是不打开VSYNC校准的，因为每一帧的合成都会把fence的时间传入到这个VsyncTracker中的时间戳集合中，所以这个函数会每次合成的时候都会重新计算回归系数和截距。</p><ul><li><p>从HWC获取的display完成显示的fence， HW VSYNC就是display显示完成后发出来的，因此这个fence的时间戳可以看作是发射HW VSYNC的恰当时刻，虽然HW VSYNC可能已经关闭了。</p></li><li><p>将fence样本加入到VsyncTracker中，会重新校准出新的Vsync周期，如果再校准中的过程中发生误差过大，会重新打开HW VSYNC进行校准，所谓的校准，就是重新采集HW VSYNC样本，重新计算出新的回归习系数（vsync周期）和截距。</p></li></ul><p>以上就是在SurfaceFlinger的postComposition中一直调用的方法。</p><h2 id="dumpsys-surfaceflinger" tabindex="-1"><a class="header-anchor" href="#dumpsys-surfaceflinger" aria-hidden="true">#</a> dumpsys SurfaceFlinger</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>VsyncDispatch:
        Timer:
                DebugState: Waiting
        mTimerSlack: 0.50ms mMinVsyncDistance: 3.00ms
        mIntendedWakeupTime: 9223372013568.00ms from now
        mLastTimerCallback: 16057.86ms ago mLastTimerSchedule: 16049.38ms ago
        Callbacks:
                sf:
                        workDuration: 15.67ms readyDuration: 0.00ms earliestVsync: -20259.13ms relative to now
                        mLastDispatchTime: 16059.13ms ago
                appSf:
                        workDuration: 16.67ms readyDuration: 15.67ms earliestVsync: -52892.46ms relative to now
                        mLastDispatchTime: 52892.46ms ago
                app:
                        workDuration: 16.67ms readyDuration: 15.67ms earliestVsync: -16025.80ms relative to now
                        mLastDispatchTime: 16025.80ms ago
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2><ul><li><a href="https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/#/%E4%B8%8D%E4%BD%BF%E7%94%A8HW-VSYNC" target="_blank" rel="noopener noreferrer">https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync/#/不使用HW-VSYNC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://source.android.google.cn/docs/core/graphics?authuser=0#android-graphics-components" target="_blank" rel="noopener noreferrer">https://source.android.google.cn/docs/core/graphics?authuser=0#android-graphics-components<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://source.android.com/docs/core/graphics/implement-vsync?hl=zh-cn" target="_blank" rel="noopener noreferrer">https://source.android.com/docs/core/graphics/implement-vsync?hl=zh-cn<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://juejin.cn/post/7081614840606785550" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7081614840606785550<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.jianshu.com/p/304f56f5d486" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/304f56f5d486<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://blog.csdn.net/Android062005/article/details/123090139" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/Android062005/article/details/123090139<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://android-developers.googleblog.com/2020/04/high-refresh-rate-rendering-on-android.html" target="_blank" rel="noopener noreferrer">https://android-developers.googleblog.com/2020/04/high-refresh-rate-rendering-on-android.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://utzcoz.github.io/2020/05/02/Analyze-AOSP-vsync-model.html" target="_blank" rel="noopener noreferrer">https://utzcoz.github.io/2020/05/02/Analyze-AOSP-vsync-model.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://utzcoz.github.io/2020/04/29/Print-call-stack-in-AOSP-native-code.html" target="_blank" rel="noopener noreferrer">https://utzcoz.github.io/2020/04/29/Print-call-stack-in-AOSP-native-code.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/roger-yu/p/16230337.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/roger-yu/p/16230337.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/roger-yu/p/16162940.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/roger-yu/p/16162940.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/roger-yu/p/16162940.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/roger-yu/p/16162940.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/roger-yu/p/15761646.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/roger-yu/p/15761646.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/roger-yu/p/16075956.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/roger-yu/p/16075956.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/roger-yu/p/15641545.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/roger-yu/p/15641545.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/roger-yu/p/16122236.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/roger-yu/p/16122236.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/roger-yu/p/15596840.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/roger-yu/p/15596840.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://juejin.cn/post/7166061140298956836" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7166061140298956836<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.jianshu.com/p/5e9c558d1543" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/5e9c558d1543<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/roger-yu/p/15761646.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/roger-yu/p/15761646.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://cs.android.com/android/platform/superproject/+/android-13.0.0_r41:frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp?hl=zh-cn" target="_blank" rel="noopener noreferrer">https://cs.android.com/android/platform/superproject/+/android-13.0.0_r41:frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp?hl=zh-cn<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://cs.android.com/android/platform/superproject/+/android-13.0.0_r41:frameworks/native/services/surfaceflinger/SurfaceFlingerFactory.cpp;l=26?q=createSurfaceFlinger&amp;ss=android%2Fplatform%2Fsuperproject&amp;hl=zh-cn" target="_blank" rel="noopener noreferrer">https://cs.android.com/android/platform/superproject/+/android-13.0.0_r41:frameworks/native/services/surfaceflinger/SurfaceFlingerFactory.cpp;l=26?q=createSurfaceFlinger&amp;ss=android%2Fplatform%2Fsuperproject&amp;hl=zh-cn<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.jianshu.com/p/5e9c558d1543" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/5e9c558d1543<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: biezhihua@gmail.com">biezhihua</span><!--]--><!--]--></div></div></footer><!----><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-ea0f097a.js" defer></script>
  </body>
</html>
